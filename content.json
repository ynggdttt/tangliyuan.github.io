{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"油腻高贵的唐怂怂","date":"2019-02-15T10:45:41.000Z","updated":"2019-02-16T13:24:04.094Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me12345&lt;profile&gt; &lt;name&gt; ynggdttt &lt;/name&gt; &lt;email&gt; tangliyuan@sjtu.edu.cn &lt;/email&gt; &lt;location&gt; Shanghai, China &lt;/location&gt;&lt;/profile&gt; Tags Related: Coding, IT, Capturing, Reading, Books, Movies, fans of Maobuyi, Traveling, Music…… FAQ: 为什么叫 ynggdttt ？简单的不能再简单的翻译–油腻高贵的糖糖糖，2018年5月份粉上了毛不易先生，仔细想想能拿到 一句话描述自己：一个对曾以为自己很特别，现在逐渐接受也甘于平凡的人。 If you want to know more, contact me via my private WeChat account: zanglingyangshashou or email."}],"posts":[{"title":"【Leetcode】144. 二叉树的前序遍历","slug":"【Leetcode】144-二叉树的前序遍历","date":"2019-07-27T02:17:49.000Z","updated":"2019-07-27T03:39:50.623Z","comments":true,"path":"2019/07/27/【Leetcode】144-二叉树的前序遍历/","link":"","permalink":"http://yoursite.com/2019/07/27/【Leetcode】144-二叉树的前序遍历/","excerpt":"","text":"题目 判断是否是对称二叉树给定一个二叉树，返回它的 前序 遍历。 案例中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 12345678 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 递归思路前序遍历：中左右；首先将根结点压入结果，然后不断的递归左子树和右子树； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; dfs(root, res); return res; &#125; void dfs(TreeNode* root, vector&lt;int&gt; &amp;res)&#123; if(!root) return; res.push_back(root-&gt;val); dfs(root-&gt;left, res); dfs(root-&gt;right, res); &#125;&#125;; 非递归思路1 在第二次访问的时候，压入结果并且弹出； 第二次既该节点作为子树的根结点的时候； 首先左子树然后然转向右子树，利用栈进行存储；代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; TreeNode* T = root; while(T || !s.empty())&#123; while(T)&#123;//找到最底层的左子树 res.push_back(T-&gt;val); s.push(T); T = T-&gt;left; &#125; if(!s.empty())&#123;//处理节点并且 T = s.top(); T = T-&gt;right; s.pop(); &#125; &#125; return res; &#125;&#125;; 非递归思路2 无论是前序还是中序还是后序；走的路径都是一样的，每个点都会被遍历三遍； 所以用一个pre指针和一个cur指针； 如果pre-&gt;left == cur 或者pre-&gt;right == cur，那么说明cur是第一次被遍历到； 如果cur-&gt;left == pre ，说明是第二次被遍历到； 如果cur-&gt;right == pre,说明是第三次遍历； 我们在第三次遍历到的时候再pop出去； 对于叶节点来讲，也会被遍历三次，但是实际上三次都是自己，所以当pre == cur的时候（也可能是右子树没有的节点），就是叶节点直接pop的时候； 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; s.push(root); TreeNode* pre = NULL, *cur = NULL; while(!s.empty())&#123; cur = s.top(); if(pre == NULL || pre-&gt;left == cur || pre-&gt;right == cur)&#123; res.push_back(cur-&gt;val); if(cur-&gt;left) s.push(cur-&gt;left); else if(cur-&gt;right) s.push(cur-&gt;right); &#125; else if(cur-&gt;left == pre)&#123; if(cur-&gt;right) s.push(cur-&gt;right); &#125; else&#123; s.pop(); &#125; pre = cur; &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"}]},{"title":"【Leetcode】94. 二叉树的中序遍历","slug":"【Leetcode】94-二叉树的中序遍历","date":"2019-07-25T05:41:28.000Z","updated":"2019-07-25T05:41:28.697Z","comments":true,"path":"2019/07/25/【Leetcode】94-二叉树的中序遍历/","link":"","permalink":"http://yoursite.com/2019/07/25/【Leetcode】94-二叉树的中序遍历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【面试】面向对象的理解","slug":"【面试】面向对象的理解","date":"2019-07-22T14:53:09.000Z","updated":"2019-07-22T15:00:45.582Z","comments":true,"path":"2019/07/22/【面试】面向对象的理解/","link":"","permalink":"http://yoursite.com/2019/07/22/【面试】面向对象的理解/","excerpt":"","text":"怎么理解面向对象对面向对象的理解 在我理解,面向对象是向现实世界模型的自然延伸，这是一种“万物皆对象”的编程思想。在现实生活中的任何物体都可以归为一类事物，而每一个个体都是一类事物的实例。面向对象的编程是以对象为中心，以消息为驱动，所以程序=对象+消息。 面向对象有三大特性，封装、继承和多态。 封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化。这样做使得代码的复用性更高。 继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类–有父类的行为和属性，也有自己特有的行为和属性。这样做扩展了已存在的代码块，进一步提高了代码的复用性。 如果说封装和继承是为了使代码重用，那么多态则是为了实现接口重用。多态的一大作用就是为了解耦–为了解除父子类继承的耦合度。如果说继承中父子类的关系式IS-A的关系，那么接口和实现类之之间的关系式HAS-A。简单来说，多态就是允许父类引用(或接口)指向子类(或实现类)对象。很多的设计模式都是基于面向对象的多态性设计的。 总结一下，如果说封装和继承是面向对象的基础，那么多态则是面向对象最精髓的理论。掌握多态必先了解接口，只有充分理解接口才能更好的应用多态。 作者：samhan0616来源：CSDN原文：https://blog.csdn.net/weixin_40066829/article/details/78111476版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/tags/Cplusplus/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}]},{"title":"【Leetcode】85. 最大矩形","slug":"【Leetcode】85-最大矩形","date":"2019-07-16T03:36:22.000Z","updated":"2019-07-16T08:10:18.148Z","comments":true,"path":"2019/07/16/【Leetcode】85-最大矩形/","link":"","permalink":"http://yoursite.com/2019/07/16/【Leetcode】85-最大矩形/","excerpt":"","text":"题目 最大矩形给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 案例示例 1:12345678输入:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出: 6 思路 把每一层分别当成底部，算能形成的矩形的面试，就是84题一样的 [84、柱状图中最大的矩形]（https://ynggdttt.github.io/2019/07/16/【Leetcode】84-柱状图中最大的矩形/） 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; tem; int res = 0; for(int i = 0; i &lt; matrix.size(); i++)&#123; tem.resize(matrix[i].size()); for(int j = 0; j &lt; tem.size(); j++)&#123; if(matrix[i][j] == '0') tem[j] = 0; else tem[j]++; &#125; int re = helper(tem); res = max(res,re); &#125; return res; &#125; int helper(vector&lt;int&gt; &amp;tem)&#123; int n = tem.size(); int res = 0; for(int i = 0; i &lt; n; i++)&#123; if(i + 1 &lt; n &amp;&amp; tem[i] &lt; tem[i+1]) continue; int mi = tem[i]; for(int j = i; j &gt;= 0; j--)&#123; mi = min(mi, tem[j]); res = max(mi*(i - j + 1),res); &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"hard","slug":"hard","permalink":"http://yoursite.com/tags/hard/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"【Leetcode】84. 柱状图中最大的矩形","slug":"【Leetcode】84-柱状图中最大的矩形","date":"2019-07-16T03:05:14.000Z","updated":"2019-07-16T03:37:10.818Z","comments":true,"path":"2019/07/16/【Leetcode】84-柱状图中最大的矩形/","link":"","permalink":"http://yoursite.com/2019/07/16/【Leetcode】84-柱状图中最大的矩形/","excerpt":"","text":"题目 柱状图中最大的矩形给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 案例示例 1:12输入: [2,1,5,6,2,3]输出: 10 思路 找到局部最大，然后判断从头到这个地方的最大的矩形面积； 具体是找到到当前的最小值，然后乘以宽； 两种做法，一种是直接遍历，找到比后一个小的，另一种是用栈； 代码1234567891011121314151617class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; for(int i = 0; i &lt; heights.size(); i++)&#123; if(i + 1 &lt; heights.size() &amp;&amp; heights[i] &lt;= heights[i+1]) continue; int maxH = heights[i], minH = heights[i]; for(int j = i - 1; j &gt;= 0; j--)&#123; minH = min(minH, heights[j]); maxH = max(maxH, minH * (i - j + 1)); &#125; res = max(res, maxH); &#125; return res; &#125;&#125;; class Solution { public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int res = 0; stack&lt;int&gt; s; heights.push_back(0); for(int i = 0; i &lt; heights.size() - 1; i++){ //if(heights[i] &lt;= heights[i+1]) s.push(i); if(heights[i] &gt; heights[i+1]){ int mi = heights[i]; //res = max(heights[i],res); //int re = heights[i]; while(!s.empty()){ int t = s.top(); s.pop(); mi = min(mi,heights[t]); res = max(res, mi * (i - t + 1)); } for(int j = 0; j &lt;= i; j++) s.push(j); } } return res; } };","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"hard","slug":"hard","permalink":"http://yoursite.com/tags/hard/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"【Leetcode】149. 直线上最多的点数","slug":"【Leetcode】149-直线上最多的点数","date":"2019-07-16T02:42:42.000Z","updated":"2019-07-16T02:51:16.776Z","comments":true,"path":"2019/07/16/【Leetcode】149-直线上最多的点数/","link":"","permalink":"http://yoursite.com/2019/07/16/【Leetcode】149-直线上最多的点数/","excerpt":"","text":"题目 加一给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。 案例示例 1:12345678910输入: [[1,1],[2,2],[3,3]]输出: 3解释:^|| o| o| o +-------------&gt;0 1 2 3 4 1234567891011输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]输出: 4解释:^|| o| o o| o| o o+-------------------&gt;0 1 2 3 4 5 6 思路 考虑利用斜率解决问题，但是因为斜率可能有小数，更像是一个方向向量，所以推荐用除以最大公约数来做； 考虑可能求出来的公约数是0，那么这种情况实际是发生了重合的点，那么我们要对重合的点做一个特别的累积； 利用map来存储，存储每个方向向量上包含的点有多少，需要对每个点都做一遍这个操作； 时间复杂度是O（N^2）,空间复杂度是O（N）； 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int res = 0; int n = points.size(); map&lt;vector&lt;int&gt;,int&gt; m; for(int i = 0; i &lt; n; i++)&#123; int equal = 1; int x = points[i][0], y = points[i][1]; m.clear();//每次要清除 for(int j = i + 1; j &lt; n; j++)&#123; if(i == j) continue; int xt = points[j][0], yt = points[j][1]; if(xt == x &amp;&amp; yt == y) &#123;equal++; continue;&#125;;//判断是否是重合点 int dx = x - xt, dy = y - yt; int d = gcd(dx, dy); m[&#123;dx/d, dy/d&#125;]++; &#125; if(m.empty()) res = max(res, equal); else&#123; for(auto a : m)&#123; res = max(res, a.second + equal); &#125; &#125; &#125; return res; &#125; int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"http://yoursite.com/tags/哈希/"},{"name":"hard","slug":"hard","permalink":"http://yoursite.com/tags/hard/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"【golang】","slug":"【golang】","date":"2019-07-13T15:18:21.000Z","updated":"2019-07-13T15:42:41.267Z","comments":true,"path":"2019/07/13/【golang】/","link":"","permalink":"http://yoursite.com/2019/07/13/【golang】/","excerpt":"","text":"golang go的调度goroutine 协程（GPM模型）就随机选择另外一个P，从其可执行的G队列中偷取一半（work-stealing调度算法）https://cloud.tencent.com/developer/article/1399244https://www.cnblogs.com/wdliu/p/9272220.html channel 是符合类型利用channel 来同步可以用select在协程中进行选择；如何关闭https://blog.csdn.net/qq_33296108/article/details/82731686 channel 缓冲ch := make(chan int, n) slice相当于动态数据，维护struct；https://www.jianshu.com/p/19a38629b3d9copy 函数的话，就是覆盖前多少个； map key-value 判断key是否存在； 必须初始化； 是引用类型； 遍历是无序的； map顺序输出，把key存在数组里，然后再去输出； 和c++的区别（红黑树和hashtable） map是非并发安全的； go的new和make区别https://www.jianshu.com/p/c173dab0e71cnew和make都在堆上分配内存，但是它们的行为不同，适用于不同的类型。new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T{}。make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：slice、map 和 channel。换言之，new 函数分配内存，make 函数初始化； defer在return之后执行的；后进先出；https://studygolang.com/articles/10167 reflecthttps://www.cnblogs.com/cxiaojia/p/6193606.html我用在数据库迁移，因为有很多的表，每次要从表中取出，然后再Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:(value, type) reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型 reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值 也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种 为什么要序列化成json","categories":[{"name":"语言","slug":"语言","permalink":"http://yoursite.com/categories/语言/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"【内存泄漏】","slug":"【内存泄漏】","date":"2019-07-13T11:15:39.000Z","updated":"2019-07-13T15:16:46.132Z","comments":true,"path":"2019/07/13/【内存泄漏】/","link":"","permalink":"http://yoursite.com/2019/07/13/【内存泄漏】/","excerpt":"","text":"https://www.cnblogs.com/liushui-sky/p/7727865.html 在类的构造函数和析构函数中没有匹配的调用new和delete函数两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存 在释放对象数组时在delete中没有使用方括号方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。 释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。 对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了 缺少拷贝构造函数浅拷贝两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。 按值传递会调用（拷贝）构造函数，引用传递不会调用。 在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。 所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符 C++中构造函数，拷贝构造函数和赋值函数的区别和实现参见：http://www.cnblogs.com/liushui-sky/p/7728902.html 缺少重载赋值运算符 这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露 关于nonmodifying运算符重载的常见迷思 a. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针 b. 返回内部静态对象的引用。 c. 返回一个泄露内存的动态分配的对象。导致内存泄露，并且无法回收 解决这一类问题的办法是重载运算符函数的返回值不是类型的引用，二应该是类型的返回值，即不是 int&amp;而是int 没有将基类的析构函数定义为虚函数当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露 造成野指针的原因：指针变量没有被初始化（如果值不定，可以初始化为NULL）指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/tags/Cplusplus/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://yoursite.com/tags/内存泄漏/"}]},{"title":"【数据库引擎】","slug":"【数据库引擎】","date":"2019-07-13T06:37:58.000Z","updated":"2019-07-13T07:41:52.593Z","comments":true,"path":"2019/07/13/【数据库引擎】/","link":"","permalink":"http://yoursite.com/2019/07/13/【数据库引擎】/","excerpt":"","text":"来源 什么是引擎数据库引擎是用于存储、处理和保护数据的核心服务。MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。 如何存储数据 如何为存储的数据建立索引 如何更新、查询数据 等技术的实现方法。 Mysql数据库的引擎InnoDBInnoDB是一个健壮的*事务型 存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。使用场合 更新密集的表。 InnoDB存储引擎特别适合处理多重并发的更新请求。 事务。 InnoDB存储引擎是支持事务的标准MySQL存储引擎。 自动灾难恢复。 与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。 外键约束。 MySQL支持外键的存储引擎只有InnoDB。 支持自动增加列AUTO_INCREMENT属性。 从5.7开始innodb存储引擎成为默认的存储引擎。一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。 MyISAM MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器。 每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：tb_demo.frm，存储表定义。tb_demo.MYD，存储数据。tb_demo.MYI，存储索引。 MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。 使用场合 选择密集型的表。 MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。 插入密集型的表。 MyISAM的并发插入特性允许同时选择和插入数据。 由此看来，MyISAM存储引擎很适合管理服务器日志数据。 MRG_MYISAM MRG_MyISAM存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同； 对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间段相关；例如，可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。 MEMORY 使用MySQL Memory存储引擎的出发点是速度，为得到最快的响应时间，采用的逻辑存储介质是系统内存。 缺点 虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。 它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。 使用场合 目标数据较小，而且被非常频繁地访问。 在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。 如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。 存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。 Memory同时支持散列索引和B树索引。 CSV CSV 存储引擎是基于 CSV 格式文件存储数据。 CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。 CSV 引擎也不支持索引，不支持分区。 CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为CSM，用来保存表的状态及表中保存的数据量。 每个数据行占用一个文本行。 因为 csv 文件本身就可以被Office等软件直接编辑，保不齐就有不按规则出牌的情况，如果出现csv 文件中的内容损坏了的情况，也可以使用 CHECK TABLE 或者 REPAIR TABLE 命令检查和修复。 ARCHIVEArchive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。 在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。 Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。 BLACKHOLE MySQL在5.x系列提供了Blackhole引擎–“黑洞”，其作用正如其名字一样：任何写入到此引擎的数据均会被丢弃掉， 不做实际存储；Select语句的内容永远是空。 Blackhole虽然不存储数据，但是MySQL还是会正常的记录下Binlog，而且这些Binlog还会被正常的同步到Slave上，可以在Slave上对数据进行后续的处理。关于binglog 使用场合 验证语法 验证dump file语法的正确性 检测负载 以使用blackhole引擎来检测binlog功能所需要的额外负载 检测性能 由于blackhole性能损耗极小，可以用来检测除了存储引擎这个功能点之外的其他MySQL功能点的性能。 PERFORMANCE_SCHEMA主要用于收集数据库服务器性能参数。 MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。 FEDERATED主要用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取；在MariaDB上的实现是FederatedX。 #存储引擎相关操作命令 存储引擎相关操作命令 SHOW ENGINES； 在创建表的时候，对表设置存储引擎 CREATE TABLE user ( id int(100) unsigned NOT NULL AUTO_INCREMENT, name varchar(32) NOT NULL DEFAULT ‘’ COMMENT ‘姓名’, mobile varchar(20) NOT NULL DEFAULT ‘’ COMMENT ‘手机’, PRIMARY KEY (id))ENGINE=InnoDB; 选择数据库引擎的时候要注意 是否需要支持事务； 是否需要使用热备； 崩溃恢复，能否接受崩溃； 是否需要外键支持； 存储的限制； 对索引和缓存的支持。 各个引擎对比","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"引擎","slug":"引擎","permalink":"http://yoursite.com/tags/引擎/"}]},{"title":"Leetcode】66. 加一","slug":"【Leetcode】66-加一","date":"2019-07-11T06:41:23.000Z","updated":"2019-07-11T06:46:38.831Z","comments":true,"path":"2019/07/11/【Leetcode】66-加一/","link":"","permalink":"http://yoursite.com/2019/07/11/【Leetcode】66-加一/","excerpt":"","text":"题目 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 案例示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 思路 考虑只有9+1才会进位； 先从后往前，如果是是连续的9，就设置为0，直至不是9； 然后把退出的那位+1； 如果全是9，就在0的位置插入1； 代码1234567891011121314class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int i = digits.size() - 1; while(i &gt;= 0 &amp;&amp; digits[i] == 9)&#123; digits[i--] = 0; &#125; if(i &lt; 0) digits.insert(digits.begin(),1); else digits[i]++; return digits; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"【Leetcode】64. 最小路径和","slug":"【Leetcode】64-最小路径和","date":"2019-07-11T06:32:25.000Z","updated":"2019-07-11T06:36:25.807Z","comments":true,"path":"2019/07/11/【Leetcode】64-最小路径和/","link":"","permalink":"http://yoursite.com/2019/07/11/【Leetcode】64-最小路径和/","excerpt":"","text":"题目 最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 案例示例 1:12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 思路 利用dp,递归数组为dp[i][j] = min(dp[i][j + 1],dp[i+1][j]) + grid[i][j]; 首先初始化dp数组的右边和下边； 代码1234567891011121314151617181920class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.empty()) return 0; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,grid[m-1][n-1])); for(int i = m - 2; i &gt;= 0; i--)&#123; dp[i][n-1] = dp[i+1][n-1] + grid[i][n-1]; &#125; for(int i = n - 2; i &gt;= 0; i--)&#123; dp[m-1][i] = dp[m-1][i+1] + grid[m-1][i]; &#125; for(int i = m - 2; i &gt;= 0; i--)&#123; for(int j = n - 2; j &gt;= 0; j--)&#123; dp[i][j] = min(dp[i][j + 1],dp[i+1][j]) + grid[i][j]; &#125; &#125; return dp[0][0]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"【Leetcode】63. 不同路径 II","slug":"【Leetcode】63-不同路径-II","date":"2019-07-11T06:26:19.000Z","updated":"2019-07-11T06:40:04.486Z","comments":true,"path":"2019/07/11/【Leetcode】63-不同路径-II/","link":"","permalink":"http://yoursite.com/2019/07/11/【Leetcode】63-不同路径-II/","excerpt":"","text":"题目 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。 案例示例 1:123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 思路 利用dp,递归数组为dp[i][j] = dp[i-1][j] + dp[i][j - 1]; 对于障碍物的情况，首先确定右边界和下边界，如果是已经有障碍物了，那么左边或者上边都是0； 遍历的时候考虑，是不是有障碍物，有的话，就设置为0； 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.empty()) return 0; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;long int&gt; &gt;dp(m, vector&lt;long int&gt;(n,1)); if(obstacleGrid[m - 1][n - 1] == 1) return 0; //确定初始的值 for(int i = 1; i &lt; m; i++)&#123; if(obstacleGrid[m - 1 - i][n - 1] == 1)&#123; for(int j = i; j &lt; m; j++) dp[j][0] = 0; break; &#125; &#125; for(int i = 1; i &lt; n; i++)&#123; if(obstacleGrid[m - 1][n - 1 - i] == 1)&#123; for(int j = i; j &lt; n; j++) dp[0][j] = 0; break; &#125; &#125; //遍历 for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; if(obstacleGrid[m - 1 - i][n - 1 - j] == 1) dp[i][j] = 0; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"【Leetcode】62. 不同路径","slug":"【Leetcode】62-不同路径","date":"2019-07-11T03:38:34.000Z","updated":"2019-07-11T06:22:41.710Z","comments":true,"path":"2019/07/11/【Leetcode】62-不同路径/","link":"","permalink":"http://yoursite.com/2019/07/11/【Leetcode】62-不同路径/","excerpt":"","text":"题目 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 案例示例 1:1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2:12输入: m = 7, n = 3输出: 28 思路 利用dp,递归数组为dp[i][j] = dp[i-1][j] + dp[i][j - 1]; 边界右和下均为1； 这里设置的是反着的，注意一下哈，也可以正着； 也可以空间复杂度没那么高，只有n也可以；代码123456789101112class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n,1)); for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j - 1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;int&gt; dp(n,1); for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; dp[j] = dp[j] + dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"【指针和引用】","slug":"【指针和引用】","date":"2019-07-09T13:57:44.000Z","updated":"2019-07-09T15:12:42.496Z","comments":true,"path":"2019/07/09/【指针和引用】/","link":"","permalink":"http://yoursite.com/2019/07/09/【指针和引用】/","excerpt":"","text":"指针和引用的区别1.指针有自己的一块空间，而引用只是一个别名； 2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小； 3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用； 4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象； 5.可以有const指针，但是没有const引用； 解释引用可以指向常量，也可以指向变量。例如int &amp;a=b，使引用a指向变量b。而为了让引用指向常量，必须使用常量引用，如const int &amp;a=1; 它代表的是引用a指向一个const int型，这个int型的值不能被改变，而不是引用a的指向不能被改变，因为引用的指向本来就是不可变的，无需加const声明。即指针存在常量指针int const p和指针常量int const p，而引用只存在常量引用int const &amp;a，不存在引用常量int&amp; const a。 6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变； 7.指针可以有多级指针（**p），而引用至于一级； 8.指针和引用使用++运算符的意义不一样； 9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/指针/"},{"name":"引用","slug":"引用","permalink":"http://yoursite.com/tags/引用/"}]},{"title":"【缓存】","slug":"【缓存】","date":"2019-07-08T01:39:50.000Z","updated":"2019-07-08T01:51:55.862Z","comments":true,"path":"2019/07/08/【缓存】/","link":"","permalink":"http://yoursite.com/2019/07/08/【缓存】/","excerpt":"","text":"缓存缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，https://blog.csdn.net/weixin_43538815/article/details/84559933","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"}]},{"title":"【Leetcode】42. 接雨水","slug":"【Leetcode】42-接雨水","date":"2019-07-06T07:44:59.000Z","updated":"2019-07-06T08:37:04.560Z","comments":true,"path":"2019/07/06/【Leetcode】42-接雨水/","link":"","permalink":"http://yoursite.com/2019/07/06/【Leetcode】42-接雨水/","excerpt":"","text":"题目 组合总和 II给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 案例示例 1:12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 思路 首先找到最大的那个，然后分成左右两边； 对左边的，从左向右遍历；如果比当前的值大，就替换，否则相减，就是当前的能盛水的； 对右边的，从右向左遍历；如果比当前的值大，就替换，否则相减，就是当前的能盛水的； 代码12345678910111213141516171819202122232425262728class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n &lt;= 2) return 0; //找最大值 int maxt = height[0], index = 0; for(int i = 1; i &lt; n; i++)&#123; if(height[i] &gt; maxt)&#123; maxt = height[i]; index = i; &#125; &#125; //找左侧的 int maxl = height[0], res = 0; for(int i = 1; i &lt; index; i++)&#123; if(height[i] &gt; maxl) maxl = height[i]; else res += maxl - height[i]; &#125; //找右侧的 int maxr = height[n - 1]; for(int i = n -1; i &gt; index; i--)&#123; if(height[i] &gt; maxr) maxr = height[i]; else res += maxr - height[i]; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"困难","slug":"困难","permalink":"http://yoursite.com/tags/困难/"},{"name":"递减序列","slug":"递减序列","permalink":"http://yoursite.com/tags/递减序列/"},{"name":"递增序列","slug":"递增序列","permalink":"http://yoursite.com/tags/递增序列/"}]},{"title":"【Leetcode】41. 缺失的第一个正数","slug":"【Leetcode】41-缺失的第一个正数","date":"2019-07-06T07:15:12.000Z","updated":"2019-07-06T07:27:23.376Z","comments":true,"path":"2019/07/06/【Leetcode】41-缺失的第一个正数/","link":"","permalink":"http://yoursite.com/2019/07/06/【Leetcode】41-缺失的第一个正数/","excerpt":"","text":"题目 组合总和 II给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 案例示例 1: 输入:12输入: [1,2,0]输出: 3 案例2:12输入: [3,4,-1,1]输出: 2 案例3:12输入: [7,8,9,11,12]输出: 1 思路因为题目中要求是时间复杂度不超过O（n）,空间复杂度要为常数空间，总体的思路就是把所有的位置放回原位，然后从前向后遍历； 具体的实现就是，当这个数是1-n之间的，且这个数组本应该对应的那个位置上没有正确的数，就把两个交换，直至该位置上的数不满足条件位置； 特别注意的是，要把这个位置上的都处理好再进行下一个位置的； 代码1234567891011121314151617class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i = 0; i &lt; n; i++)&#123; while(i &lt; n &amp;&amp; nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i])&#123; swap(nums[i], nums[nums[i] - 1]); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(nums[i] != i + 1)&#123; return i + 1; &#125; &#125; return n + 1; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"困难","slug":"困难","permalink":"http://yoursite.com/tags/困难/"},{"name":"变换下标","slug":"变换下标","permalink":"http://yoursite.com/tags/变换下标/"}]},{"title":"【英文】","slug":"【英文】","date":"2019-07-06T03:01:05.000Z","updated":"2019-07-06T03:12:02.927Z","comments":true,"path":"2019/07/06/【英文】/","link":"","permalink":"http://yoursite.com/2019/07/06/【英文】/","excerpt":"","text":"算法 回溯算法：Backtracking Algorithm； 时间复杂度：Time Complexity； 空间复杂度：space complexity;","categories":[{"name":"专业术语","slug":"专业术语","permalink":"http://yoursite.com/categories/专业术语/"}],"tags":[{"name":"英文表达","slug":"英文表达","permalink":"http://yoursite.com/tags/英文表达/"}]},{"title":"【Leetcode】40. 组合总和 II","slug":"【Leetcode】40-组合总和-II","date":"2019-07-06T02:51:37.000Z","updated":"2019-07-06T03:58:44.886Z","comments":true,"path":"2019/07/06/【Leetcode】40-组合总和-II/","link":"","permalink":"http://yoursite.com/2019/07/06/【Leetcode】40-组合总和-II/","excerpt":"","text":"题目 组合总和 II给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 案例示例 1: 输入:12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 案例2:123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 思路 很典型的dfs思想，回溯算法 三步，定义一个存储的中间变量，最终结果，起始位置； 递归兜底条件是target == 0,或者target &lt; 0; 回溯的过程记得pop出来，恢复上一个状态； 关键的点在不可以重复； 如果和前面的重复，要去重； 所以要排序，才好去重； 类似题目39,组合总和 代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(target == 0) return res; vector&lt;int&gt; cur; sort(candidates.begin(),candidates.end()); helper(candidates, target, 0, res, cur); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates, int target, int pos, vector&lt;vector&lt;int&gt; &gt;&amp;res, vector&lt;int&gt; cur)&#123; if(target == 0)&#123; res.push_back(cur); return; &#125; if(target &lt; 0) return; for(int i = pos; i &lt; candidates.size(); i++)&#123; if(i &gt; pos &amp;&amp; candidates[i] == candidates[i - 1]) continue; cur.push_back(candidates[i]); helper(candidates,target - candidates[i], i + 1, res, cur); cur.pop_back(); &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/回溯/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"}]},{"title":"【Leetcode】39. 组合总和","slug":"【Leetcode】39-组合总和","date":"2019-07-06T02:51:14.000Z","updated":"2019-07-06T03:56:55.873Z","comments":true,"path":"2019/07/06/【Leetcode】39-组合总和/","link":"","permalink":"http://yoursite.com/2019/07/06/【Leetcode】39-组合总和/","excerpt":"","text":"题目 组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 案例示例 1: 输入:123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2:1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 思路 很典型的dfs思想，回溯算法 三步，定义一个存储的中间变量，最终结果，起始位置； 递归兜底条件是target == 0,或者target &lt; 0; 回溯的过程记得pop出来，恢复上一个状态； 关键的点在可以重复，所以递归的时候就是要从i开始； 代码12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(target == 0) return res; vector&lt;int&gt;cur; helper(candidates,target,0,res, cur); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates,int target,int start, vector&lt;vector&lt;int&gt; &gt;&amp;res,vector&lt;int&gt;cur)&#123; if(target == 0)&#123; res.push_back(cur); return; &#125; if(target &lt; 0) return; for(int i = start; i &lt; candidates.size(); i++)&#123; cur.push_back(candidates[i]); helper(candidates, target - candidates[i], i, res, cur); cur.pop_back(); &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/回溯/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"}]},{"title":"【测试】","slug":"【测试】","date":"2019-06-29T12:07:57.000Z","updated":"2019-06-29T13:58:11.261Z","comments":true,"path":"2019/06/29/【测试】/","link":"","permalink":"http://yoursite.com/2019/06/29/【测试】/","excerpt":"","text":"测试方法 单元测试完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。 集成测试应当避免一次性的集成（除非软件规模很小），而采用增量集成。自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。 自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。 系统测试是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。 回归测试回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。 验收测试Alpha测试：是由用户在开发者的场所来进行的，在一个受控的环境中进行。aBeta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。 灰度测试就是在小范围内看一下效果； bug的评测优先级和严重程度 自动化测试自动化测试的意义在于1、可以对程序的新版本自动执行回归测试 2、可以执行手工测试困难或者不可能实现的测试，如压力测试，并发测试， 3、能够更好的利用资源，节省时间和人力 执行自动化测试之前首先判断这个项目是不是和推广自动化测试，然后对项目做需求分析，指定测试计划，搭建自动化测试框架，设计测试用例，执行测试，评估4、测试的复用性；5、测试具有一致性和可重复性。由于测试是自动执行的，每次测试的结果和执行的内容的一致性是可以得到保障的，从而达到测试的可重复的效果。6、增加软件信任度。由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量。一旦软件通过了强有力的自动测试后，软件的信任度自然会增加。 自动化测试替代手工测试1、不能取代手工测试 2、手工测试比自动测试发现的缺陷更多 3、对测试质量的依赖性极大 4、测试自动化不能提高有效性 5、测试自动化可能会制约软件开发。由于自动测试比手动测试更脆弱，所以维护会受到限制，从而制约软件的开发。 6、工具本身并无想像力7、审美以及合理性 请问你怎么看待测试，知道哪些测试的类型，有用过哪些测试方法？测试是软件开发中不可或缺的一环，测试通过经济，高效的方法，捕捉软件中的错误，从而达到保重软件内在质量的目的。测试分为功能测试和非功能测试，非功能测试又可以分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。 测试方法用过等价划分法、边值分析法、错误推测法、因果图法。 app和web测试web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容 app测试则要看分辨率，屏幕尺寸，还要看设备系统。 web测试是基于浏览器的所以不必考虑安装卸载。 而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件 。 此外APP还有一些专项测试：如网络、适配性。 性能方面: web页面主要会关注响应时间 而app则还需要关心流量、电量、CPU、GPU、Memory这些。","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"}]},{"title":"【数据库sql】","slug":"【数据库sql】","date":"2019-06-29T11:36:06.000Z","updated":"2019-07-13T09:21:20.034Z","comments":true,"path":"2019/06/29/【数据库sql】/","link":"","permalink":"http://yoursite.com/2019/06/29/【数据库sql】/","excerpt":"","text":"https://www.cnblogs.com/diffrent/p/8854995.html 用一条SQL 语句 查询出每门课都大于80 分的学生姓名 name kecheng fenshu张三 语文 81张三 数学 75李四 语文 76李四 数学 90王五 语文 81王五 数学 100王五 英语 901select name from table group by name having min(fenshu)&gt;80 学生表 如下:自动编号 学号 姓名 课程编号 课程名称 分数1 2005001 张三 0001 数学 692 2005002 李四 0001 数学 893 2005001 张三 0001 数学 69删除除了自动编号不同, 其他都相同的学生冗余信息 A: delete tablename where 自动编号 not in(select min( 自动编号) from tablename group by学号, 姓名, 课程编号, 课程名称, 分数) limit offset 查找入职员工时间排名倒数第三的员工所有信息1select * from employees order by hire_date desc limit 1 offset 2; join查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_noCREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 123select salaries.emp_no,salaries.salary,salaries.from_date,salaries.to_date,dept_manager.dept_nofrom salaries join dept_manager on dept_manager.emp_no = salaries.emp_nowhere salaries.to_date = '9999-01-01' and dept_manager.to_date = '9999-01-01';","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"常考语句","slug":"常考语句","permalink":"http://yoursite.com/tags/常考语句/"}]},{"title":"【c#】","slug":"【c-】","date":"2019-06-29T11:19:09.000Z","updated":"2019-06-29T11:36:23.596Z","comments":true,"path":"2019/06/29/【c-】/","link":"","permalink":"http://yoursite.com/2019/06/29/【c-】/","excerpt":"","text":"lambda简化了匿名委托的使用；lambda运算符：所有的lambda表达式都是用新的lambda运算符 “ =&gt; “,可以叫他，“转到”或者 “成为”。运算符将表达式分为两部分，左边指定输入参数，右边是lambda的主体。 lambda表达式：1.一个参数：param=&gt;expr2.多个参数：（param-list）=&gt;expr","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"lambd","slug":"lambd","permalink":"http://yoursite.com/tags/lambd/"}]},{"title":"【红黑树】","slug":"【红黑树】","date":"2019-06-29T08:20:39.000Z","updated":"2019-06-29T11:17:24.473Z","comments":true,"path":"2019/06/29/【红黑树】/","link":"","permalink":"http://yoursite.com/2019/06/29/【红黑树】/","excerpt":"","text":"二叉树链接特点由二叉树定义以及图示分析得出二叉树有以下特点：1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。2）左子树和右子树是有顺序的，次序不能任意颠倒。3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 性质1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;(2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；(3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。满二叉树满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。满二叉树的特点有：1）叶子只能出现在最下一层。出现在其它层就不可能达成平衡。2）非叶子结点的度一定是2。3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。完全二叉树1）叶子结点只能出现在最下层和次下层。2）最下层的叶子结点集中在树的左部。3）倒数第二层若存在叶子结点，一定在右部连续位置。4）如果结点度为1，则该结点只有左孩子，即没有右子树。5）同样结点数目的二叉树，完全二叉树深度最小。注：满二叉树一定是完全二叉树，但反过来不一定成立。 遍历见链接 知乎链接 BST二叉搜索树AVL平衡二叉搜索树特点（1）非叶子节点最多拥有两个子节点； （2）非叶子节值大于左边子节点、小于右边子节点； （3）树的左右两边的层级数相差不会大于1; （4）没有值相等重复的节点; B树(B-tree) B树特点 B树性质 B树结构 B树查找 B树插入、删除分裂和借兄弟合并 B+ 树 B+树的特点 B+树的结构 B+树的查找一直查到叶节点； B+树的特点 B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快； B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定; B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。 B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。 红黑树用途1）广泛应用在 C++ 的 STL 中，如 map 和 set 都是用红黑树实现的。2）linux 进程调度，用红黑树管理进程控制块3）epoll 在内核中的实现，用红黑树管理事件块4）nginx 中，用红黑树管理 timer 等特征阶特征(1) 红黑树是满二叉树 空叶结点也看作结点(2) 阶为 k 的红黑树路径长度 最短是 k，最长是 2k(2)’ 阶为 k 的红黑树树高最小是 k+1，最高是 2k+1(3) 阶为k的红黑树的内部结点最少是一棵完全满二叉树，内部结点数最少是 2k-1(4) n 个内部结点的红黑树树高最大是 2 log2(n+1)+插入、删除解决冲突，重构或者换色","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"各种树","slug":"各种树","permalink":"http://yoursite.com/tags/各种树/"}]},{"title":"【数据库】","slug":"【数据库】","date":"2019-06-26T13:52:30.000Z","updated":"2019-07-13T15:41:36.909Z","comments":true,"path":"2019/06/26/【数据库】/","link":"","permalink":"http://yoursite.com/2019/06/26/【数据库】/","excerpt":"","text":"索引数据库索引 https://www.cnblogs.com/s-b-b/p/8334593.html 联合索引联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。最左前缀匹配 对于一个联合索引，如果有一个SQL查询语句需要执行，则只有从索引最左边的第一个字段开始到SQL语句查询条件中不包含的字段（不含）或范围条件字段（含）为止的部分才会使用索引进行加速。 范围查询条件 聚集索引数据会根据索引中的顺序进行排列和组织的，这样的索引就被称为聚集索引，而非聚集索引就是其他的一般索引。因为数据只能按照一种规则排序，所以一张表至多有一个聚集索引，但可以有多个非聚集索引。B+ 树。在B+树中，每一个节点里都有N个按顺序排列的值，且每个值的中间和节点的头尾都有指向下一级节点的指针。在查找过程中，按顺序从头到尾遍历一个节点中的值，当发现要找的目标值恰好在一个指针的前一个值之前、后一个值之后时，就通过这个指针进入下一级节点。当最后到达叶子节点，也就是最下层的节点时，就能够找到自己希望查找的数据记录了。 非聚集索引而从非聚集索引的叶子节点链接到聚集索引的叶子节点查询实际数据的过程就叫做——回表。 全覆盖索引不需要回表；全覆盖索引可以节约回表的开销这一点在一些回表开销很大的情况下就非常重要了 为什么用B+ 树 不用二叉树 二分法，查找效率高 所以对于数据库索引来说，因为数据量很大，所以基本都是保存在外存中的，这样的话数据库读取一个索引节点的成本就非常大了。在数据量一样大的情况下，我们可以知道，B+树的单个节点中包含的值个数越多那么树中需要的节点总数就会越少，这样查询一次数据需要访问的节点数就更少了。 在现代的操作系统中，把数据从外存读到内存所使用的单位一般被称为“页”，每次读取数据都需要读入整数个的“页”，而不能读入半页或者0.8页。一页的大小由操作系统决定，常见的页大小一般为4KB=4096字节。所以不管我们是要读取1字节还是2KB，最后都是需要读入一个完整的4KB大小的页的，那么一个节点的读取成本就取决于需要读入的页数。 索引分类 唯一索引唯一索引：表中的任意两行的索引值都不相等 主键索引 主键索引和唯一索引的区别： 主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键； 主键不允许为空值，唯一索引列允许空值； 一个表只能有一个主键，但是可以有多个唯一索引； 主键可以被其他表引用为外键，唯一索引列不可以； 主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的差别 复合索引复合索引，可以是唯一索引 比较详细 sql语句创建索引12CREATE INDEX index_nameON table_name (column_name) 创建唯一索引12CREATE UNIQUE INDEX index_nameON table_name (column_name) 创建复合索引12CREATE INDEX PersonIndexON Person (LastName, FirstName) 删除索引1DROP INDEX index_name ON table_name 隔离级别[参考链接]https://www.cnblogs.com/myseries/p/10748912.html 读未提交 脏读 读提交 update 不可重复读 不可重复读 insert 幻读 序列化事务的四大特性事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。acid原子性、一致性、隔离性、持久性 三大范式https://www.cnblogs.com/1906859953Lucas/p/8299959.html 第一范式*（确保每列保持原子性） 第二范式（确保表中的每列都和主键相关） 第三范式（确保每列都和主键列直接相关，而不是间接相关） varchar 和char的区别 char类型的长度是固定的，varchar的长度是可变的。 这就表示，存储字符串’abc’，使用char(10)，表示存储的字符将占10个字节（包括7个空字符） 使用varchar2(10),，则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储。 ER图ER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。 死锁https://www.jianshu.com/p/26881a1b9e30概念：多个并发进程因争夺系统资源而产生相互等待的现象。1、互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。 2、占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。3、不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。4、循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。解决办法：1、死锁预防 —– 确保系统永远不会进入死锁状态a、破坏“占有且等待”条件b、破坏“不可抢占”条件c、破坏“循环等待”条件2、避免死锁 —– 在使用前进行判断，只允许不会产生死锁的进程申请资源两种避免办法： 1、如果一个进程的请求会导致死锁，则不启动该进程 2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。3、死锁检测与解除 —– 在检测到运行系统进入死锁，进行恢复。1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。 a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。 b、逐个终止进程，直至死锁状态解除 饥饿锁用远得不到资源活锁两人争夺资源都进，都让https://blog.csdn.net/u013766342/article/details/80929719 常用语句 https://www.cnblogs.com/ieayoio/p/5293124.html删除列名alter table 表名 drop column 列名;添加列alter table tableName add columnName varchar(30)增insert into 表名 （col1，col2….coln）values(value1,value2…..valuen)；删delete from 表名 where改update 数据表 set 字段1=‘值1’,字段2=‘值2’,字段3=‘值3’ where id=你要修改的数据ID","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"},{"name":"隔离级别","slug":"隔离级别","permalink":"http://yoursite.com/tags/隔离级别/"},{"name":"常用语句","slug":"常用语句","permalink":"http://yoursite.com/tags/常用语句/"}]},{"title":"【网络】","slug":"【网络】","date":"2019-06-25T02:28:14.415Z","updated":"2019-06-26T13:51:42.975Z","comments":true,"path":"2019/06/25/【网络】/","link":"","permalink":"http://yoursite.com/2019/06/25/【网络】/","excerpt":"","text":"tcp三次握手，四次挥手的具体三次握手、四次挥手 tcp、udp区别1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 5、TCP提供面向字节流的传输，它能将信息分割成组，并在接收端将其充足，UDP提供面向数据报的传输，没有分组开销 6、TCP提供拥塞控制，流量控制机制，UDP没有 滑动窗口滑动窗口协议的实现：GBN(go back to N)GBN 累计计数收到乱序的直接丢了 分组头部包含序列号 窗口如下，大小为N，最多允许N个分组未确认 ACK(n),则表示确认从开始到n（包含n）的序列号全部正确接收 会空中在传的分组设置一个Timer计时器，处理超时，如果收到了timeout(n)事件，那么会重传的是n以及n以后的所有分组（尽管后面的可能已经收到了，这就是回退，回退到n开始传，GBN） 接收方会有一个期望序列号，如果收到的不是期望的分组，直接丢弃 SR(select repeat)多了一个接收方的窗口发送方窗口和接收窗口不同步的 GBN缺陷，累积确认机制导致回退到N，重复传了很多。解决这个。 1.对每个分组分别确认，不再只接收期望的，接到不期望的，就先缓存（设置缓存机制），接到期望的才交付上层 2.发送方只需要重传那些没收到ACK的分组了 3.产生了接收方窗口（GBN只有发送方窗口），用来缓存，现在有两窗口了 4.序列号的位数是K的话，那么得满足 接收方窗口大小N+发送方N&lt;= 2的k次方，防止因为接收方ACK丢失导致发送重发k号分组，而此时接收方滑到了新窗口，新窗口有新的k号分组（不是原来的，共用序号产生的），导致出错 tcp可靠数据传输的原理端到端，用确认重传等保证TCP协议采用累积确认机制、通常在接收端提供缓存、单一重传计时器重传具有最小序列号的那一个，并且重启计时器 快重传定时器超时之前，收到三个重复的ack，就重传 流量控制速度匹配 拥塞控制整个网络的负载带来的问题：拥塞端到端的拥塞控制加性增、乘性减、慢启动 TCP为什么可靠知乎链接 TCP超时重传，确认和重传机制 流量控制 TCP窗口会指明双方能够发送接收的最大数据量 TCP流量控制主要是针对接收端的处理速度不如发送端发送速度快的问题，消除发送方使接收方缓存溢出的可能性。 TCP流量控制主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。 拥塞控制TCP发送方可能因为IP网络的拥塞而被遏制，TCP拥塞控制就是为了解决这个问题（注意和TCP流量控制的区别）。 TCP拥塞控制的几种方法：慢启动，拥塞避免，快重传和快恢复。 慢启动 拥塞避免 加性增 快重传 快恢复 乘性减 https 的实现传纸条讲解https小灰讲解https 牛客上的https答案HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。HTTPS和HTTP的区别主要如下： 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 http\\tcpip\\socket指路链接吧了socket，tcp，http三者之间的区别和原理 网络协议 待看https://blog.csdn.net/stringNewName/article/details/72717213 session 和 cookie讲解 差异①存在的位置： cookie 存在于客户端，临时文件夹中 session：存在于服务器的内存中，一个session域对象为一个用户浏览器服务 ②安全性 cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放 session存放于服务器的内存中，所以安全性好 ③网络传输量 cookie会传递消息给服务器 session本身存放于服务器，不会有传送流量 ④生命周期(以20分钟为例) (1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束， (2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁 但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期 (3)关机会造成session生命周期的结束，但是对cookie没有影响⑤访问范围 session为一个用户浏览器独享 cookie为多个用户浏览器共享 域名解析 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。 但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。 如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址 此时LDNS再发送请求给上一步返回的gTLD 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器 Name Server根据映射关系表找到目标ip，返回给LDNS LDNS缓存这个域名和对应的ip LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束 请你说一下HTTP的报文段是什么样的？开始背 状态码状态码，100~199表示请求已收到继续处理，200~299表示成功，300~399表示资源重定向，400~499表示客户端请求出错，500~599表示服务器端出错 200：响应成功 302：跳转，重定向 400：客户端有语法错误 403：服务器拒绝提供服务 404：请求资源不存在 500：服务器内部错误","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[]},{"title":"【操作系统】进程线程","slug":"【操作系统】进程线程","date":"2019-06-23T12:54:23.000Z","updated":"2019-06-30T12:22:38.937Z","comments":true,"path":"2019/06/23/【操作系统】进程线程/","link":"","permalink":"http://yoursite.com/2019/06/23/【操作系统】进程线程/","excerpt":"","text":"指路链接吧，讲的太好了分享链接 进程线程 进程：程序的一次执行 线程：CPU的基本调度单位 自己的感悟：线程是我们自己设计的，一个程序中可以开启多个线程去干活，这样快很多，但是必要的时候为了保证线程安全，就得加锁；进程，通常是操作系统调度的； 进程是并行，线程并发 进程之间通信参考链接，链接进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 线程和进程的堆栈线程有栈，进程有堆 静态存储区、堆区和栈区可编程内存在基本上分为这样的几大部分：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。 栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，否则，我们认为发生了内存泄漏现象。 线程、协程、进程机器人解释coroutine可以认为是单线程多任务的工作方式(当然，进程中实现coroutine也是可以的)，因为它在单个线程中的多个任务之间直接跳转，而多线程是通过上下文切换来实现多任务的。换句话说，coroutine提供了并发却不并行的功能。通过coroutine，还能实现更为”实时”的上下文任务，因为coroutine之间的跳转切换不需要任何系统调用和可能的阻塞调用，不需要像多线程一样为了线程之间的资源同步而使用额外的互斥锁、信号量等。协程线程区别而协程与线程主要的区别有两个，最大的就是调度方式，线程是操作系统调度，协程是应用系统自己调度。 另外一个区别，协程的栈空间是可以动态调整的，这样空间利用率就可以更高，一个任务需要2K空间就分配2K内存，一个任务需要20M空间就分配20M，而不用担心栈空间不够或者空间浪费。 由于上面的两个原因，协程的优势也就凸显出来。 协程可以更好的利用CPU，不用把CPU浪费在线程调度和上下文切换上。 协程可以更好的利用内存，不用全都分配一个偏大的空间，只需要分配需要的对应空间即可。 多线程单线程 多线程的产生并不是因为发明了多核CPU甚至现在有多个CPU+多核的硬件，也不是因为多线程CPU运行效率比单线程高。单从CPU的运行效率上考虑，单任务进程及单线程效率是最高的，因为CPU没有任何进程及线程的切换开销， 实际上，多线程的出现主要为了解决IO设备的读写速度往往比CPU的处理速度慢造成的单线程程序运行阻塞问题，一个极端的例子就是如果你需要用户在键盘上输入一个数据，当用户没有输入前，单线程程序就阻塞了，多线程程序就可以放个音乐或继续干一些程序中除了键盘输入外的工作，因此，多线程能提高因程序由于等待某个资源阻塞时其他资源的利用率（是利用率不是效率）。 因此多线程与单线程的最大区别，多线程程序能在等待某个IO操作时，继续完成非这个IO的其他工作，有利于提高完成整个任务的效果和速度。此外，多线程程序与单线程程序对程序设计也有不同的流程和结构，多线程需要考虑对静态变量等资源的操作互锁及程序执行的同步问题。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"},{"name":"进程","slug":"进程","permalink":"http://yoursite.com/tags/进程/"}]},{"title":"【Linux】","slug":"【Linux】","date":"2019-06-23T05:41:47.000Z","updated":"2019-07-08T02:18:25.673Z","comments":true,"path":"2019/06/23/【Linux】/","link":"","permalink":"http://yoursite.com/2019/06/23/【Linux】/","excerpt":"","text":"常用语法 查看进程ps -ef//-e显示系统内的所有进程信息。-f使用完整的（full）格式显示进程信息。 杀死进程kill -15 //正常退出kill -9 //强制退出 怎么批量杀死进程，ps aux|grep python|grep -v grep|cut -c 9-15|xargs kill -15 看进程号ps -a | grep “cmdname” 批量替换指定文件夹中所有文件的指定内容命令：sed -i “s/查找字段/替换字段/g” grep 查找字段 -rl 路径 文件名功能：用来替换当前目录VEROMODA文件夹及子文件夹中所有文件中的https为http. 说明： -i 表示inplace edit，就地修改文件 -r 表示搜索子目录 -l 表示输出匹配的文件名 linux 下查找一个目录下带指定字符的文件grep -r “test” /data/reports Linux查看磁盘空间大小命令df -hl 查看硬盘的分区：fdisk -l 修改文件的权限最高位7是设置文件所有者访问权限，第二位是设置群组访问权限，最低位是设置其他人访问权限。 其中每一位的权限用数字来表示。具体有这些权限：r(Read，读取，权限值为4)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目 录的权限。w(Write,写入，权限值为2)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。x(eXecute，执行，权限值为1)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"【Leetcode】918. 环形子数组的最大和","slug":"【Leetcode】918-环形子数组的最大和","date":"2019-06-22T07:09:20.000Z","updated":"2019-06-22T07:29:01.555Z","comments":true,"path":"2019/06/22/【Leetcode】918-环形子数组的最大和/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】918-环形子数组的最大和/","excerpt":"","text":"题目 环形子数组的最大和给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。 在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，而当 i &gt;= 0 时 C[i+A.length] = C[i]） 此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length） 案例示例 1:123输入：[1,-2,3,-2]输出：3解释：从子数组 [3] 得到最大和 3 示例2：123输入：[5,-3,5]输出：10解释：从子数组 [5,5] 得到最大和 5 + 5 = 10 示例3：123输入：[3,-1,2,-1]输出：4解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4 -30000 &lt;= A[i] &lt;= 300001 &lt;= A.length &lt;= 30000 思路 首先处理没有延长的情况，就正常寻找最大的值； 对于有延长的情况，只要用求和的减去连续数组的最小值即可； 但是要考虑是不是全是负数，因为全是负数的话，考虑延长的结果就是0了；代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int maxSubarraySumCircular(vector&lt;int&gt;&amp; A) &#123; bool flag = false; int sum = 0, amax = A[0]; //考虑是不是负数，并且找到最大值 for(auto a : A)&#123; if(a &gt; 0) flag = true; sum += a; amax = max(a,amax); &#125; if(!flag)&#123; return amax; &#125; int res = INT_MIN; int res_max = INT_MIN; int res_min = INT_MAX; int n = A.size(); int tem_max = A[0], tem_min = A[0]; //分别找到最大值和最小值 for(int i = 1;i &lt; n; i++)&#123; if(tem_max + A[i] &gt; A[i])&#123; tem_max = tem_max + A[i]; &#125;else&#123; tem_max = A[i]; &#125; res_max = max(res_max,tem_max); if(tem_min + A[i] &lt; A[i])&#123; tem_min = tem_min + A[i]; &#125;else&#123; tem_min = A[i]; &#125; res_min = min(res_min,tem_min); &#125; //求和减去最小值 int res2 = sum - res_min; res = max(res2,res_max); return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组 - 中等 - 双指针","slug":"数组-中等-双指针","permalink":"http://yoursite.com/tags/数组-中等-双指针/"}]},{"title":"【Leetcode】31. 下一个排列","slug":"【Leetcode】31-下一个排列","date":"2019-06-22T06:13:28.000Z","updated":"2019-06-22T06:27:02.685Z","comments":true,"path":"2019/06/22/【Leetcode】31-下一个排列/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】31-下一个排列/","excerpt":"","text":"题目 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 案例示例 1:1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路 从后往前找，首先找到第一个逆序的位置 如果不存在逆序的位置，就直接把顺序改变，得到最小的； 再从后往前遍历，找到第一个比当前的大的，然后交换后，再排序；代码 12345678910111213141516171819class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; //找第一个不顺序的数 int i = nums.size() - 1; for(i; i &gt; 0; i--)&#123; if(nums[i] &gt; nums[i - 1]) break; &#125; if(i == 0) return sort(nums.begin(),nums.end()); int j = nums.size() - 1; for(j; j &gt;= i; j--)&#123; if(nums[j] &gt; nums[i - 1]) break; &#125; swap(nums[j],nums[i - 1]); sort(nums.begin()+i, nums.end()); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】27. 移除元素","slug":"【Leetcode】27-移除元素","date":"2019-06-22T06:04:30.000Z","updated":"2019-06-22T06:05:56.386Z","comments":true,"path":"2019/06/22/【Leetcode】27-移除元素/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】27-移除元素/","excerpt":"","text":"题目 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 案例示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 思路 从前向后遍历，利用两个指针，一个指针遍历，一个指针用来存储当前的有效的位置； 代码123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int i = 0; for(int j = 0; j &lt; nums.size(); j++)&#123; if(nums[j] != val)&#123; nums[i++] = nums[j]; &#125; &#125; return i; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组 - 中等 - 双指针","slug":"数组-中等-双指针","permalink":"http://yoursite.com/tags/数组-中等-双指针/"}]},{"title":"【Leetcode】26. 删除排序数组中的重复项","slug":"【Leetcode】26-删除排序数组中的重复项","date":"2019-06-22T05:59:57.000Z","updated":"2019-06-22T06:03:29.869Z","comments":true,"path":"2019/06/22/【Leetcode】26-删除排序数组中的重复项/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】26-删除排序数组中的重复项/","excerpt":"","text":"题目 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 案例示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 思路 从前向后遍历，利用两个指针，一个指针遍历，一个指针用来存储当前的有效的位置； 代码12345678910111213class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; int i = 1, t = nums[0]; for(int j = 1; j &lt; nums.size();j++)&#123; if(nums[j] != nums[j - 1])&#123; nums[i++] = nums[j]; &#125; &#125; return i; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】18. 四数之和","slug":"【Leetcode】18-四数之和","date":"2019-06-21T10:10:35.000Z","updated":"2019-06-21T10:15:16.625Z","comments":true,"path":"2019/06/21/【Leetcode】18-四数之和/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】18-四数之和/","excerpt":"","text":"题目 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意 答案中不可以包含重复的四元组。 案例示例 1:12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路和题目【Leetcode】15-3Sum比较相近； 将数组排序； 降为三维； 不同的是不用去做判断break,因为有负数； 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt;res; sort(nums.begin(),nums.end()); for(int i = 0; i &lt; nums.size(); i++)&#123; //if(nums[i] &gt; target) break;//没有的 if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; for(int j = i + 1; j &lt; nums.size(); j++)&#123; //if(nums[j] &gt; target) break;//没有的 if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int t = target - nums[i] - nums[j]; int left = j + 1,right = nums.size() - 1; while(left &lt; right)&#123; int sum = nums[left] + nums[right]; if(sum == t)&#123; res.push_back(&#123;nums[i],nums[j],nums[left],nums[right]&#125;); while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++,right--; &#125;else if(sum &lt; t) left++; else right--; &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】16. 最接近的三数之和","slug":"【Leetcode】16-最接近的三数之和","date":"2019-06-21T10:04:31.000Z","updated":"2019-06-21T10:09:09.797Z","comments":true,"path":"2019/06/21/【Leetcode】16-最接近的三数之和/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】16-最接近的三数之和/","excerpt":"","text":"题目 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 案例示例 1:123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 思路和题目【Leetcode】15-3Sum比较相近； 将数组排序； 不段的比较，找到最小的 注意，仍然用双指针方法，这样不会丢解，因为是在不短的像target靠近；代码 12345678910111213141516171819202122class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int dif = INT_MAX,res = 0; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++)&#123; int left = i + 1, right = nums.size() - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[left] + nums[right]; int diff = abs(sum - target); if(diff &lt; dif)&#123; dif = diff; res = sum; &#125; // res = min(res,diff); if (sum &lt; target) left++; else right--; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】11.盛最多水的容器","slug":"【Leetcode】11-盛最多水的容器","date":"2019-06-21T09:41:51.000Z","updated":"2019-06-21T09:58:58.725Z","comments":true,"path":"2019/06/21/【Leetcode】11-盛最多水的容器/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】11-盛最多水的容器/","excerpt":"","text":"题目 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 案例12![示例](【Leetcode】11-盛最多水的容器/figure.jpg)图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 思路利用双指针，移动的是盛水少的指针，最后跳出循环，得到最终结果； 代码1234567891011121314class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int left = 0, right = height.size() - 1; int res = 0; while(left &lt; right)&#123; int l = height[left], r = height[right]; res = max(min(l,r)*(right - left),res); if(l &lt; r) left++; else right--; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"mk的一些常见的语法“ ","slug":"mk的一些常见的语法“","date":"2019-05-30T14:11:56.000Z","updated":"2019-05-30T14:17:20.392Z","comments":true,"path":"2019/05/30/mk的一些常见的语法“/","link":"","permalink":"http://yoursite.com/2019/05/30/mk的一些常见的语法“/","excerpt":"","text":"插入图片! + [[内容]] + ( ) 字体加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 超链接语法： [超链接名]+(超链接地址 +”超链接title”)title可加可不加 列表 无序列表语法：无序列表用 - + * 任何一种都可以 有序列表语法：数字加点","categories":[{"name":"MK","slug":"MK","permalink":"http://yoursite.com/categories/MK/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"【Leetcode】12. 整数转罗马数字","slug":"【Leetcode】12-整数转罗马数字","date":"2019-05-30T13:01:23.000Z","updated":"2019-05-30T13:05:17.631Z","comments":true,"path":"2019/05/30/【Leetcode】12-整数转罗马数字/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】12-整数转罗马数字/","excerpt":"","text":"题目 整数转罗马数字罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 案例示例 1:12输入: 3输出: &quot;III&quot; 示例 2:12输入: 4输出: &quot;IV&quot; 思路先将所有的对应表列好，每次通过查表找出当前最大的数，减去再继续查表 代码123456789101112131415class Solution &#123;public: string intToRoman(int num) &#123; string res = \"\"; vector&lt;int&gt; val = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; vector&lt;string&gt; s = &#123;\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"&#125;; for(int i = 0; i &lt; val.size(); i++)&#123;//这个for和while很巧妙 while(num &gt;= val[i])&#123; num -= val[i]; res += s[i]; &#125; &#125; return res; &#125;&#125;; 需要记住的点 这个for和while用的很巧妙；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"【Leetcode】8. 字符串转换整数 (atoi)” ","slug":"【Leetcode】8-字符串转换整数-atoi-”","date":"2019-05-30T12:10:52.538Z","updated":"2019-05-30T13:01:33.553Z","comments":true,"path":"2019/05/30/【Leetcode】8-字符串转换整数-atoi-”/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】8-字符串转换整数-atoi-”/","excerpt":"","text":"题目 Z 字形变换请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 案例示例 1:12输入: &quot;42&quot;输出: 42 示例 2:1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 思路首先排除空字符，然后看符号，然后看数字，注意，判断数字要考虑可能越界问题，采用INT_MACX/10，作为判断是不是会越界；具体看代码；这道题主要学习代码简洁性，以及判断越界的方法； 代码1234567891011121314151617181920cclass Solution &#123;public: int myAtoi(string str) &#123; int flag = 1, res = 0,n = str.length(),i = 0; while(i &lt; n &amp;&amp; str[i] == ' ')&#123; i++; &#125; if(str[i] == '+' || str[i] == '-')&#123; flag = str[i++] == '+' ? 1 : -1; &#125; while(i &lt; n &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')&#123; int tem = str[i++] - '0'; if(res &gt; INT_MAX/10 || (res == INT_MAX/10 &amp;&amp; tem &gt;= 8))&#123; return flag == 1 ? INT_MAX : INT_MIN; &#125; res = res * 10 + tem; &#125; return flag * res; &#125;&#125;; 需要记住的点 INT_MAX/10，并要判断等于的情况，等于的情况要分为大不大于8；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】6. Z 字形变换","slug":"【Leetcode】6-Z-字形变换","date":"2019-05-30T07:52:03.146Z","updated":"2019-05-30T08:01:57.308Z","comments":true,"path":"2019/05/30/【Leetcode】6-Z-字形变换/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】6-Z-字形变换/","excerpt":"","text":"题目 Z 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 案例示例 1:12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2:12345678输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L D RE O E I IE C I H NT S G 思路可以看出是有规律可循的，我们发现，周期为2nRows - 2, 根据这个特点，我们可以按顺序找到所有的黑色元素在元字符串的位置，将他们按顺序加到新字符串里面。对于红色元素出现的位置也是有规律的，每个红色元素的位置为 j + 2nRows-2 - 2i, 其中，j为前一个黑色元素的列数，i为当前行数。 比如当n = 4中的那个红色5，它的位置为 1 + 24-2 - 2*1 = 5，为原字符串的正确位置。因为相当于加了一个周期再折回来，当我们知道所有黑色元素和红色元素位置的正确算法，我们就可以一次性的把它们按顺序都加到新的字符串里面 代码12345678910111213141516class Solution &#123;public: string convert(string s, int nRows) &#123; if (nRows &lt;= 1) return s; string res = \"\"; int size = 2 * nRows - 2; for (int i = 0; i &lt; nRows; ++i) &#123; for (int j = i; j &lt; s.size(); j += size) &#123; res += s[j]; int tmp = j + size - 2 * i; if (i != 0 &amp;&amp; i != nRows - 1 &amp;&amp; tmp &lt; s.size()) res += s[tmp];//关键的地方 &#125; &#125; return res; &#125;&#125;; 需要记住的点 规律很好，时间复杂度就是变成n；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】5. 最长回文子串","slug":"【Leetcode】5-最长回文子串","date":"2019-05-27T14:35:14.716Z","updated":"2019-05-27T14:48:49.869Z","comments":true,"path":"2019/05/27/【Leetcode】5-最长回文子串/","link":"","permalink":"http://yoursite.com/2019/05/27/【Leetcode】5-最长回文子串/","excerpt":"","text":"题目 无重复字符的最长子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 案例示例 1:123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2:12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 思路遍历每个字符，然后获取这个字符作为中间的最长的回文串；再去更新结果；分为两种情况，回文串为奇数和偶数两种情况；具体代码如下； 代码123456789101112131415161718192021class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; int n = s.size(), maxLen = 0, start = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; searchPalindrome(s, i, i, start, maxLen); searchPalindrome(s, i, i + 1, start, maxLen); &#125; return s.substr(start, maxLen); &#125; void searchPalindrome(string s, int left, int right, int&amp; start, int&amp; maxLen) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; if (maxLen &lt; right - left - 1) &#123; start = left + 1; maxLen = right - left - 1; &#125; &#125;&#125;; 需要记住的点 很巧妙的用了引用；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】3. 无重复字符的最长子串","slug":"【Leetcode】3-无重复字符的最长子串","date":"2019-05-27T13:59:22.000Z","updated":"2019-05-27T14:09:33.416Z","comments":true,"path":"2019/05/27/【Leetcode】3-无重复字符的最长子串/","link":"","permalink":"http://yoursite.com/2019/05/27/【Leetcode】3-无重复字符的最长子串/","excerpt":"","text":"题目 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。 案例示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路建立一个HashMap，建立每个字符和其最后出现位置之间的映射，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置的前一个，由于是前一个，所以初始化就是-1，然后我们遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在HashMap中存在了，并且如果其映射值大于left的话，那么更新left为当前映射值。然后映射值更新为当前坐标i，这样保证了left始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用i-left即可，用来更新结果res。几个比较关键的点： left初始值设为1，因为我们定义left是当前窗口的前一个值；代码 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0, left = -1, n = s.size(); unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; n; ++i) &#123; if (m.count(s[i]) &amp;&amp; m[s[i]] &gt; left) &#123;//比较精华的一句话 left = m[s[i]]; &#125; m[s[i]] = i; res = max(res, i - left); &#125; return res; &#125;&#125;; 需要记住的点 unordered_map查找，用m.count(val); 包含再头文件unordered_map中；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/滑动窗口/"}]},{"title":"排序算法","slug":"排序算法“","date":"2019-05-04T12:30:21.000Z","updated":"2019-07-24T02:07:00.022Z","comments":true,"path":"2019/05/04/排序算法“/","link":"","permalink":"http://yoursite.com/2019/05/04/排序算法“/","excerpt":"","text":"每一种排序算法都有必须存在的理由； 选择排序 时间复杂度：n^2，最好的最坏的情况都是； 不需要额外的空间； 不稳定；代码：123456789101112void helper(vector&lt;int&gt; &amp;b)&#123; int n = b.size(); for(int i = 0; i &lt; n; i++)&#123; int index = i; for(int j = i + 1; j &lt; n; j++)&#123; if(b[j] &lt; b[index])&#123; index = j; &#125; &#125; swap(b[i],b[index]); &#125;&#125; 冒泡排序冒泡排序的思想是，从第0个元素到第n-1个元素遍历，若前面一个元素大于后面一个元素，则交换两个元素，这样可将整个序列中最大的元素冒泡到最后，然后再从第0个到第n-2遍历，如此往复，直到只剩一个元素。 时间复杂度：n^2，最好的最坏的情况都是； 不需要额外的空间； 不稳定 好在可以在内层循环中设置一个flag,如果在当前的循环中从来没有进行过交换，那么说明内部已经是完全有序的了，那么这种情况，最好的情况是时间复杂度为n;代码：123456789101112131415void helper(vector&lt;int&gt; &amp;b)&#123; int n = b.size(); for(int i = n - 1; i &gt; 0; i--)&#123; bool flag = false; for(int j = 0; j &lt; i; j++)&#123; if(b[j] &gt; b[j + 1])&#123; flag = true; swap(b[j], b[j+1]); &#125; &#125; if(!flag)&#123; break; &#125; &#125;&#125; 123456789101112void Bubble_Sort( ElementType A[], int N )&#123; for ( P=N-1; P&gt;=0; P-- )&#123; flag = 0; for( i=0; i&lt;P; i++ ) &#123; /* 一趟冒泡 */ if ( A[i] &gt; A[i+1] ) &#123; Swap(A[i], A[i+1]); flag = 1; /* 标识发生了交换 */ &#125; &#125; if ( flag==0 ) break; /* 全程无交换 */ &#125;&#125; 插入排序插入排序的思想是，像抓扑克牌一样，不断的将一张牌插入到已经排序好的数组中；从有序的最后比较； 时间复杂度：最坏n^2，最好n,取决于逆序对的数量； 不需要额外的空间； 现在一次只能消除一个逆序对，想法就是一次多消除几个逆序对；代码：123456789void Insertion_Sort( ElementType A[], int N ) &#123; for(int P = 1; P &lt; N; P++)&#123; int tem = A[P];//抓牌 for(int i = P; i &gt; 0 &amp;&amp; tem &lt; A[i - 1]; i--)&#123; A[i] = A[i - 1];//找位置 &#125; A[i] = tem; &#125;&#125; 当我们每次需要多消除几个逆序对的想法出现的时候，就变成了希尔排序； 希尔排序希尔排序的思想是，保证K个间隔是有序的 定义增量序列DM &gt;DM-1 &gt;…&gt;D1 =1 对每个 Dk 进行“Dk-间隔”排序( k = M, M-1, … 1 ) 注意:“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk- 间隔”有序的 几种增量序列 原始增量序列DM =N/2, Dk =Dk+1/2代码：1234567891011void Shell_sort( ElementType A[], int N )&#123; for(int D = N/2; D &gt; 0; D /= 2 )&#123; for(int P = D; P &lt; N; P ++)&#123; int tem = A[P]; for(int i = P; i &gt;0 &amp;&amp; tem &lt; A[i - D]; i -= D)&#123; A[i] = A[i - D]; &#125; A[i] = tem; &#125; &#125;&#125; 可能会导致很大的问题，比如下面的情况相当于白跑很多趟，只有最后一趟有用，坏的是O(N^2) Hibbard 增量序列Dk =2k –1 —相邻元素互质 最坏情况:T=O(N3/2 ) 猜想:Tavg =O(N5/4 ) Sedgewick增量序列 {1, 5, 19, 41, 109, … }—9+4^i–9+2^i +1或4^i–3*2^i+1 猜想:Tavg =O(N7/6 )，Tworst =O(N4/3 ) 堆排序思想就是，在选择排序的基础上，把每次找最小元的事情交给堆；但是因为选择排序的，每次是N的复杂度去找最小元； 首先建立最大堆； 每次交换根节点和头节点； 向下过滤，调整成最大堆； 不断的交换； 最小堆 建立最小堆； 每次从头部弹出一个； 然后重开一个数组；T(N)=O(N logN)1234567void Heap_Sort ( ElementType A[], int N )&#123; BuildHeap(A); /* O(N) */&#125;for ( i=0; i&lt;N; i++ ) TmpA[i] = DeleteMin(A); /* O(logN) */for ( i=0; i&lt;N; i++ ) /* O(N) */ A[i] = TmpA[i]; 归并排序排两个有序子列T ( N ) = O( N ) 快速排序分而治之，选主元，大于主元，小于主元，底层是N是1的时候直接就返回了；快在每次主元一次性的换到了正确的位置；问题 选主元； 怎么分最好情况每次正好中分 T(N) = O(NlogN） 不好的情况 本来就是有顺序的，然后选了主元为第一个，结果是N^2； 是递归的，不断的进栈，大规模的时候可以，小规模的时候就没必要了； 步骤 选三个的中位数； 换到right-1; 子集划分 选定主元后； 两个指针i,j，如果i小于主元，那么直接走，直到i大于位置；然后开始j–,直到j小于主元为止，最后的限制条件是i&lt;j; 最终i的位置就是主元的位置； 极端情况如果是全相等的序列的话，如果停下来交换，最终主元是会被放在中间位置；O(NlogN）但是如果是继续向前，最终主元就是倒数第一个位置，导致N^2;程序123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void quicksort(vector&lt;int&gt; &amp;arr, int l, int r);int main()&#123; vector&lt;int&gt; arr&#123;2,1,4,3&#125;; quicksort(arr,0,3); for(int i = 0; i &lt; 4; i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;&#125;void quicksort(vector&lt;int&gt; &amp;arr, int l, int r)&#123; if(l &gt; r) return; int t = arr[l], index = l,end = r; l = l + 1; while(l &lt;= r)&#123; while(l &lt;= r &amp;&amp; arr[l] &lt; t) l++; while(l &lt;= r &amp;&amp; arr[r] &gt; t) r--; if(l &lt; r) swap(arr[l],arr[r]); &#125; swap(arr[r],arr[index]); quicksort(arr, index, r -1); quicksort(arr, r+1, end);&#125; 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void helper(vector&lt;int&gt;&amp;arr,int l,int r);int main()&#123; vector&lt;int&gt; arr&#123;2,1,4,3&#125;; int l = 0, r = arr.size()-1; helper(arr,l,r); for(int a:arr)&#123; cout&lt;&lt;a&lt;&lt;endl; &#125;&#125;void helper(vector&lt;int&gt;&amp;arr,int l,int r)&#123; //选主元 if(l == r || l &gt; r) return; int mid = l + (r - l)/2; if(arr[l] &gt; arr[mid]) swap(arr[l],arr[mid]); if(arr[mid] &gt; arr[r]) swap(arr[mid],arr[r]); if(arr[l] &gt; arr[mid]) swap(arr[mid],arr[l]); swap(arr[r - 1],arr[mid]); //找主元 int i = l + 1, j = r - 2; while(i &lt; j)&#123; while(i &lt; j &amp;&amp; arr[i] &lt; arr[r-1]) i++; while(i &lt; j &amp;&amp; arr[j] &gt; arr[r-1]) j--; if(i &lt; j) swap(arr[i], arr[j]); &#125; if(r-1 &gt; i) swap(arr[r - 1],arr[i]);//一定要判断 helper(arr,l,i - 1); helper(arr,i + 1,r);&#125; 非递归排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;stack&gt;#include&lt;vector&gt;using namespace std;int helper(vector&lt;int&gt;&amp;arr,int l,int r);int main()&#123; vector&lt;int&gt; arr&#123;2,1,4,3&#125;; int l = 0, r = arr.size()-1; stack&lt;int&gt; s; s.push(l); s.push(r); while(!s.empty())&#123; int right = s.top(); s.pop(); int left = s.top(); s.pop(); if(left &lt; right)&#123; int p = helper(arr,left, right); s.push(left); s.push(p - 1); s.push(p+1); s.push(right); &#125; &#125; for(auto a : arr)&#123; cout&lt;&lt;a&lt;&lt;endl; &#125;&#125;int helper(vector&lt;int&gt;&amp;arr,int l,int r)&#123; int mid = l + (r - l)/2; if(arr[l] &gt; arr[mid]) swap(arr[l],arr[mid]); if(arr[mid] &gt; arr[r]) swap(arr[mid],arr[r]); if(arr[l] &gt; arr[mid]) swap(arr[mid],arr[l]); swap(arr[r - 1],arr[mid]); //找主元 int i = l + 1, j = r - 2; while(i &lt; j)&#123; while(i &lt; j &amp;&amp; arr[i] &lt; arr[r-1]) i++; while(i &lt; j &amp;&amp; arr[j] &gt; arr[r-1]) j--; if(i &lt; j) swap(arr[i], arr[j]); &#125; if(r-1 &gt; i) swap(arr[r - 1],arr[i]); return i;&#125; 表排序待排的是一个结构体，因为要频繁的移动，移动指针；定义一个指针数组；插入排序； 基数排序 桶排序 基数排序“次位优先”先排个位数 基数排序–多关键字 各种比较","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"【Leetcode】15. 3Sum","slug":"【Leetcode】15-3Sum","date":"2019-05-03T10:27:07.000Z","updated":"2019-06-21T07:24:30.128Z","comments":true,"path":"2019/05/03/【Leetcode】15-3Sum/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】15-3Sum/","excerpt":"","text":"题目 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。案例示例 1:1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路 将数组排序； 遍历数组，利用双指针的方法去找两个数的和相加是当前数的相反数的情况，见题目（）； 几点注意，因为题目中要求不能有重复的结果，重复的结果可能出现在两个地方，首先是，遍历的时候已经找到过的组合，还有就是对当前遍历到的数字，可能存在两种相同的组合；对两种情况进行排除即可。代码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; int n = nums.size(); if(n &lt;= 2) return result; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int t = nums[i]; if(i &gt; 0 &amp;&amp; t == nums[i - 1]) continue; if(t &gt; 0) break; else&#123; int tem = -t; int l = i + 1, r = n - 1; while(l &lt; r)&#123; if(nums[l] + nums[r] == tem) &#123; result.push_back(&#123;t,nums[l],nums[r]&#125;); while(l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++;//记住是为什么，是为了排除重复，而且有条件限制，所以不会在l+1处出问题 while(l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; &#125; else if(nums[l] + nums[r] &gt; tem) r--; else if(nums[l] + nums[r] &lt; tem) l++; &#125; &#125; &#125; return result; &#125; &#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】4. Median of Two Sorted Arrays","slug":"【Leetcode】4-Median-of-Two-Sorted-Arrays“","date":"2019-05-03T09:32:55.000Z","updated":"2019-05-03T09:38:19.984Z","comments":true,"path":"2019/05/03/【Leetcode】4-Median-of-Two-Sorted-Arrays“/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】4-Median-of-Two-Sorted-Arrays“/","excerpt":"","text":"题目 寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 案例示例 1:123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 思路 首先题目要求时间复杂度为O(log(m + n))，那么需要用二分法，但是两个数组怎么用二分法呢； 第二点，中位数要怎么找呢，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小 trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。 需要定义一个函数来在两个有序数组中找到第K个元素； 首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组 nums1 和 nums2 的起始位置。 然后来处理一些 corner cases，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果 K=1 的话，那么我们只要比较 nums1 和 nums2 的起始位置i和j上的数字就可以了。难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，那么对谁二分呢，数组么？其实要对K二分，意思是我们需要分别在 nums1 和 nums2 中查找第 K/2 个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第 K/2 个数字，所以我们需要先 check 一下，数组中到底存不存在第 K/2 个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第 K/2 个数字，那么我们就淘汰另一个数组的前 K/2 个数字即可。举个例子来说吧，比如 nums1 = {3}，nums2 = {2, 4, 5, 6, 7}，K=4，我们要找两个数组混合中第4个数字，那么我们分别在 nums1 和 nums2 中找第2个数字，我们发现 nums1 中只有一个数字，不存在第二个数字，那么 nums2 中的前2个数字可以直接跳过，为啥呢，因为我们要求整个混合数组的第4个数字，不管 nums1 中的那个数字是大是小，第4个数字绝不会出现在 nums2 的前两个数字中，所以可以直接跳过。 最后就是二分法的核心啦，比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，如果第一个数组的第 K/2 个数字小的话，那么说明我们要找的数字肯定不在 nums1 中的前 K/2 个数字，所以我们可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2，调用递归。反之，我们淘汰 nums2 中的前 K/2 个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2代码 12345678910111213141516171819class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(), left = (m + n + 1) / 2, right = (m + n + 2) / 2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; &#125; int findKth(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt;&amp; nums2, int j, int k) &#123; if (i &gt;= nums1.size()) return nums2[j + k - 1]; if (j &gt;= nums2.size()) return nums1[i + k - 1]; if (k == 1) return min(nums1[i], nums2[j]); int midVal1 = (i + k / 2 - 1 &lt; nums1.size()) ? nums1[i + k / 2 - 1] : INT_MAX; int midVal2 = (j + k / 2 - 1 &lt; nums2.size()) ? nums2[j + k / 2 - 1] : INT_MAX; if (midVal1 &lt; midVal2) &#123; return findKth(nums1, i + k / 2, nums2, j, k - k / 2); &#125; else &#123; return findKth(nums1, i, nums2, j + k / 2, k - k / 2); &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"困难","slug":"困难","permalink":"http://yoursite.com/tags/困难/"}]},{"title":"【Leetcode】1. Two Sum","slug":"【Leetcode】1-Two-Sum","date":"2019-05-03T07:46:05.000Z","updated":"2019-06-21T09:42:18.396Z","comments":true,"path":"2019/05/03/【Leetcode】1-Two-Sum/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】1-Two-Sum/","excerpt":"","text":"题目 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 案例示例 1:123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路最开始的想法应该都是用两重循环去遍历，这样会超时；可以用空间换时间，利用哈希表map进行存储;从前向后遍历，这样可以排除自己加自己的情况； 代码12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0; i &lt; nums.size(); i++)&#123; int t = target - nums[i]; if(m.count(t))&#123; return &#123;i,m[t]&#125;; &#125; else&#123; m[nums[i]] = i; &#125; &#125; return &#123;&#125;; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"类成员可访问的情况","slug":"类成员可访问的情况","date":"2019-04-27T02:30:49.000Z","updated":"2019-04-30T01:56:33.459Z","comments":true,"path":"2019/04/27/类成员可访问的情况/","link":"","permalink":"http://yoursite.com/2019/04/27/类成员可访问的情况/","excerpt":"","text":"Private基类的Private成员可以被以下两种访问： 基类的成员函数 基类的友员函数 Protected基类的Protected成员可以被以下访问： 基类的成员函数 基类的友员函数 派生类的成员函数可以访问当前对象的基类的保护成员 Pulbic基类的Pulbic成员可以被以下访问： 基类的成员函数 基类的友员函数 派生类的成员函数 派生类的友员函数 其他函数","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"}]},{"title":"多态，虚函数，抽象类","slug":"多态，虚函数，抽象类","date":"2019-04-24T14:20:01.000Z","updated":"2019-06-30T12:20:57.490Z","comments":true,"path":"2019/04/24/多态，虚函数，抽象类/","link":"","permalink":"http://yoursite.com/2019/04/24/多态，虚函数，抽象类/","excerpt":"","text":"多态 目的：提供程序的可扩充性，有些语言有继承的概念但是没有多态的概念，只能称为基于对象的语言，不能称为面向对象的语言； 多态的表现形式： 派生类的指针可以赋值给基类指针；（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数;（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。举例： 12345678910111213class CBase &#123; public: virtual void SomeVirtualFunction() &#123; &#125;&#125;;class CDerived:public CBase &#123;public : virtual void SomeVirtualFunction() &#123; &#125;&#125;;int main() &#123;CDerived ODerived;CBase * p = &amp; ODerived;p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象 return 0;&#125; 派生类的对象可以赋值给基类引用；（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数;（2）若该引用引用的是派生类的对象，那么被调用的是派生类的虚函数。 12345678910111213class CBase &#123; public: virtual void SomeVirtualFunction() &#123; &#125;&#125;;class CDerived:public CBase &#123;public : virtual void SomeVirtualFunction() &#123; &#125;&#125;;int main() &#123; CDerived ODerived; CBase &amp; r = ODerived; r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象 return 0;&#125; 虚函数在声明成员函数的时候，加上virtual关键字，该关键字只用在类定义函数的声明中，写函数体的时候不需要；注意 构造函数和静态成员函数不能是虚函数； 虚函数和普通函数的差别在于，虚函数可以参与多态，而普通函数不能 函数重写等于覆盖，重写的函数在基类中必须是虚函数； 派生类中和基类的虚函数同名同参数的函数，不叫virtual也会自动定义为虚函数； 虚函数的访问权限问题12345678910class Base &#123;private:virtual void fun2() &#123; cout &lt;&lt; \"Base::fun2()\" &lt;&lt; endl; &#125; &#125;;class Derived:public Base &#123; public:virtual void fun2() &#123; cout &lt;&lt; \"Derived:fun2()\" &lt;&lt; endl; &#125; &#125;;Derived d;Base * pBase = &amp; d;pBase -&gt; fun2(); // 编译出错 编译出错是因为fun2()是Base的私有成员。即使运行到此时实际上调用的应该是 Derived的公有成员 fun2()也不行，因为语法检查是不考虑运行结果的。如果将Base中的private换成public,即使Derived中的fun2()是private的，编译依然能通 过，也能正确调用Derived::fun2()。 一般基类的虚构函数都会写成是虚析构函数，因为要不然基类指针只会析构掉基类的，不会析构掉派生类new出来的东西；","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"多态","slug":"多态","permalink":"http://yoursite.com/tags/多态/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/虚函数/"},{"name":"抽象类","slug":"抽象类","permalink":"http://yoursite.com/tags/抽象类/"}]},{"title":"【Leetcode】106. Construct Binary Tree from Inorder and Postorder Traversal","slug":"【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal","date":"2019-04-22T14:12:25.000Z","updated":"2019-04-22T14:15:53.168Z","comments":true,"path":"2019/04/22/【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的中序遍历与后序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 123453 / \\9 20 / \\ 15 7 思路这道题是105基本相同，只不过，根节点在后续遍历数组的尾部，剩余都相同。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int il = 0, ir = inorder.size() - 1; int pl = 0, pr = postorder.size() - 1; return dfs(inorder, il, ir, postorder, pl, pr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; inorder, int il, int ir, vector&lt;int&gt;&amp; postorder, int pl, int pr)&#123; if(il &gt; ir || pl &gt; pr)&#123; return NULL; &#125; TreeNode* root = new TreeNode(postorder[pr]); int pos = 0; for(; pos &lt; ir; pos++)&#123; if(inorder[pos] == postorder[pr]) break; &#125; int len = pos - il; root-&gt;left = dfs(inorder, il, pos - 1, postorder, pl, pl + len - 1); root-&gt;right = dfs(inorder, pos + 1, ir, postorder, pl + len, pr - 1); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】105. Construct Binary Tree from Preorder and Inorder Traversal","slug":"【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","date":"2019-04-22T13:57:04.000Z","updated":"2019-04-22T14:10:51.617Z","comments":true,"path":"2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的前序遍历与中序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 123453 / \\9 20 / \\ 15 7 思路这道题实际上就是前序遍历的是，中左右，中序遍历的顺序是左中右，那么前序遍历的第一个点就是根节点，我们在中序遍历的数组中找到根节点的位置，左边就是左子树，右边就是右子树，不断的递归；这个题之前做的时候，是每次都构造新的vector,但是这样就会爆栈溢出，实际上每次传递引用即可。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int pl = 0, pr = preorder.size() - 1; int vl = 0, vr = inorder.size() - 1; return dfs(preorder, pl, pr, inorder, vl, vr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; preorder, int pl, int pr, vector&lt;int&gt;&amp; inorder, int vl, int vr)&#123; if(pl &gt; pr || vl &gt; vr)&#123; return NULL; &#125; int pos = 0; for(; pos &lt; vr; pos++)&#123; if(preorder[pl] == inorder[pos]) break; &#125; int len = pos - vl; TreeNode* root = new TreeNode(preorder[pl]); root-&gt;left = dfs(preorder, pl + 1, pl + len, inorder, vl, pos - 1); root-&gt;right = dfs(preorder, pl + len + 1, pr, inorder, pos + 1, vr); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】101.Symmetric Tree","slug":"【Leetcode】101-Symmetric-Tree","date":"2019-04-08T13:50:58.000Z","updated":"2019-04-08T14:05:13.777Z","comments":true,"path":"2019/04/08/【Leetcode】101-Symmetric-Tree/","link":"","permalink":"http://yoursite.com/2019/04/08/【Leetcode】101-Symmetric-Tree/","excerpt":"","text":"题目 判断是否是对称二叉树给定一个二叉树，检查它是否是镜像对称的。 案例二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \\2 2 \\ \\ 3 3 思路这道题反反复复几次总容易想错，实际上要看这个二叉树的左右子树是不是对称二叉树，实际上是看左右节点的子树是不是对称二叉树，也就是左节点的左子树和右节点的右子树是不是对称的，左节点的右子树和右节点的左子树的不是对称的。具体代码如下； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return issym(root-&gt;left, root-&gt;right); &#125; bool issym(TreeNode* left,TreeNode* right)&#123; if(!left &amp;&amp; !right) return true; if((!left &amp;&amp; right) || (left &amp;&amp; !right)) return false; if(left-&gt;val != right-&gt;val) return false; return issym(left-&gt;left, right-&gt;right) &amp;&amp; issym(left-&gt;right, right-&gt;left); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】81. Search in Rotated Sorted Array II","slug":"【Leetcode】81-Search-in-Rotated-Sorted-Array-II","date":"2019-03-06T14:53:38.000Z","updated":"2019-03-06T14:59:14.664Z","comments":true,"path":"2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 案例示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 思路这道题是33题的延伸，重复带来的问题就是，增加了判断哪边是有序的困难，比如[3 1 1] 和 [1 1 3 1]，对于这两种情况中间值等于最右值时，目标值3既可以在左边又可以在右边，那么其实，只要right和mid相等的话，我们直接将rihgt不断的减小就可以了。容易忘记等号！！！！ 代码123456789101112131415161718192021class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return true; if(nums[mid] &gt; nums[right])&#123; if(nums[mid] &gt; target &amp;&amp; target &gt;= nums[left]) right = mid - 1; else left = mid + 1; &#125;else if(nums[mid] &lt; nums[right])&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) left = mid + 1; else right = mid - 1; &#125;else right--; &#125; return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】33. Search in Rotated Sorted Array","slug":"【Leetcode】33-Search-in-Rotated-Sorted-Array","date":"2019-03-06T14:26:00.000Z","updated":"2019-03-06T14:37:20.833Z","comments":true,"path":"2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路如果是没旋转的，直接用二分法就可以了，但是旋转后的问题就在于不知道应该去左边和右边哪边找，实际上，如果mid大于right的值的话，那么就知道mid是旋转过来的，也就是左边是有序的，那我们先判断target是不是在左边，如果不是那么就是在右边；反之，如果mid小于right,说明mid是没有被旋转，右边是有序的，那么就先判断是不是属于右边，如果不是的话就属于左边；容易忘记等号！！！！ 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0; int right = n-1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; if(nums[mid] &gt; nums[right])//左边有序 &#123; if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])//容易忘记等号 &#123; right = mid -1; &#125; else left = mid + 1; &#125; else//右边有序 &#123; if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid+1; &#125; else right = mid -1; &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】67.Add Binary","slug":"【Leetcode】67-Add-Binary","date":"2019-03-03T05:15:05.000Z","updated":"2019-03-09T02:28:02.801Z","comments":true,"path":"2019/03/03/【Leetcode】67-Add-Binary/","link":"","permalink":"http://yoursite.com/2019/03/03/【Leetcode】67-Add-Binary/","excerpt":"","text":"题目 合并区间给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2:12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 思路从后向前看，如果当前的的位不存在，那么直接赋值为0，否则的话，赋值为当前的字符值，并于carry相加，这样不断的循环，直到两个字符串都遍历结束；具体看代码：需要注意的是，每次取的时候要转化成int; 代码123456789101112131415class Solution &#123;public: string addBinary(string a, string b) &#123; string res = \"\"; int m = a.length() - 1, n = b.length() - 1, carry = 0; while(m &gt;= 0 || n &gt;= 0)&#123; int i = m &gt;= 0 ? a[m--] - '0' : 0; int j = n &gt;= 0 ? b[n--] - '0' : 0; int tem = i + j + carry; res = to_string(tem % 2) + res; carry = tem / 2; &#125; return carry == 1 ? \"1\" + res : res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"}]},{"title":"【Leetcode】57.Insert Interval","slug":"【Leetcode】57-Insert-Interval","date":"2019-02-25T07:45:10.000Z","updated":"2019-02-25T08:15:23.310Z","comments":true,"path":"2019/02/25/【Leetcode】57-Insert-Interval/","link":"","permalink":"http://yoursite.com/2019/02/25/【Leetcode】57-Insert-Interval/","excerpt":"","text":"题目 合并区间给出一个无重叠的 ，按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 案例示例 1:12输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2:123输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 思路这个题和56题很像，唯一不同的就是是需要插入一个区间；思考这样的一个问题，这个区间应该插在哪里，实际上应该插在，该区间的start比原区间数组中的某一个元素的start刚好大于或者等于的情况；找到这个位置之后，就要考虑当前的插入区间是不是能直接插入还是需要和上一个区间合并，如果该区间的start比上一个区间的end要大的话，那么可以直接插入，或者还有一种特殊情况就是res中还没有区间，那么这两种情况都直接插入，否则的话就需要进行一次合并，合并的原则和56题一样，就是将当前res尾部的区间的end修改成插入区间的end和res尾部的end中的较大的值；然后再对剩余的区间依次做合并操作，最终得到结果； 代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); if(n == 0) &#123; res.push_back(newInterval); return res; &#125; int i = 0; for( ; i &lt; n; i++)&#123; if(newInterval.start &lt;= intervals[i].start) break; res.push_back(intervals[i]); &#125; if(i == 0 || newInterval.start &gt; intervals[i - 1].end) res.push_back(newInterval); else&#123; res.back().end = max(newInterval.end, res.back().end); &#125; for(; i &lt; n; i++)&#123; if(res.back().end &lt; intervals[i].start) res.push_back(intervals[i]); else res.back().end = max(res.back().end, intervals[i].end); &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"难","slug":"难","permalink":"http://yoursite.com/tags/难/"}]},{"title":"【Leetcode】56. Merge Intervals","slug":"【Leetcode】56-Merge-Intervals","date":"2019-02-24T15:07:06.000Z","updated":"2019-02-25T08:20:23.493Z","comments":true,"path":"2019/02/24/【Leetcode】56-Merge-Intervals/","link":"","permalink":"http://yoursite.com/2019/02/24/【Leetcode】56-Merge-Intervals/","excerpt":"","text":"题目 合并区间给出一个区间的集合，请合并所有重叠的区间。 案例示例 1:123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路首先将当前的区间按照start从低到高排序，如果后面一个区间的start比前一个的end要大，那么两者是没有重复的，直接将第二个放到当前的结果中；否则就是存在重复的区间，那就将当前res中最后一个区间的end，换成当前的end和原本的end的最大值；这个题目类似的题目是56题 代码123456789101112131415161718192021222324252627282930/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; if(n == 0) return res; sort(intervals.begin(), intervals.end(), cmp); res.push_back(intervals[0]); for(int i = 1; i &lt; n; i++)&#123; if(intervals[i].start &gt; res.back().end) res.push_back(intervals[i]); else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125; static bool cmp(Interval a, Interval b)&#123; return a.start &lt; b.start; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]},{"title":"关于c++ push ,pop小命令的笔记小抄","slug":"关于c-push-pop小命令的笔记小抄","date":"2019-02-23T03:04:33.000Z","updated":"2019-04-30T01:57:47.571Z","comments":true,"path":"2019/02/23/关于c-push-pop小命令的笔记小抄/","link":"","permalink":"http://yoursite.com/2019/02/23/关于c-push-pop小命令的笔记小抄/","excerpt":"","text":"set 插入：insert; vector 插入：push_back; 删除：pop_back; queuemap 访问map的key 和 value 的时候，是m.second 或者 m.first","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"c++习惯总结","slug":"c-习惯总结","permalink":"http://yoursite.com/tags/c-习惯总结/"}]},{"title":"leetcode之间的关系捋一捋","slug":"leetcode之间的关系捋一捋","date":"2019-02-23T02:21:44.000Z","updated":"2019-07-16T03:01:46.637Z","comments":true,"path":"2019/02/23/leetcode之间的关系捋一捋/","link":"","permalink":"http://yoursite.com/2019/02/23/leetcode之间的关系捋一捋/","excerpt":"","text":"组合类型 Permutations47. 39.40。 数组双指针【Leetcode】11.盛最多水的容器 求和问题双指针最后返回的是和值有关【Leetcode】15-3Sum【Leetcode】16-最接近的三数之和【Leetcode】16-最接近的三数之和map解决，返回的是下标Leetcode】1-Two-Sum 两个指针，一个指针用来锁定位置，一个用来遍历【Leetcode】26-删除排序数组中的重复项【Leetcode】27-移除元素 dfs、回溯【Leetcode】39-组合总和【Leetcode】40-组合总和-II 递归 类别1,二维dp数组可以只刷一次的是63【Leetcode】62. 不同路径【Leetcode】63. 不同路径 II【Leetcode】64. 最小路径和 哈希map【Leetcode】149. 直线上最多的点数（有三点注意） 技巧变小数为除以最大公约数，这样是比较保险的【Leetcode】149. 直线上最多的点数","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"知识点梳理","slug":"知识点梳理","permalink":"http://yoursite.com/tags/知识点梳理/"}]},{"title":"【leetcode】36. Valid Sudoku","slug":"【leetcode】36-Valid-Sudoku","date":"2019-02-21T14:09:21.000Z","updated":"2019-04-30T01:43:21.464Z","comments":true,"path":"2019/02/21/【leetcode】36-Valid-Sudoku/","link":"","permalink":"http://yoursite.com/2019/02/21/【leetcode】36-Valid-Sudoku/","excerpt":"","text":"题目 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 案例示例 1: 输入:12345678910111213[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:123456789101112输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] 输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 思路设置三个标志矩阵，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下，如下代码； 代码12345678910111213141516171819202122232425class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int n = board.size(); vector&lt;vector&lt;bool&gt;&gt; iscol(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; isrow(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; ismini(n,vector&lt;bool&gt;(n,false)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9') &#123; int t = board[i][j] - '1'; if(iscol[t][j] || isrow[i][t] || ismini[3 * (i / 3) + j / 3][t]) return false; iscol[t][j] = true; isrow[i][t] = true; ismini[3 * (i / 3) + j / 3][t] = true; &#125; &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]}]}
{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"油腻高贵的唐怂怂","date":"2019-02-15T10:45:41.000Z","updated":"2019-02-16T13:24:04.094Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me12345&lt;profile&gt; &lt;name&gt; ynggdttt &lt;/name&gt; &lt;email&gt; tangliyuan@sjtu.edu.cn &lt;/email&gt; &lt;location&gt; Shanghai, China &lt;/location&gt;&lt;/profile&gt; Tags Related: Coding, IT, Capturing, Reading, Books, Movies, fans of Maobuyi, Traveling, Music…… FAQ: 为什么叫 ynggdttt ？简单的不能再简单的翻译–油腻高贵的糖糖糖，2018年5月份粉上了毛不易先生，仔细想想能拿到 一句话描述自己：一个对曾以为自己很特别，现在逐渐接受也甘于平凡的人。 If you want to know more, contact me via my private WeChat account: zanglingyangshashou or email."}],"posts":[{"title":"【Leetcode】6. Z 字形变换","slug":"【Leetcode】6-Z-字形变换","date":"2019-05-30T07:52:03.000Z","updated":"2019-05-30T07:52:03.146Z","comments":true,"path":"2019/05/30/【Leetcode】6-Z-字形变换/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】6-Z-字形变换/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【Leetcode】5. 最长回文子串","slug":"【Leetcode】5-最长回文子串","date":"2019-05-27T14:35:14.716Z","updated":"2019-05-27T14:48:49.869Z","comments":true,"path":"2019/05/27/【Leetcode】5-最长回文子串/","link":"","permalink":"http://yoursite.com/2019/05/27/【Leetcode】5-最长回文子串/","excerpt":"","text":"题目 无重复字符的最长子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 案例示例 1:123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2:12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 思路遍历每个字符，然后获取这个字符作为中间的最长的回文串；再去更新结果；分为两种情况，回文串为奇数和偶数两种情况；具体代码如下； 代码123456789101112131415161718192021class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; int n = s.size(), maxLen = 0, start = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; searchPalindrome(s, i, i, start, maxLen); searchPalindrome(s, i, i + 1, start, maxLen); &#125; return s.substr(start, maxLen); &#125; void searchPalindrome(string s, int left, int right, int&amp; start, int&amp; maxLen) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; if (maxLen &lt; right - left - 1) &#123; start = left + 1; maxLen = right - left - 1; &#125; &#125;&#125;; 需要记住的点 很巧妙的用了引用；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】3. 无重复字符的最长子串","slug":"【Leetcode】3-无重复字符的最长子串","date":"2019-05-27T13:59:22.000Z","updated":"2019-05-27T14:09:33.416Z","comments":true,"path":"2019/05/27/【Leetcode】3-无重复字符的最长子串/","link":"","permalink":"http://yoursite.com/2019/05/27/【Leetcode】3-无重复字符的最长子串/","excerpt":"","text":"题目 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。 案例示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路建立一个HashMap，建立每个字符和其最后出现位置之间的映射，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置的前一个，由于是前一个，所以初始化就是-1，然后我们遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在HashMap中存在了，并且如果其映射值大于left的话，那么更新left为当前映射值。然后映射值更新为当前坐标i，这样保证了left始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用i-left即可，用来更新结果res。几个比较关键的点： left初始值设为1，因为我们定义left是当前窗口的前一个值；代码 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0, left = -1, n = s.size(); unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; n; ++i) &#123; if (m.count(s[i]) &amp;&amp; m[s[i]] &gt; left) &#123;//比较精华的一句话 left = m[s[i]]; &#125; m[s[i]] = i; res = max(res, i - left); &#125; return res; &#125;&#125;; 需要记住的点 unordered_map查找，用m.count(val); 包含再头文件unordered_map中；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/滑动窗口/"}]},{"title":"排序算法","slug":"排序算法“","date":"2019-05-04T12:30:21.000Z","updated":"2019-05-04T12:43:02.899Z","comments":true,"path":"2019/05/04/排序算法“/","link":"","permalink":"http://yoursite.com/2019/05/04/排序算法“/","excerpt":"","text":"选择排序 时间复杂度：n^2，最好的最坏的情况都是； 不需要额外的空间； 不稳定；代码：123456789101112void helper(vector&lt;int&gt; &amp;b)&#123; int n = b.size(); for(int i = 0; i &lt; n; i++)&#123; int index = i; for(int j = i + 1; j &lt; n; j++)&#123; if(b[j] &lt; b[index])&#123; index = j; &#125; &#125; swap(b[i],b[index]); &#125;&#125; 冒泡排序冒泡排序的思想是，从第0个元素到第n-1个元素遍历，若前面一个元素大于后面一个元素，则交换两个元素，这样可将整个序列中最大的元素冒泡到最后，然后再从第0个到第n-2遍历，如此往复，直到只剩一个元素。 时间复杂度：n^2，最好的最坏的情况都是； 不需要额外的空间； 不稳定 好在可以在内层循环中设置一个flag,如果在当前的循环中从来没有进行过交换，那么说明内部已经是完全有序的了，那么这种情况，最好的情况是时间复杂度为n;代码：123456789101112131415void helper(vector&lt;int&gt; &amp;b)&#123; int n = b.size(); for(int i = n - 1; i &gt; 0; i--)&#123; bool flag = false; for(int j = 0; j &lt; i; j++)&#123; if(b[j] &gt; b[j + 1])&#123; flag = true; swap(b[j], b[j+1]); &#125; &#125; if(!flag)&#123; break; &#125; &#125;&#125;","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"【Leetcode】15. 3Sum","slug":"【Leetcode】15-3Sum","date":"2019-05-03T10:27:07.000Z","updated":"2019-05-03T10:54:55.241Z","comments":true,"path":"2019/05/03/【Leetcode】15-3Sum/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】15-3Sum/","excerpt":"","text":"题目 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。案例示例 1:1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路 将数组排序； 遍历数组，利用双指针的方法去找两个数的和相加是当前数的相反数的情况，见题目（）； 几点注意，因为题目中要求不能有重复的结果，重复的结果可能出现在两个地方，首先是，遍历的时候已经找到过的组合，还有就是对当前遍历到的数字，可能存在两种相同的组合；对两种情况进行排除即可。代码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; int n = nums.size(); if(n &lt;= 2) return result; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int t = nums[i]; if(i &gt; 0 &amp;&amp; t == nums[i - 1]) continue; if(t &gt; 0) break; else&#123; int tem = -t; int l = i + 1, r = n - 1; while(l &lt; r)&#123; if(nums[l] + nums[r] == tem) &#123; result.push_back(&#123;t,nums[l],nums[r]&#125;); while(l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while(l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; &#125; else if(nums[l] + nums[r] &gt; tem) r--; else if(nums[l] + nums[r] &lt; tem) l++; &#125; &#125; &#125; return result; &#125; &#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】4. Median of Two Sorted Arrays","slug":"【Leetcode】4-Median-of-Two-Sorted-Arrays“","date":"2019-05-03T09:32:55.000Z","updated":"2019-05-03T09:38:19.984Z","comments":true,"path":"2019/05/03/【Leetcode】4-Median-of-Two-Sorted-Arrays“/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】4-Median-of-Two-Sorted-Arrays“/","excerpt":"","text":"题目 寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 案例示例 1:123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 思路 首先题目要求时间复杂度为O(log(m + n))，那么需要用二分法，但是两个数组怎么用二分法呢； 第二点，中位数要怎么找呢，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小 trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。 需要定义一个函数来在两个有序数组中找到第K个元素； 首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组 nums1 和 nums2 的起始位置。 然后来处理一些 corner cases，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果 K=1 的话，那么我们只要比较 nums1 和 nums2 的起始位置i和j上的数字就可以了。难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，那么对谁二分呢，数组么？其实要对K二分，意思是我们需要分别在 nums1 和 nums2 中查找第 K/2 个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第 K/2 个数字，所以我们需要先 check 一下，数组中到底存不存在第 K/2 个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第 K/2 个数字，那么我们就淘汰另一个数组的前 K/2 个数字即可。举个例子来说吧，比如 nums1 = {3}，nums2 = {2, 4, 5, 6, 7}，K=4，我们要找两个数组混合中第4个数字，那么我们分别在 nums1 和 nums2 中找第2个数字，我们发现 nums1 中只有一个数字，不存在第二个数字，那么 nums2 中的前2个数字可以直接跳过，为啥呢，因为我们要求整个混合数组的第4个数字，不管 nums1 中的那个数字是大是小，第4个数字绝不会出现在 nums2 的前两个数字中，所以可以直接跳过。 最后就是二分法的核心啦，比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，如果第一个数组的第 K/2 个数字小的话，那么说明我们要找的数字肯定不在 nums1 中的前 K/2 个数字，所以我们可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2，调用递归。反之，我们淘汰 nums2 中的前 K/2 个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2代码 12345678910111213141516171819class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(), left = (m + n + 1) / 2, right = (m + n + 2) / 2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; &#125; int findKth(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt;&amp; nums2, int j, int k) &#123; if (i &gt;= nums1.size()) return nums2[j + k - 1]; if (j &gt;= nums2.size()) return nums1[i + k - 1]; if (k == 1) return min(nums1[i], nums2[j]); int midVal1 = (i + k / 2 - 1 &lt; nums1.size()) ? nums1[i + k / 2 - 1] : INT_MAX; int midVal2 = (j + k / 2 - 1 &lt; nums2.size()) ? nums2[j + k / 2 - 1] : INT_MAX; if (midVal1 &lt; midVal2) &#123; return findKth(nums1, i + k / 2, nums2, j, k - k / 2); &#125; else &#123; return findKth(nums1, i, nums2, j + k / 2, k - k / 2); &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"困难","slug":"困难","permalink":"http://yoursite.com/tags/困难/"}]},{"title":"【Leetcode】1. Two Sum","slug":"【Leetcode】1-Two-Sum","date":"2019-05-03T07:46:05.000Z","updated":"2019-05-03T07:57:23.405Z","comments":true,"path":"2019/05/03/【Leetcode】1-Two-Sum/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】1-Two-Sum/","excerpt":"","text":"题目 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 案例示例 1:123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 说明实际上是 思路设置三个标志矩阵，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下，如下代码； 代码12345678910111213141516171819202122232425class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int n = board.size(); vector&lt;vector&lt;bool&gt;&gt; iscol(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; isrow(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; ismini(n,vector&lt;bool&gt;(n,false)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9') &#123; int t = board[i][j] - '1'; if(iscol[t][j] || isrow[i][t] || ismini[3 * (i / 3) + j / 3][t]) return false; iscol[t][j] = true; isrow[i][t] = true; ismini[3 * (i / 3) + j / 3][t] = true; &#125; &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"类成员可访问的情况","slug":"类成员可访问的情况","date":"2019-04-27T02:30:49.000Z","updated":"2019-04-30T01:56:33.459Z","comments":true,"path":"2019/04/27/类成员可访问的情况/","link":"","permalink":"http://yoursite.com/2019/04/27/类成员可访问的情况/","excerpt":"","text":"Private基类的Private成员可以被以下两种访问： 基类的成员函数 基类的友员函数 Protected基类的Protected成员可以被以下访问： 基类的成员函数 基类的友员函数 派生类的成员函数可以访问当前对象的基类的保护成员 Pulbic基类的Pulbic成员可以被以下访问： 基类的成员函数 基类的友员函数 派生类的成员函数 派生类的友员函数 其他函数","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"}]},{"title":"多态，虚函数，抽象类","slug":"多态，虚函数，抽象类","date":"2019-04-24T14:20:01.000Z","updated":"2019-04-30T01:56:31.287Z","comments":true,"path":"2019/04/24/多态，虚函数，抽象类/","link":"","permalink":"http://yoursite.com/2019/04/24/多态，虚函数，抽象类/","excerpt":"","text":"多态 目的：提供程序的可扩充性，有些语言有继承的概念但是没有多态的概念，只能称为基于对象的语言，不能称为面向对象的语言； 多态的表现形式： 派生类的指针可以赋值给基类指针；（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数;（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。举例： 12345678910111213class CBase &#123; public: virtual void SomeVirtualFunction() &#123; &#125;&#125;;class CDerived:public CBase &#123;public : virtual void SomeVirtualFunction() &#123; &#125;&#125;;int main() &#123;CDerived ODerived;CBase * p = &amp; ODerived;p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象 return 0;&#125; 派生类的对象可以赋值给基类引用；（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数;（2）若该引用引用的是派生类的对象，那么被调用的是派生类的虚函数。 12345678910111213class CBase &#123; public: virtual void SomeVirtualFunction() &#123; &#125;&#125;;class CDerived:public CBase &#123;public : virtual void SomeVirtualFunction() &#123; &#125;&#125;;int main() &#123; CDerived ODerived; CBase &amp; r = ODerived; r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象 return 0;&#125; 多态的原理 – 动态连编 “多态”的关键在于通过基类指针或引用调用 一个虚函数时，编译时不确定到底调用的是基类还 是派生类的函数，运行时才确定 —- 这叫“动态联编”。 虚函数表1）每一个有虚函数的类(或有虚函数的类的派生类) 都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。如图：多态的函数调用语句被编译成一系列根据基类指针所指向的(或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令； 虚函数在声明成员函数的时候，加上virtual关键字，该关键字只用在类定义函数的声明中，写函数体的时候不需要；注意 构造函数和静态成员函数不能是虚函数； 虚函数和普通函数的差别在于，虚函数可以参与多态，而普通函数不能 函数重写等于覆盖，重写的函数在基类中必须是虚函数； 派生类中和基类的虚函数同名同参数的函数，不叫virtual也会自动定义为虚函数； 虚函数的访问权限问题12345678910class Base &#123;private:virtual void fun2() &#123; cout &lt;&lt; \"Base::fun2()\" &lt;&lt; endl; &#125; &#125;;class Derived:public Base &#123; public:virtual void fun2() &#123; cout &lt;&lt; \"Derived:fun2()\" &lt;&lt; endl; &#125; &#125;;Derived d;Base * pBase = &amp; d;pBase -&gt; fun2(); // 编译出错 编译出错是因为fun2()是Base的私有成员。即使运行到此时实际上调用的应该是 Derived的公有成员 fun2()也不行，因为语法检查是不考虑运行结果的。如果将Base中的private换成public,即使Derived中的fun2()是private的，编译依然能通 过，也能正确调用Derived::fun2()。 一般基类的虚构函数都会写成是虚析构函数，这样才能把构造的对象成彻底析构掉； 纯虚函数和抽象类 纯虚函数: 没有函数体的虚函数；virtual void Print( ) = 0 ; 包含纯虚函数的类叫抽象类； 抽象类只能作为基类来派生新类使用，不能创建抽象类的对象 抽象类的指针和引用可以指向由抽象类派生出来的类的对象 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函 数，它才能成为非抽象类； 补充没有多态机制的语言，叫基于对象的程序语言，有多态的才叫面向对象语言；","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"多态","slug":"多态","permalink":"http://yoursite.com/tags/多态/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/虚函数/"},{"name":"抽象类","slug":"抽象类","permalink":"http://yoursite.com/tags/抽象类/"}]},{"title":"【Leetcode】106. Construct Binary Tree from Inorder and Postorder Traversal","slug":"【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal","date":"2019-04-22T14:12:25.000Z","updated":"2019-04-22T14:15:53.168Z","comments":true,"path":"2019/04/22/【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的中序遍历与后序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 123453 / \\9 20 / \\ 15 7 思路这道题是105基本相同，只不过，根节点在后续遍历数组的尾部，剩余都相同。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int il = 0, ir = inorder.size() - 1; int pl = 0, pr = postorder.size() - 1; return dfs(inorder, il, ir, postorder, pl, pr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; inorder, int il, int ir, vector&lt;int&gt;&amp; postorder, int pl, int pr)&#123; if(il &gt; ir || pl &gt; pr)&#123; return NULL; &#125; TreeNode* root = new TreeNode(postorder[pr]); int pos = 0; for(; pos &lt; ir; pos++)&#123; if(inorder[pos] == postorder[pr]) break; &#125; int len = pos - il; root-&gt;left = dfs(inorder, il, pos - 1, postorder, pl, pl + len - 1); root-&gt;right = dfs(inorder, pos + 1, ir, postorder, pl + len, pr - 1); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】105. Construct Binary Tree from Preorder and Inorder Traversal","slug":"【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","date":"2019-04-22T13:57:04.000Z","updated":"2019-04-22T14:10:51.617Z","comments":true,"path":"2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的前序遍历与中序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 123453 / \\9 20 / \\ 15 7 思路这道题实际上就是前序遍历的是，中左右，中序遍历的顺序是左中右，那么前序遍历的第一个点就是根节点，我们在中序遍历的数组中找到根节点的位置，左边就是左子树，右边就是右子树，不断的递归；这个题之前做的时候，是每次都构造新的vector,但是这样就会爆栈溢出，实际上每次传递引用即可。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int pl = 0, pr = preorder.size() - 1; int vl = 0, vr = inorder.size() - 1; return dfs(preorder, pl, pr, inorder, vl, vr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; preorder, int pl, int pr, vector&lt;int&gt;&amp; inorder, int vl, int vr)&#123; if(pl &gt; pr || vl &gt; vr)&#123; return NULL; &#125; int pos = 0; for(; pos &lt; vr; pos++)&#123; if(preorder[pl] == inorder[pos]) break; &#125; int len = pos - vl; TreeNode* root = new TreeNode(preorder[pl]); root-&gt;left = dfs(preorder, pl + 1, pl + len, inorder, vl, pos - 1); root-&gt;right = dfs(preorder, pl + len + 1, pr, inorder, pos + 1, vr); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】101.Symmetric Tree","slug":"【Leetcode】101-Symmetric-Tree","date":"2019-04-08T13:50:58.000Z","updated":"2019-04-08T14:05:13.777Z","comments":true,"path":"2019/04/08/【Leetcode】101-Symmetric-Tree/","link":"","permalink":"http://yoursite.com/2019/04/08/【Leetcode】101-Symmetric-Tree/","excerpt":"","text":"题目 判断是否是对称二叉树给定一个二叉树，检查它是否是镜像对称的。 案例二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \\2 2 \\ \\ 3 3 思路这道题反反复复几次总容易想错，实际上要看这个二叉树的左右子树是不是对称二叉树，实际上是看左右节点的子树是不是对称二叉树，也就是左节点的左子树和右节点的右子树是不是对称的，左节点的右子树和右节点的左子树的不是对称的。具体代码如下； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return issym(root-&gt;left, root-&gt;right); &#125; bool issym(TreeNode* left,TreeNode* right)&#123; if(!left &amp;&amp; !right) return true; if((!left &amp;&amp; right) || (left &amp;&amp; !right)) return false; if(left-&gt;val != right-&gt;val) return false; return issym(left-&gt;left, right-&gt;right) &amp;&amp; issym(left-&gt;right, right-&gt;left); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】81. Search in Rotated Sorted Array II","slug":"【Leetcode】81-Search-in-Rotated-Sorted-Array-II","date":"2019-03-06T14:53:38.000Z","updated":"2019-03-06T14:59:14.664Z","comments":true,"path":"2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 案例示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 思路这道题是33题的延伸，重复带来的问题就是，增加了判断哪边是有序的困难，比如[3 1 1] 和 [1 1 3 1]，对于这两种情况中间值等于最右值时，目标值3既可以在左边又可以在右边，那么其实，只要right和mid相等的话，我们直接将rihgt不断的减小就可以了。容易忘记等号！！！！ 代码123456789101112131415161718192021class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return true; if(nums[mid] &gt; nums[right])&#123; if(nums[mid] &gt; target &amp;&amp; target &gt;= nums[left]) right = mid - 1; else left = mid + 1; &#125;else if(nums[mid] &lt; nums[right])&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) left = mid + 1; else right = mid - 1; &#125;else right--; &#125; return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】33. Search in Rotated Sorted Array","slug":"【Leetcode】33-Search-in-Rotated-Sorted-Array","date":"2019-03-06T14:26:00.000Z","updated":"2019-03-06T14:37:20.833Z","comments":true,"path":"2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路如果是没旋转的，直接用二分法就可以了，但是旋转后的问题就在于不知道应该去左边和右边哪边找，实际上，如果mid大于right的值的话，那么就知道mid是旋转过来的，也就是左边是有序的，那我们先判断target是不是在左边，如果不是那么就是在右边；反之，如果mid小于right,说明mid是没有被旋转，右边是有序的，那么就先判断是不是属于右边，如果不是的话就属于左边；容易忘记等号！！！！ 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0; int right = n-1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; if(nums[mid] &gt; nums[right])//左边有序 &#123; if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])//容易忘记等号 &#123; right = mid -1; &#125; else left = mid + 1; &#125; else//右边有序 &#123; if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid+1; &#125; else right = mid -1; &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】67.Add Binary","slug":"【Leetcode】67-Add-Binary","date":"2019-03-03T05:15:05.000Z","updated":"2019-03-09T02:28:02.801Z","comments":true,"path":"2019/03/03/【Leetcode】67-Add-Binary/","link":"","permalink":"http://yoursite.com/2019/03/03/【Leetcode】67-Add-Binary/","excerpt":"","text":"题目 合并区间给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2:12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 思路从后向前看，如果当前的的位不存在，那么直接赋值为0，否则的话，赋值为当前的字符值，并于carry相加，这样不断的循环，直到两个字符串都遍历结束；具体看代码：需要注意的是，每次取的时候要转化成int; 代码123456789101112131415class Solution &#123;public: string addBinary(string a, string b) &#123; string res = \"\"; int m = a.length() - 1, n = b.length() - 1, carry = 0; while(m &gt;= 0 || n &gt;= 0)&#123; int i = m &gt;= 0 ? a[m--] - '0' : 0; int j = n &gt;= 0 ? b[n--] - '0' : 0; int tem = i + j + carry; res = to_string(tem % 2) + res; carry = tem / 2; &#125; return carry == 1 ? \"1\" + res : res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"}]},{"title":"【Leetcode】57.Insert Interval","slug":"【Leetcode】57-Insert-Interval","date":"2019-02-25T07:45:10.000Z","updated":"2019-02-25T08:15:23.310Z","comments":true,"path":"2019/02/25/【Leetcode】57-Insert-Interval/","link":"","permalink":"http://yoursite.com/2019/02/25/【Leetcode】57-Insert-Interval/","excerpt":"","text":"题目 合并区间给出一个无重叠的 ，按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 案例示例 1:12输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2:123输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 思路这个题和56题很像，唯一不同的就是是需要插入一个区间；思考这样的一个问题，这个区间应该插在哪里，实际上应该插在，该区间的start比原区间数组中的某一个元素的start刚好大于或者等于的情况；找到这个位置之后，就要考虑当前的插入区间是不是能直接插入还是需要和上一个区间合并，如果该区间的start比上一个区间的end要大的话，那么可以直接插入，或者还有一种特殊情况就是res中还没有区间，那么这两种情况都直接插入，否则的话就需要进行一次合并，合并的原则和56题一样，就是将当前res尾部的区间的end修改成插入区间的end和res尾部的end中的较大的值；然后再对剩余的区间依次做合并操作，最终得到结果； 代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); if(n == 0) &#123; res.push_back(newInterval); return res; &#125; int i = 0; for( ; i &lt; n; i++)&#123; if(newInterval.start &lt;= intervals[i].start) break; res.push_back(intervals[i]); &#125; if(i == 0 || newInterval.start &gt; intervals[i - 1].end) res.push_back(newInterval); else&#123; res.back().end = max(newInterval.end, res.back().end); &#125; for(; i &lt; n; i++)&#123; if(res.back().end &lt; intervals[i].start) res.push_back(intervals[i]); else res.back().end = max(res.back().end, intervals[i].end); &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"难","slug":"难","permalink":"http://yoursite.com/tags/难/"}]},{"title":"【Leetcode】56. Merge Intervals","slug":"【Leetcode】56-Merge-Intervals","date":"2019-02-24T15:07:06.000Z","updated":"2019-02-25T08:20:23.493Z","comments":true,"path":"2019/02/24/【Leetcode】56-Merge-Intervals/","link":"","permalink":"http://yoursite.com/2019/02/24/【Leetcode】56-Merge-Intervals/","excerpt":"","text":"题目 合并区间给出一个区间的集合，请合并所有重叠的区间。 案例示例 1:123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路首先将当前的区间按照start从低到高排序，如果后面一个区间的start比前一个的end要大，那么两者是没有重复的，直接将第二个放到当前的结果中；否则就是存在重复的区间，那就将当前res中最后一个区间的end，换成当前的end和原本的end的最大值；这个题目类似的题目是56题 代码123456789101112131415161718192021222324252627282930/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; if(n == 0) return res; sort(intervals.begin(), intervals.end(), cmp); res.push_back(intervals[0]); for(int i = 1; i &lt; n; i++)&#123; if(intervals[i].start &gt; res.back().end) res.push_back(intervals[i]); else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125; static bool cmp(Interval a, Interval b)&#123; return a.start &lt; b.start; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]},{"title":"关于c++ push ,pop小命令的笔记小抄","slug":"关于c-push-pop小命令的笔记小抄","date":"2019-02-23T03:04:33.000Z","updated":"2019-04-30T01:57:47.571Z","comments":true,"path":"2019/02/23/关于c-push-pop小命令的笔记小抄/","link":"","permalink":"http://yoursite.com/2019/02/23/关于c-push-pop小命令的笔记小抄/","excerpt":"","text":"set 插入：insert; vector 插入：push_back; 删除：pop_back; queuemap 访问map的key 和 value 的时候，是m.second 或者 m.first","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"c++习惯总结","slug":"c-习惯总结","permalink":"http://yoursite.com/tags/c-习惯总结/"}]},{"title":"leetcode之间的关系捋一捋","slug":"leetcode之间的关系捋一捋","date":"2019-02-23T02:21:44.000Z","updated":"2019-02-23T03:14:14.238Z","comments":true,"path":"2019/02/23/leetcode之间的关系捋一捋/","link":"","permalink":"http://yoursite.com/2019/02/23/leetcode之间的关系捋一捋/","excerpt":"","text":"组合类型 Permutations47. 39.40。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"知识点梳理","slug":"知识点梳理","permalink":"http://yoursite.com/tags/知识点梳理/"}]},{"title":"【leetcode】36. Valid Sudoku","slug":"【leetcode】36-Valid-Sudoku","date":"2019-02-21T14:09:21.000Z","updated":"2019-04-30T01:43:21.464Z","comments":true,"path":"2019/02/21/【leetcode】36-Valid-Sudoku/","link":"","permalink":"http://yoursite.com/2019/02/21/【leetcode】36-Valid-Sudoku/","excerpt":"","text":"题目 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 案例示例 1: 输入:12345678910111213[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:123456789101112输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] 输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 思路设置三个标志矩阵，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下，如下代码； 代码12345678910111213141516171819202122232425class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int n = board.size(); vector&lt;vector&lt;bool&gt;&gt; iscol(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; isrow(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; ismini(n,vector&lt;bool&gt;(n,false)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9') &#123; int t = board[i][j] - '1'; if(iscol[t][j] || isrow[i][t] || ismini[3 * (i / 3) + j / 3][t]) return false; iscol[t][j] = true; isrow[i][t] = true; ismini[3 * (i / 3) + j / 3][t] = true; &#125; &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]}]}
{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"油腻高贵的唐怂怂","date":"2019-02-15T10:45:41.000Z","updated":"2019-02-16T13:24:04.094Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me12345&lt;profile&gt; &lt;name&gt; ynggdttt &lt;/name&gt; &lt;email&gt; tangliyuan@sjtu.edu.cn &lt;/email&gt; &lt;location&gt; Shanghai, China &lt;/location&gt;&lt;/profile&gt; Tags Related: Coding, IT, Capturing, Reading, Books, Movies, fans of Maobuyi, Traveling, Music…… FAQ: 为什么叫 ynggdttt ？简单的不能再简单的翻译–油腻高贵的糖糖糖，2018年5月份粉上了毛不易先生，仔细想想能拿到 一句话描述自己：一个对曾以为自己很特别，现在逐渐接受也甘于平凡的人。 If you want to know more, contact me via my private WeChat account: zanglingyangshashou or email."}],"posts":[{"title":"【Leetcode】105. Construct Binary Tree from Preorder and Inorder Traversal","slug":"【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","date":"2019-04-22T13:57:04.000Z","updated":"2019-04-22T14:10:51.617Z","comments":true,"path":"2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的前序遍历与中序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 123453 / \\9 20 / \\ 15 7 思路这道题实际上就是前序遍历的是，中左右，中序遍历的顺序是左中右，那么前序遍历的第一个点就是根节点，我们在中序遍历的数组中找到根节点的位置，左边就是左子树，右边就是右子树，不断的递归；这个题之前做的时候，是每次都构造新的vector,但是这样就会爆栈溢出，实际上每次传递引用即可。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int pl = 0, pr = preorder.size() - 1; int vl = 0, vr = inorder.size() - 1; return dfs(preorder, pl, pr, inorder, vl, vr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; preorder, int pl, int pr, vector&lt;int&gt;&amp; inorder, int vl, int vr)&#123; if(pl &gt; pr || vl &gt; vr)&#123; return NULL; &#125; int pos = 0; for(; pos &lt; vr; pos++)&#123; if(preorder[pl] == inorder[pos]) break; &#125; int len = pos - vl; TreeNode* root = new TreeNode(preorder[pl]); root-&gt;left = dfs(preorder, pl + 1, pl + len, inorder, vl, pos - 1); root-&gt;right = dfs(preorder, pl + len + 1, pr, inorder, pos + 1, vr); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】101.Symmetric Tree","slug":"【Leetcode】101-Symmetric-Tree","date":"2019-04-08T13:50:58.000Z","updated":"2019-04-08T14:05:13.777Z","comments":true,"path":"2019/04/08/【Leetcode】101-Symmetric-Tree/","link":"","permalink":"http://yoursite.com/2019/04/08/【Leetcode】101-Symmetric-Tree/","excerpt":"","text":"题目 判断是否是对称二叉树给定一个二叉树，检查它是否是镜像对称的。 案例二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \\2 2 \\ \\ 3 3 思路这道题反反复复几次总容易想错，实际上要看这个二叉树的左右子树是不是对称二叉树，实际上是看左右节点的子树是不是对称二叉树，也就是左节点的左子树和右节点的右子树是不是对称的，左节点的右子树和右节点的左子树的不是对称的。具体代码如下； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return issym(root-&gt;left, root-&gt;right); &#125; bool issym(TreeNode* left,TreeNode* right)&#123; if(!left &amp;&amp; !right) return true; if((!left &amp;&amp; right) || (left &amp;&amp; !right)) return false; if(left-&gt;val != right-&gt;val) return false; return issym(left-&gt;left, right-&gt;right) &amp;&amp; issym(left-&gt;right, right-&gt;left); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】81. Search in Rotated Sorted Array II","slug":"【Leetcode】81-Search-in-Rotated-Sorted-Array-II","date":"2019-03-06T14:53:38.000Z","updated":"2019-03-06T14:59:14.664Z","comments":true,"path":"2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 案例示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 思路这道题是33题的延伸，重复带来的问题就是，增加了判断哪边是有序的困难，比如[3 1 1] 和 [1 1 3 1]，对于这两种情况中间值等于最右值时，目标值3既可以在左边又可以在右边，那么其实，只要right和mid相等的话，我们直接将rihgt不断的减小就可以了。容易忘记等号！！！！ 代码123456789101112131415161718192021class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return true; if(nums[mid] &gt; nums[right])&#123; if(nums[mid] &gt; target &amp;&amp; target &gt;= nums[left]) right = mid - 1; else left = mid + 1; &#125;else if(nums[mid] &lt; nums[right])&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) left = mid + 1; else right = mid - 1; &#125;else right--; &#125; return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"【Leetcode】33. Search in Rotated Sorted Array","slug":"【Leetcode】33-Search-in-Rotated-Sorted-Array","date":"2019-03-06T14:26:00.000Z","updated":"2019-03-06T14:37:20.833Z","comments":true,"path":"2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路如果是没旋转的，直接用二分法就可以了，但是旋转后的问题就在于不知道应该去左边和右边哪边找，实际上，如果mid大于right的值的话，那么就知道mid是旋转过来的，也就是左边是有序的，那我们先判断target是不是在左边，如果不是那么就是在右边；反之，如果mid小于right,说明mid是没有被旋转，右边是有序的，那么就先判断是不是属于右边，如果不是的话就属于左边；容易忘记等号！！！！ 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0; int right = n-1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; if(nums[mid] &gt; nums[right])//左边有序 &#123; if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])//容易忘记等号 &#123; right = mid -1; &#125; else left = mid + 1; &#125; else//右边有序 &#123; if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid+1; &#125; else right = mid -1; &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"【Leetcode】67.Add Binary","slug":"【Leetcode】67-Add-Binary","date":"2019-03-03T05:15:05.000Z","updated":"2019-03-09T02:28:02.801Z","comments":true,"path":"2019/03/03/【Leetcode】67-Add-Binary/","link":"","permalink":"http://yoursite.com/2019/03/03/【Leetcode】67-Add-Binary/","excerpt":"","text":"题目 合并区间给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2:12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 思路从后向前看，如果当前的的位不存在，那么直接赋值为0，否则的话，赋值为当前的字符值，并于carry相加，这样不断的循环，直到两个字符串都遍历结束；具体看代码：需要注意的是，每次取的时候要转化成int; 代码123456789101112131415class Solution &#123;public: string addBinary(string a, string b) &#123; string res = \"\"; int m = a.length() - 1, n = b.length() - 1, carry = 0; while(m &gt;= 0 || n &gt;= 0)&#123; int i = m &gt;= 0 ? a[m--] - '0' : 0; int j = n &gt;= 0 ? b[n--] - '0' : 0; int tem = i + j + carry; res = to_string(tem % 2) + res; carry = tem / 2; &#125; return carry == 1 ? \"1\" + res : res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"}]},{"title":"【Leetcode】57.Insert Interval","slug":"【Leetcode】57-Insert-Interval","date":"2019-02-25T07:45:10.000Z","updated":"2019-02-25T08:15:23.310Z","comments":true,"path":"2019/02/25/【Leetcode】57-Insert-Interval/","link":"","permalink":"http://yoursite.com/2019/02/25/【Leetcode】57-Insert-Interval/","excerpt":"","text":"题目 合并区间给出一个无重叠的 ，按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 案例示例 1:12输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2:123输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 思路这个题和56题很像，唯一不同的就是是需要插入一个区间；思考这样的一个问题，这个区间应该插在哪里，实际上应该插在，该区间的start比原区间数组中的某一个元素的start刚好大于或者等于的情况；找到这个位置之后，就要考虑当前的插入区间是不是能直接插入还是需要和上一个区间合并，如果该区间的start比上一个区间的end要大的话，那么可以直接插入，或者还有一种特殊情况就是res中还没有区间，那么这两种情况都直接插入，否则的话就需要进行一次合并，合并的原则和56题一样，就是将当前res尾部的区间的end修改成插入区间的end和res尾部的end中的较大的值；然后再对剩余的区间依次做合并操作，最终得到结果； 代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); if(n == 0) &#123; res.push_back(newInterval); return res; &#125; int i = 0; for( ; i &lt; n; i++)&#123; if(newInterval.start &lt;= intervals[i].start) break; res.push_back(intervals[i]); &#125; if(i == 0 || newInterval.start &gt; intervals[i - 1].end) res.push_back(newInterval); else&#123; res.back().end = max(newInterval.end, res.back().end); &#125; for(; i &lt; n; i++)&#123; if(res.back().end &lt; intervals[i].start) res.push_back(intervals[i]); else res.back().end = max(res.back().end, intervals[i].end); &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"难","slug":"难","permalink":"http://yoursite.com/tags/难/"}]},{"title":"【Leetcode】56. Merge Intervals","slug":"【Leetcode】56-Merge-Intervals","date":"2019-02-24T15:07:06.000Z","updated":"2019-02-25T08:20:23.493Z","comments":true,"path":"2019/02/24/【Leetcode】56-Merge-Intervals/","link":"","permalink":"http://yoursite.com/2019/02/24/【Leetcode】56-Merge-Intervals/","excerpt":"","text":"题目 合并区间给出一个区间的集合，请合并所有重叠的区间。 案例示例 1:123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路首先将当前的区间按照start从低到高排序，如果后面一个区间的start比前一个的end要大，那么两者是没有重复的，直接将第二个放到当前的结果中；否则就是存在重复的区间，那就将当前res中最后一个区间的end，换成当前的end和原本的end的最大值；这个题目类似的题目是56题 代码123456789101112131415161718192021222324252627282930/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; if(n == 0) return res; sort(intervals.begin(), intervals.end(), cmp); res.push_back(intervals[0]); for(int i = 1; i &lt; n; i++)&#123; if(intervals[i].start &gt; res.back().end) res.push_back(intervals[i]); else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125; static bool cmp(Interval a, Interval b)&#123; return a.start &lt; b.start; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]},{"title":"关于c++ push ,pop小命令的笔记小抄","slug":"关于c-push-pop小命令的笔记小抄","date":"2019-02-23T03:04:33.000Z","updated":"2019-02-23T12:08:52.293Z","comments":true,"path":"2019/02/23/关于c-push-pop小命令的笔记小抄/","link":"","permalink":"http://yoursite.com/2019/02/23/关于c-push-pop小命令的笔记小抄/","excerpt":"","text":"set 插入：insert; vector 插入：push_back; 删除：pop_back; queuemap 访问map的key 和 value 的时候，是m.second 或者 m.first","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++习惯总结","slug":"c-习惯总结","permalink":"http://yoursite.com/tags/c-习惯总结/"}]},{"title":"leetcode之间的关系捋一捋","slug":"leetcode之间的关系捋一捋","date":"2019-02-23T02:21:44.000Z","updated":"2019-02-23T03:14:14.238Z","comments":true,"path":"2019/02/23/leetcode之间的关系捋一捋/","link":"","permalink":"http://yoursite.com/2019/02/23/leetcode之间的关系捋一捋/","excerpt":"","text":"组合类型 Permutations47. 39.40。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"知识点梳理","slug":"知识点梳理","permalink":"http://yoursite.com/tags/知识点梳理/"}]},{"title":"【leetcode】36. Valid Sudoku","slug":"【leetcode】36-Valid-Sudoku","date":"2019-02-21T14:09:21.000Z","updated":"2019-02-21T14:42:26.506Z","comments":true,"path":"2019/02/21/【leetcode】36-Valid-Sudoku/","link":"","permalink":"http://yoursite.com/2019/02/21/【leetcode】36-Valid-Sudoku/","excerpt":"","text":"题目 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 案例示例 1: 输入:12345678910111213[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:123456789101112输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] 输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 思路设置三个标志矩阵，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下，如下代码； 代码12345678910111213141516171819202122232425class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int n = board.size(); vector&lt;vector&lt;bool&gt;&gt; iscol(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; isrow(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; ismini(n,vector&lt;bool&gt;(n,false)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9') &#123; int t = board[i][j] - '1'; if(iscol[t][j] || isrow[i][t] || ismini[3 * (i / 3) + j / 3][t]) return false; iscol[t][j] = true; isrow[i][t] = true; ismini[3 * (i / 3) + j / 3][t] = true; &#125; &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]}]}
{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"油腻高贵的唐怂怂","date":"2019-02-15T10:45:41.000Z","updated":"2019-02-16T13:24:04.094Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me12345&lt;profile&gt; &lt;name&gt; ynggdttt &lt;/name&gt; &lt;email&gt; tangliyuan@sjtu.edu.cn &lt;/email&gt; &lt;location&gt; Shanghai, China &lt;/location&gt;&lt;/profile&gt; Tags Related: Coding, IT, Capturing, Reading, Books, Movies, fans of Maobuyi, Traveling, Music…… FAQ: 为什么叫 ynggdttt ？简单的不能再简单的翻译–油腻高贵的糖糖糖，2018年5月份粉上了毛不易先生，仔细想想能拿到 一句话描述自己：一个对曾以为自己很特别，现在逐渐接受也甘于平凡的人。 If you want to know more, contact me via my private WeChat account: zanglingyangshashou or email."}],"posts":[{"title":"【Leetcode】82-Remove Duplicates from Sorted List II","slug":"【Leetcode】82-Remove-Duplicates-from-Sorted-List-II","date":"2021-02-13T13:43:59.000Z","updated":"2021-02-13T15:03:02.836Z","comments":true,"path":"2021/02/13/【Leetcode】82-Remove-Duplicates-from-Sorted-List-II/","link":"","permalink":"http://yoursite.com/2021/02/13/【Leetcode】82-Remove-Duplicates-from-Sorted-List-II/","excerpt":"","text":"题目 从有序链表中删除重复元素Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.. 案例! + [[内容]] + (【Leetcode】82-Remove Duplicates from Sorted List II/pic1.png) 思路1.避免头节点被删除2.pre表示当前的有效节点的尾巴3.cur为下一个要判断的节点4.cur要是没有重复的，那么就纳入进来5.cur要是又重复的，就跳过，即把pre-&gt;next换成下一个 代码1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* pre = dummy; while(pre-&gt;next)&#123; ListNode* cur = pre-&gt;next; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123; cur = cur-&gt;next; &#125; if(pre-&gt;next != cur) pre-&gt;next = cur-&gt;next; else pre = pre-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"【Leetcode】253-Move Zeroes","slug":"【Leetcode】253-Move-Zeroes","date":"2021-02-12T02:58:28.000Z","updated":"2021-02-12T03:04:03.385Z","comments":true,"path":"2021/02/12/【Leetcode】253-Move-Zeroes/","link":"","permalink":"http://yoursite.com/2021/02/12/【Leetcode】253-Move-Zeroes/","excerpt":"","text":"题目 移动0Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 案例示例 1:12Input: [0,1,0,3,12]Output: [1,3,12,0,0] 思路两个指针，一个遍历遇到0向前，一个当前非零的，不是0，不断交换。 代码123456789101112131415161718192021class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt;= 1) return; int index = 0; for(int i = 0; i &lt; n; i++)&#123; if(nums[i] != 0)&#123; if(i != index) //nums[index++] = nums[i];//需要再遍历一遍 swap(nums[index++],nums[i]); else index++; &#125; &#125; /*需要再遍历一遍for(int i = index; i &lt; n; i++)&#123; nums[i] = 0; &#125; return;*/ &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"【COMSOL APP开发】板块元模型","slug":"【COMSOL-APP开发】板块元模型","date":"2020-02-05T13:50:04.000Z","updated":"2020-02-06T14:51:30.492Z","comments":true,"path":"2020/02/05/【COMSOL-APP开发】板块元模型/","link":"","permalink":"http://yoursite.com/2020/02/05/【COMSOL-APP开发】板块元模型/","excerpt":"","text":"准备工作COMSOL软件，板块元程序，一台windows笔记本，一个网格模型 知识点1:如何实现在APP中导入任意网格模型并展示 目的：通过界面导入一个几何网格模型，并且能显示出来。步骤一：在后台准备工作。 新建三维模型,添加研究； 网格处，添加导入1； 点击APP开发器；点击数据访问；勾选导入1处；说明数据访问是为了保证我们想操作的组件能够顺利的移植到APP开发器处，此处具体是为了将当前的导入功能拿到前面去；步骤二：在APP开发器处开发。 新建表单，插入对象，文件导入； 双击组建，给组件加入源，从右侧模型树上找到导入1作为源； 插入按钮，图形，图形关联几何；功能是，点击按钮能够绘图展示在几何上； 按钮先后在模型树上关联，构建网格，几何，绘制几何；说明a. 通过这种方式赋予按钮功能，一般如果一个按钮想实现什么功能，就将之前在后台会手动点的按钮关联过来，一个按钮可以关联多个操作；这里我们想绘制网格、几何，因此做这几种关联。此外，按钮还能关联方法。b. 对于图形的源有两种情况，一种是我们这里使用的直接手动链接在后台，另一种是通过方法的方式，后面会提。 点击运行App，可以对当前的功能进行测试；目前已经有的功能是，导入一个网格文件，点击按钮，会将这个几何绘制出来。具体方法是，点击浏览，然后选择网格文件，然后点击按钮，就实现将模型展示出来的功能了。 知识点2:怎么在界面中添加输入参数 新建参数表单命名para，包含计算方位和频点；插入输入框和文本标签（分别作为变量提示和单位说明）；说明一般情况，推荐将一组功能的参数或者图形等放在一个表单中，这样后续回顾的时候比较清楚。后续可以用在某个表单中插入子表单的方式进行整合排版。 在声明处新建字符串，并将各个参数声明；说明每个输入框必须关联一个变量，可以是后台参数也可以是APP中声明的变量； 将输入框和声明的变量关联起来； para表单加入到主菜单中；在主表单中插入表单，并下拉选择para;说明可以勾选边框，这样比较好看，而且左上角会有个提示； 知识点3:怎么设置文件夹因为本案例中涉及到文件的存储、调用等，所以需要对文件存储位置做一个提前的声明。一般用字符串的方式； 在声明中，声明一下当前的文件夹和matlab程序存储的文件夹;必须是绝对路径，文件夹必须以\\结尾。 知识点4:方法使用–分割网格 方法是逻辑的实现，所以要清楚自己想干嘛，比如这里，我现在的网格文件中node face是混杂的，我等一下要用的是分开的，所以这个逻辑很简单，就是需要分开node face; 具体操作在方法中实现，新建方法，命名，然后拷写代码；说明代码的逻辑就是把文件当成字符串读进来，然后分割，具体的需要熟能生巧； 新增按钮，关联方法，可以把按钮改个名字，比如叫处理网格； 知识点5:调用matlab 通过调用操作系统命令调用Matlab程序，已经将该过程打包成函数，每次需要时，只需要传入函数名funcname、函数绝对路径funcpath、函数参数args即可； 首先准备matlab程序；将传入参数设置为包theta,phi,freq；（是我们要从app传入的）。 新建方法，推荐命名为UseMatlabTS，作用是进行matlab计算并新增按钮，关联此方法。说明如果你的matlab中的计算结果需要回传到APP中调用，那么请在matlab程序中将结果保存至硬盘中某个位置。一般我们是用来将matlab中的计算结果在app中绘图展示的，存成txt文件即可。知识点6:调用matlab计算好的结果绘制曲线 后台操作步骤为，在结果处新建表格，导入数据、新建一维或二维绘图，进行绘图； 针对绘制一维和二维图的情况，我已经写好打包函数，只需要修改参数，直接调用即可。 为了在app上能够展示出来，需要插入图形，且关键的点在于将源选对，通过usegraphic这个函数可以实现在方法中赋予图形的源。 新插入图形，用来展示TS曲线； 新建方法plotTS,调用PlotOne函数即可。","categories":[{"name":"COMSOLAPP","slug":"COMSOLAPP","permalink":"http://yoursite.com/categories/COMSOLAPP/"}],"tags":[{"name":"COMSOL 调用matlab","slug":"COMSOL-调用matlab","permalink":"http://yoursite.com/tags/COMSOL-调用matlab/"},{"name":"绘图","slug":"绘图","permalink":"http://yoursite.com/tags/绘图/"}]},{"title":"【秋招总结】","slug":"【秋招总结】","date":"2019-11-29T09:53:34.000Z","updated":"2020-02-06T15:29:14.247Z","comments":true,"path":"2019/11/29/【秋招总结】/","link":"","permalink":"http://yoursite.com/2019/11/29/【秋招总结】/","excerpt":"","text":"","categories":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/categories/总结/"}],"tags":[{"name":"秋招总结","slug":"秋招总结","permalink":"http://yoursite.com/tags/秋招总结/"}]},{"title":"【C++】知识点","slug":"【C-】知识点","date":"2019-10-24T13:42:33.000Z","updated":"2019-10-25T00:47:27.683Z","comments":true,"path":"2019/10/24/【C-】知识点/","link":"","permalink":"http://yoursite.com/2019/10/24/【C-】知识点/","excerpt":"","text":"union struct 区别","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"做题总结知识点","slug":"做题总结知识点","permalink":"http://yoursite.com/tags/做题总结知识点/"}]},{"title":"微软产品分析","slug":"微软产品分析","date":"2019-10-21T10:37:54.000Z","updated":"2019-10-22T14:35:22.771Z","comments":true,"path":"2019/10/21/微软产品分析/","link":"","permalink":"http://yoursite.com/2019/10/21/微软产品分析/","excerpt":"","text":"Office 365Office 365 是一种订阅式的跨平台办公软件，基于云平台提供多种服务，通过将 Excel 和 Outlook 等应用与 OneDrive 和 Microsoft Teams 等强大的云服务相结合，Office 365 可让任何人使用任何设备随时随地创建和共享内容。 第一是编辑与创作类，Word、PowerPoint、Excel 等用来编辑、写东西的。第二是邮件、社交类，Outlook、Exchange、Yammer、Teams、Office 365 微助理。第三是站点及网络内容管理类，以 SharePoint、OneDrive 产品为主，做到同步编辑、共享文件、达成协作。第四是会话、语音类，比如 Skype for Business。第五是报告和分析类，Power BI、MyAnalytics 这些产品。第六是业务规划和管理类， Microsoft Bookings、StaffHub，还有 Project Online、Visio Online ，是项目管理、绘图等方面的。 [3] OneDriveOneDrive是微软也就是Windows的云存储服务。使用 OneDrive，可将图片、文件和文件夹安全存储在一个位置，与其他人共享，并从任意位置访问它们。登录 office.com，然后选择“OneDrive”可以：1、查看存储在 OneDrive 中文件和照片。2、创建家人朋友的相册。3、在计算机上创建文档，并在笔记本计算机、手机或平板电脑上进行编辑。4、与其他人共享文件和照片。5、可与朋友同时协作处理 Office 文档。 Microsoft TeamsMicrosoft Teams 是一款基于聊天的智能团队协作工具，可以同步进行文档共享，并为成员提供包括语音、视频会议在内的即时通讯工具。 skype for businessSkype for Business Online 是一款通信服务，支持随时随地与参加会议和通话的人员联系。它支持用户访问出席信息，并支持即时消息、音频和视频呼叫、丰富的在线会议和一系列 Web 会议功能。 主要是为企业实现不同地点不同时间能与客户沟通问题，实现协同办公。 CRM即客户关系管理，是指企业用CRM技术来管理与客户之间的关系。在不同场合下，CRM可能是一个管理学术语，可能是一个软件系统。通常所指的CRM，指用计算机自动化分析销售、市场营销、客户服务以及应用等流程的软件系统。(Customer Relationship Management). 客户信息获取 客户细分 资源分配 客户关系发展 增强对客户的关怀 客户保持好处： 1、传递优秀经验，规范企业流程。 2、提升销售，项目管理能力和结案率。 3、减少培训工作。 4、防止出错。 5、积累客户经验于企业自身。 6、产生更多的生意机会。 ERP https://zhuanlan.zhihu.com/p/68131679?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=987612760565497856 ERP和CRM的区别CRM&amp;ERP编辑CRM与ERP之间的区别和联系，是从不同角度进行理解，总体来说，二者之间是相互依存、区别的关系。CRMCRM从管理理念上，ERP的管理理念是提高企业内部资源的计划和控制能力，讲究的是在满足客户、及时交货的同时最大限度地降低各种成本，通过提高内部运转效率来提高对客户的服务质量， 可以说是以效率为中心。CRM的理念是以客户关系的建立、发展和维持为主目的。它们的理念在关注对象上有区别，与企业级的内部资源计划ERP相比，CRM的更关注市场与客户。因为今天的客户既可以通过传统市场所提供的销售形式接触各类产品和服务，也可以方便地透过呼叫中心或互联网找到自己感兴趣的产品和服务。他们的消费方式由被动接受变为主动选择。所以CRM的作用主要在与客户直接接触的部门，它主要针对的是企业的市场营销、销售、服务部门，包括管理整个客户生命周期等各个阶段，为企业提供了对客户及所购产品的统计、跟踪和服务等信息化手段和功能。也就是说，如果说ERP是企业级的全面管理应用的话，CRM就是ERP的最前端，它的作用延伸到了ERP以前力所不能及的范围之外。1.客户关系管理系统是ERP的延伸客户关系管理软件侧重于管理企业的客户，同时企业的客户也是企业最重要的资源，ERP作为企业资源管理软件把客户做比较全面的管理，这点在ERP的分销系统和应收账模块等中都有一些体现。所以夸张一点说，客户关系管理系统可作为ERP系统中的一个子系统，当然正确的说法应该是客户关系管理系统的核心部分，是ERP系统中销售管理的延伸，是对ERP的补充与增强。因为客户关系管理系统不仅对现有客户资源进行管理，也对潜在客户资源进行管理，客户关系管理系统原本不在ERP之内的呼叫中心、B2B. B2C、一对一营销等。既然是延伸，自然ERP就是客户关系管理系统的基础，是培养客户关系管理的土壤，所以ERP与客户关系管理系统是有些交叉的，这也是我们经常会提到ERP与客户关系管理系统整合的叫—个原因。2.关注对象不同如果从系统的角度讲，二者是不同的系统，而且关注的企业问题不同，客户关系管理系统更偏重于外向型的问题，比如营销、服务等与市场和客户相关的外部资源，强调合理利用优质服务来开拓和保持客户，优化面对客户的流程以减少获取和保留客户的成本。而ERP则是偏重于内部的问题，关注点是企业资源，比如生产、 库存、质量、成本等，它的方式主要是优化内部管理流程和其他内部资源。3.管理理念不同ERP的管理理念是提高企业内部资源的计划和控制能力，讲究的是在满足客户、及时最大限度地降低各种成本，通过提高内部运转效率来提高对客户的服务质量，可以说是以效率为中心。客户关系管理系统的理念是以客户关系的建立、发展和维持为主要目的，更关注市场与客户。ERP更注重企业内部的管理，它的目标是规范管理，而客户关系管理系统的目标是为客户提供更加全面的服务，如果说ERP是企业级的全面管理应用的话，客户关系管理系统就是ERP的最前端，它的作用延伸到了以前ERP力所不能及的范围。4.应用系统的设计不同大部分客户关系管理系统的业务流程相对比较灵活，ERP的主要业务流程则相对固定，ERP系统是一个“事务处理”系统，强调准确记录企业中人、财、物各项资源的轨迹，无缝地集成企业生产、库存、仓库、财务等管理模块，提高企业的“自动化”能力从而极大地降低人力需求及差错，提高效率。而优客易客户关系管理系统的体系设计以客户关系发展和维系为目标，系统以统一的客户数据库为中心，为系统用户提供客户的统一视图和对客户的分析、预测等工具，同时强调和其他企业应用的集成。与ERP系统相比，CRM产品更专注于销售、营销、客户服务和支持等方面的管理，实际上，CRM的价值在于突出销售管理、营销管理、客户服务与支持方面的重要性，CRM系统本身可以看成广义的ERP的一部分，二者应该可以形成无缝的闭环系统。 [4]","categories":[],"tags":[{"name":"微软产品分析","slug":"微软产品分析","permalink":"http://yoursite.com/tags/微软产品分析/"}]},{"title":"【Java】异常","slug":"【Java】异常","date":"2019-09-19T02:23:30.000Z","updated":"2019-09-19T03:06:58.774Z","comments":true,"path":"2019/09/19/【Java】异常/","link":"","permalink":"http://yoursite.com/2019/09/19/【Java】异常/","excerpt":"","text":"Java异常分类Throwable:所有错误的祖先Error类和Exception类的父类都是Throwable类；a. Error:系统内部错误或者资源耗尽。Error类一般是指与虚拟机相关的问题，如系统奔溃，虚拟机错误，内存空间不足，方法调用栈溢出等。错误导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议程序终止。b. Exception程序错误 RuntimeException: Unchecked Exception程序必须处理，以预防为主。编译器不关心此类异常，也不会辅助检查。主要有https://blog.csdn.net/u014753629/article/details/79954262 java.lang.NullPointerException空指针异常，调用未初始化的或者是 不存在的对象； ClassNoFoundException 指定类找不到，出现原因：类的名称和路径加载错误，通常是试图通过字符串来加载某个类时可能引发异常。 IndexOutOfBoundsException数组下标越界异常 NoSuchMethodExceptioin 方法不存在异常 SQLException SQL异常异常处理 try-catch-finallytry必须有，catch和finally至少要有一个• try: 正常业务逻辑代码。• catch: 当try发生异常，将执行catch代码。若无异常，绕之。• finally: 当try或catch执行结束后，必须要执行finally。catch块可以有多个，每个有不同的入口形参。当已发生的异常和某一个catch块中的形参类型一致，那么将执行该catch块中的代码。如果没有一个匹配，catch也不会被触发。最后都进入finally块。 方法存在可能异常的语句，但不处理，那么可以使用throws来声明异常。调用带有throws异常（checked exception）的方法，要么处理这些异常，或者再次向外throws，直到main函数为止。注意 一个方法被覆盖，覆盖它的方法必须抛出相同的异常，或者异常的子类。 如果父类的方法抛出多个异常，那么重写的子类方法必须抛出那些异常的子集，也就是不能抛出新的异常。 自定义异常 需要继承Exception类或其子类。 继承自Exception，就变成Checked Exception –继承自RuntimeException, 就变成Unchecked Exception； 自定义重点在构造函数 –调用父类Exception的message构造函数 –可以自定义自己的成员变量 在程序中采用throw主动抛出异常","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"异常处理","slug":"异常处理","permalink":"http://yoursite.com/tags/异常处理/"}]},{"title":"【覆盖率】","slug":"【覆盖率】","date":"2019-09-17T02:12:56.000Z","updated":"2019-09-17T02:24:38.193Z","comments":true,"path":"2019/09/17/【覆盖率】/","link":"","permalink":"http://yoursite.com/2019/09/17/【覆盖率】/","excerpt":"","text":"https://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html 行覆盖率 分支覆盖/判定覆盖，只需要判断分支条件就可以 条件覆盖，每个条件表达式满足即可； 路径覆盖","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"},{"name":"覆盖率","slug":"覆盖率","permalink":"http://yoursite.com/tags/覆盖率/"}]},{"title":"【Java-Arraylist,Vector,LinkedList】","slug":"【Java-Arraylist-Vector-LinkedList】","date":"2019-09-16T14:28:07.000Z","updated":"2019-09-18T02:02:04.607Z","comments":true,"path":"2019/09/16/【Java-Arraylist-Vector-LinkedList】/","link":"","permalink":"http://yoursite.com/2019/09/16/【Java-Arraylist-Vector-LinkedList】/","excerpt":"","text":"https://blog.csdn.net/virtiL33/article/details/89378232","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"【Java-HashMap&HashTable】","slug":"【Java-HashMap-HashTable】","date":"2019-09-16T13:55:36.000Z","updated":"2019-09-16T14:19:22.659Z","comments":true,"path":"2019/09/16/【Java-HashMap-HashTable】/","link":"","permalink":"http://yoursite.com/2019/09/16/【Java-HashMap-HashTable】/","excerpt":"","text":"HashMap HashTable的区别https://www.zhihu.com/question/20581065/answer/334969310?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=987612760565497856&amp;hb_wx_block=1 继承的父类不同HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口； 对外提供的接口不同Hashtable比HashMap多提供了elments() 和contains() 两个方法。 对Null key 和Null value的支持不同Hashtable既不支持Null key也不支持Null value。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 线程安全性不同Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。具体的原因在下一篇文章中会详细进行分析。使用HashMap时就必须要自己增加同步处理，ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。 遍历方式的内部实现上不同Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 初始容量大小和每次扩充容量大小的不同Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。 Hashtable和HashMap的计算hash值的方法不同Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置.为了解决这个问题，HashMap重新根据hashcode计算hash值后，又对hash值做了一些运算来打散数据。使得取得的位置更加分散，从而减少了hash冲突。当然了，为了高效，HashMap只做了一些简单的位处理。从而不至于把使用2 的幂次方带来的效率提升给抵消掉。 ConcurrentHashMap HashTable的区别https://www.cnblogs.com/zx-bob-123/archive/2017/12/26/8118074.htmlConcurrentHashMap是线程安全的HashMap的实现。HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Map","slug":"Map","permalink":"http://yoursite.com/tags/Map/"}]},{"title":"【Java】知识点","slug":"【Java】知识点","date":"2019-09-16T11:22:46.000Z","updated":"2019-09-18T02:02:07.682Z","comments":true,"path":"2019/09/16/【Java】知识点/","link":"","permalink":"http://yoursite.com/2019/09/16/【Java】知识点/","excerpt":"","text":"string 类不能被继承，因为是final修饰的； final 知识点final 修饰类，不能被继承a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。b. final类中的成员方法都会被隐式的指定为final方法。final修饰的方法，不能被重写a. 一个类的private方法会隐式的被指定为final方法。b. 如果父类中有final修饰的方法，那么子类不能去重写。final修饰成员变量a. 需要直接初始化，不能再次赋值。b. 如果是对象实例（引用类型的），那么不能修改其指针(但是可以修改对象内部的值; static 知识点修饰变量静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本【存放在方法区，又名静态区】.它当且仅当在类初次加载时会被初始化【加final和不加final的static变量初始化的位置不一样】.而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。修饰方法不依赖对象修饰代码块static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次【根据class加载原理 每个类加载一次 使用双亲委托加载】。初始化的顺序 静态代码块 &gt; 构造代码块 &gt; 构造函数 修饰内部类 java内存存疑https://www.cnblogs.com/dolphin0520/p/3613043.html 内部类","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面试知识点","slug":"面试知识点","permalink":"http://yoursite.com/tags/面试知识点/"}]},{"title":"【Java】代码块","slug":"【Java】代码块","date":"2019-09-09T13:57:41.000Z","updated":"2019-09-09T13:58:24.259Z","comments":true,"path":"2019/09/09/【Java】代码块/","link":"","permalink":"http://yoursite.com/2019/09/09/【Java】代码块/","excerpt":"","text":"https://www.cnblogs.com/Heliner/p/10524699.html","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"代码块","slug":"代码块","permalink":"http://yoursite.com/tags/代码块/"}]},{"title":"【Java】volidate","slug":"【Java】volidate","date":"2019-09-09T13:56:52.000Z","updated":"2019-09-16T11:29:01.509Z","comments":true,"path":"2019/09/09/【Java】volidate/","link":"","permalink":"http://yoursite.com/2019/09/09/【Java】volidate/","excerpt":"","text":"https://www.cnblogs.com/blog-Aevin/p/9302678.html","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"volidate","slug":"volidate","permalink":"http://yoursite.com/tags/volidate/"}]},{"title":"【Java】单例","slug":"【Java】单例","date":"2019-09-09T13:39:54.000Z","updated":"2019-09-16T13:12:02.821Z","comments":true,"path":"2019/09/09/【Java】单例/","link":"","permalink":"http://yoursite.com/2019/09/09/【Java】单例/","excerpt":"","text":"https://www.cnblogs.com/ngy0217/p/9006716.html 单例模式的五种实现方式 饿汉模式，线程安全，调用效率高，但是不能延时加载 先初始化","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"单例","slug":"单例","permalink":"http://yoursite.com/tags/单例/"}]},{"title":"【数据库】删除表","slug":"【数据库】删除表","date":"2019-09-09T11:19:12.000Z","updated":"2019-09-09T11:29:34.990Z","comments":true,"path":"2019/09/09/【数据库】删除表/","link":"","permalink":"http://yoursite.com/2019/09/09/【数据库】删除表/","excerpt":"","text":"一、SQL中的语法 drop table 表名称 eg: drop table dbo.Sys_Test truncate table 表名称 eg: truncate table dbo.Sys_Test 3. delete from 表名称 where 列名称 = 值 eg: delete from dbo.Sys_Test where test=’test’ 二、drop，truncate，delete区别 drop (删除表)：删除内容和定义，释放空间。简单来说就是把整个表去掉.以后要新增数据是不可能的,除非新增一个表。 drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。 truncate (清空表中的数据)：删除内容、释放空间但不删除定义(保留表的数据结构)。与drop不同的是,只是清空表数据而已。注意:truncate 不能删除行数据,要删就要把表清空。 delete (删除表中的数据)：delete 语句用于删除表中的行。delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。 truncate与不带where的delete ：只删除数据，而不删除表的结构（定义） truncate table 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用delete。如果要删除表定义及其数据，请使用 drop table 语句。 对于由foreign key约束引用的表，不能使用truncate table ，而应使用不带where子句的delete语句。由于truncate table 记录在日志中，所以它不能激活触发器。 执行速度，一般来说: drop&gt; truncate &gt; delete。 delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。 truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"删除表","slug":"删除表","permalink":"http://yoursite.com/tags/删除表/"}]},{"title":"【c++】单例模式","slug":"【c-】单例模式","date":"2019-08-21T08:30:07.000Z","updated":"2019-08-21T12:31:01.776Z","comments":true,"path":"2019/08/21/【c-】单例模式/","link":"","permalink":"http://yoursite.com/2019/08/21/【c-】单例模式/","excerpt":"","text":"饿汉模式12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;class singleton&#123;protected: singleton()&#123;&#125;;private: singleton(const singleton&amp;)&#123;&#125;;//禁止拷贝 singleton&amp; operator=(const singleton&amp;)&#123;&#125;;//禁止赋值 static T* m_instance;//静态public: static T* GetInstance();//要是静态的，不然不能用&#125;;template &lt;class T&gt;T* singleton&lt;T&gt;::GetInstance()&#123; return m_instance;&#125;template &lt;class T&gt;T* singleton&lt;T&gt;::m_instance = new T();int main()&#123; char *a = singleton&lt;char&gt;::GetInstance(); cout&lt;&lt;*a&lt;&lt;endl; return 0;&#125; 先不初始化，等get的时候再初始化，加锁 懒汉模式123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;class singleton&#123;protected: singleton()&#123;&#125;;private: singleton(const singleton&amp;)&#123;&#125;; singleton&amp; operator=(const singleton&amp;)&#123;&#125;; static T* m_instance; static pthread_mutex_t mutex;public: static T* GetInstance(T a);&#125;;template &lt;class T&gt;T* singleton&lt;T&gt;::GetInstance(T a)&#123; if( m_instance == NULL) &#123; pthread_mutex_lock(&amp;mutex); if( m_instance == NULL) &#123; m_instance = new T(a); &#125; pthread_mutex_unlock(&amp;mutex); &#125; return m_instance;&#125;template &lt;class T&gt;pthread_mutex_t singleton&lt;T&gt;::mutex = PTHREAD_MUTEX_INITIALIZER;template &lt;class T&gt;T* singleton&lt;T&gt;::m_instance = NULL;int main()&#123; char *a = singleton&lt;char&gt;::GetInstance('a'); char *b = singleton&lt;char&gt;::GetInstance('b'); cout&lt;&lt;*a&lt;&lt;endl; cout&lt;&lt;*b&lt;&lt;endl; return 0;&#125;","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"单例模式","slug":"单例模式","permalink":"http://yoursite.com/tags/单例模式/"}]},{"title":"【c++】assert","slug":"【c-】assert","date":"2019-08-21T06:49:36.000Z","updated":"2019-08-21T06:52:48.266Z","comments":true,"path":"2019/08/21/【c-】assert/","link":"","permalink":"http://yoursite.com/2019/08/21/【c-】assert/","excerpt":"","text":"一、为什么要用断言https://blog.csdn.net/taifei/article/details/53975323首先要搞清楚为什么要用断言，不能看别人代码中有，就追赶时髦地用一用！从效果上来说assert断言能用if语句替换，那么为什么不用if语句把断言替换呢？一般而言，if语句是处理逻辑上的可能会发生的错误，断言则用来处理不应该发生的状况。 什么是不应该发的的状况呢？这要区分数据的来源：１、数据来源于系统内部（子程序、子模块间的调用）２、数据来源于系统外部（外部设备如键盘的输入、串口数据的读取、网络数据的读取）。对内部来源的数据，我们没法去通过常规的测试手段去验证，此时断言就用上了。 当然你如果硬是要用if语句也没人说你不对，但大量的if语句出现在源码中时，会造成代码臃肿，降低了可读性，另外会产生不紧凑代码，影响效率。 程序开发初期，码农们忽视的是程序间调用参数的合法性，对这些参数可使用断言来防止意外，随着程序进入release版时，可以定义NDEBUG来让断言失效。以下是NDEGBU对assert的处理代码。 二、 例子12345678910111213141516171819202122232425262728// crt_assert.c// compile with: /c#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt; void analyze_string( char *string ); // Prototype int main( void )&#123; char test1[] = \"abc\", *test2 = NULL, test3[] = \"\"; printf ( \"Analyzing string '%s'\\n\", test1 ); fflush( stdout ); analyze_string( test1 ); printf ( \"Analyzing string '%s'\\n\", test2 ); fflush( stdout ); analyze_string( test2 ); printf ( \"Analyzing string '%s'\\n\", test3 ); fflush( stdout ); analyze_string( test3 );&#125; // Tests a string to see if it is NULL, // empty, or longer than 0 characters.void analyze_string( char * string )&#123; assert( string != NULL ); // Cannot be NULL assert( *string != '\\0' ); // Cannot be empty assert( strlen( string ) &gt; 2 ); // Length must exceed 2&#125;","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"assert","slug":"assert","permalink":"http://yoursite.com/tags/assert/"}]},{"title":"【智力题】","slug":"【智力题】","date":"2019-08-21T02:43:11.000Z","updated":"2019-08-21T02:44:54.565Z","comments":true,"path":"2019/08/21/【智力题】/","link":"","permalink":"http://yoursite.com/2019/08/21/【智力题】/","excerpt":"","text":"两个不均匀的香，烧完都需要1小时，测出精确的15分钟https://blog.csdn.net/Tzhennan/article/details/84921051","categories":[{"name":"智力题","slug":"智力题","permalink":"http://yoursite.com/categories/智力题/"}],"tags":[{"name":"智力题","slug":"智力题","permalink":"http://yoursite.com/tags/智力题/"}]},{"title":"【数据库语句】--嵌套查询","slug":"【数据库语句】-嵌套查询","date":"2019-08-17T12:47:10.000Z","updated":"2019-08-17T14:04:20.222Z","comments":true,"path":"2019/08/17/【数据库语句】-嵌套查询/","link":"","permalink":"http://yoursite.com/2019/08/17/【数据库语句】-嵌套查询/","excerpt":"","text":"一个SELECT-FROM-WHERE语句称为一个查询块将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询子查询的限制！！！不能使用ORDER BY子句 连接子查询 带有IN谓词的子查询 带有比较运算符的子查询 带有ANY（SOME）或ALL谓词的子查询 带有EXISTS谓词的子查询不相关子查询子查询的查询条件不依赖于父查询 例子：查询与“刘晨”在同一个系学习的学生SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept IN( SELECT Sdept FROM Student WHERE Sname=’刘晨’)也可以用自身连接SELECT Sno, Sname, SdeptFROM Student FIRST, Student SECONDWHERE FIRST.Sdept = SECOND.Sdept ANDSECOND.Sname=’刘晨’ 查询选修了课程名为“信息系统”的学生学号和姓名 用连接SELECT Student.Sno, Student.SnameFROM Student, Course, ScWHERE Student.Sno = Sc.SnoAND Course.Cno = Sc.CnoAND Course.Cname = ‘信息系统’ 用嵌套SELECT Student.Sno, Student.SnameFROM StudentWHERE Student.Sno IN( SELECT Sc.Sno FROM Sc WHERE Sc.Cno IN(SELECT Course.Cno FROM Course WHERE Course.Cname=&apos;信息系统&apos; )) 相关子查询带有比较字符的 找出每个学生超过他选修课程平均成绩的课程号SELECT x.CnoFROM Sc xWHERE x.Grade &gt; ( SELECT AVG(y.Grade) FROM Sc y WHERE y.Sno=x.Sno) 带有ANY（SOME）或ALL谓词的子查询查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄SELECT Sname, SageFROM Student xWHERE x.Sdept &lt;&gt; ‘CS’ AND x.age &lt; ANY( SELECT Sage FROM Student y WHERE y.Sdept=’CS’) 用聚集函数实现SELECT Sname, SageFROM StudentWHERE x.Sdept &lt;&gt; ‘CS’ AND x.age &lt; ( SELECT MAX(Sage) FROM Student WHERE Sdept=’CS’)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"常考语句","slug":"常考语句","permalink":"http://yoursite.com/tags/常考语句/"},{"name":"嵌套查询","slug":"嵌套查询","permalink":"http://yoursite.com/tags/嵌套查询/"}]},{"title":"【数据库语句】--链接","slug":"【数据库语句】-链接","date":"2019-08-17T11:38:45.000Z","updated":"2019-08-17T12:46:46.730Z","comments":true,"path":"2019/08/17/【数据库语句】-链接/","link":"","permalink":"http://yoursite.com/2019/08/17/【数据库语句】-链接/","excerpt":"","text":"等值连接查询选修2号课程且成绩在90分以上的所有学生的学号和姓名。SELECT Sno, SnameFROM STUDENT,SCWHERE STUDENT.Sno = Sc.SnoAND Scourse = ‘2’ AND Grade &gt; 90 自身连接 一个表与其自己进行连接，是一种特殊的连接 需要给表起别名以示区别 由于所有属性名都是同名属性，因此必须使用别名前缀例子 查询每一门课的直接先修课的名称SELECT FIRST.Cname, SECOND.CnameFROM Course FIRST, Course SECONDWHERE FRIST.Cpno = SECOND.Cno外连接 inner join, left join, right joinSELECT column_name(s)FROM table_name1LEFT JOIN table_name2ON table_name1.column_name=table_name2.column_name 多表连接查询每个学生的学号、姓名、选修的课程名及成绩SELECT Student.Sno, Student.Sname, Course.Cname, Sc.GradeFROM Student, Sc, CourseWHERE Studet.Sno = Sc.Sno AND Course.Cno = Sc.Cno","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"常考语句","slug":"常考语句","permalink":"http://yoursite.com/tags/常考语句/"},{"name":"连接两个表","slug":"连接两个表","permalink":"http://yoursite.com/tags/连接两个表/"}]},{"title":"【模版】","slug":"【模版】","date":"2019-08-15T08:51:23.000Z","updated":"2019-08-16T02:30:57.913Z","comments":true,"path":"2019/08/15/【模版】/","link":"","permalink":"http://yoursite.com/2019/08/15/【模版】/","excerpt":"","text":"函数模版template 返回值类型 模板名 (形参表){函数体};12345678910111213141516#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template &lt;class T&gt;void Swap(T &amp;x,T &amp;y)&#123; T tem = x; x = y; y = tem;&#125;int main()&#123; int x = 1, y = 2; Swap(x, y); cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;endl; return 0;&#125;","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/tags/Cplusplus/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"模版","slug":"模版","permalink":"http://yoursite.com/tags/模版/"}]},{"title":"【输入输出】","slug":"【输入输出】","date":"2019-08-15T07:45:46.000Z","updated":"2019-08-15T08:51:01.973Z","comments":true,"path":"2019/08/15/【输入输出】/","link":"","permalink":"http://yoursite.com/2019/08/15/【输入输出】/","excerpt":"","text":"类的关系 istream是用于输入的流类，cin就是该类的对象。ostream是用于输出的流类，cout就是该类的对象。ifstream是用于从文件读取数据的类。ofstream是用于向文件写入数据的类。iostream是既能用于输入，又能用于输出的类。fstream 是既能从文件读取数据，又能向文件写入数据的类。 重定向 写freopen(“name”,”w”,stdout); 12345678910#include&lt;iostream&gt;using namespace std;int main()&#123; int x,y; cout&lt;&lt;\"fa\"&lt;&lt;endl; cin&gt;&gt;x&gt;&gt;y; freopen(\"/Users/liyuantang/Desktop/c.txt\",\"w\",stdout); cout&lt;&lt;x/y&lt;&lt;endl; return 0;&#125; 读freopen(“name”,”r”,stdin); 读的时候判断输入结束while(cin&gt;&gt;x){ } istream 中的成员函数getline cin.getline 和getline的区别https://blog.csdn.net/weixin_41042404/article/details/80934191 getline的使用char a[10];istream &amp; getline(char buf, int bufSize);cin.getline(a,1);istream &amp; getline(char buf, int bufSize,char delim);cin.getline(a,1,” “); 可以用 if(!cin.getline(…)) 判断输入是否结束 bool eof(); 判断输入流是否结束 int peek(); 返回下一个字符,但不从流中去掉. istream &amp; putback(char c); 将字符ch放回输入流 istream &amp; ignore( int nCount = 1, int delim = EOF );从流中删掉最多nCount个字符，遇到EOF时结束。 流操纵算子使用流操纵算子需要 #include 整数流的基数：流操纵算子dec,oct,hexint n = 10;cout &lt;&lt; n &lt;&lt; endl;cout &lt;&lt; hex &lt;&lt; n &lt;&lt; “\\n”&lt;&lt; dec &lt;&lt; n &lt;&lt; “\\n”&lt;&lt; oct &lt;&lt; n &lt;&lt; endl; 控制浮点数精度的流操纵算子precision（成员函数）, setprecision precision是成员函数，其调用方式为：cout.precision(5); setprecision 是流操作算子，其调用方式为：cout &lt;&lt; setprecision(5); // 可以连续输出指定输出浮点数的有效位数（非定点方式输出时）（小数点不一定在个位数的右边）指定输出浮点数的小数点后的有效位数（定点方式输出时）（小数点在个位右边） 1234567891011#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;double x = 1234567.89,y = 12.34567;int n = 1234567;int m = 12;cout &lt;&lt; setprecision(6) &lt;&lt; x &lt;&lt; endl&lt;&lt; y &lt;&lt; endl &lt;&lt; n &lt;&lt; endl &lt;&lt; m;&#125; 12345678910111213#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;double x = 1234567.89,y = 12.34567;int n = 1234567;int m = 12;cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt;setprecision(6) &lt;&lt; x &lt;&lt; endl//控制输出的小数点位数&lt;&lt; y &lt;&lt; endl &lt;&lt; n &lt;&lt; endl &lt;&lt; m;cout&lt;&lt;resetiosflags(ios::fixed) &lt;&lt; x ;//取消&#125; 设置域宽的流操纵算子cin &gt;&gt; setw(4); 或者 cin.width(5);cout &lt;&lt; setw(4); 或者 cout.width(5);例子#include #include using namespace std;int main() {int n = 141;//1) 分别以十六进制、十进制、八进制先后输出 ncout &lt;&lt; “1) “ &lt;&lt; hex &lt;&lt; n &lt;&lt; “ “ &lt;&lt; dec &lt;&lt; n &lt;&lt; “ “ &lt;&lt; oct &lt;&lt; n &lt;&lt; endl;double x = 1234567.89,y = 12.34567;//2) 保留5位有效数字cout &lt;&lt; “2) “ &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; “ “ &lt;&lt; y &lt;&lt; “ “ &lt;&lt; endl;//3) 保留小数点后面5位cout &lt;&lt; “3) “ &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; “ “ &lt;&lt; y &lt;&lt; endl ;//4) 科学计数法输出，且保留小数点后面5位cout &lt;&lt; “4) “ &lt;&lt; scientific &lt;&lt; setprecision(5) &lt;&lt;x &lt;&lt; “ “ &lt;&lt; y &lt;&lt; endl ;//5) 非负数要显示正号，输出宽度为12字符，宽度不足则用’‘填补cout &lt;&lt; “5) “ &lt;&lt; showpos &lt;&lt; fixed &lt;&lt; setw(12) &lt;&lt; setfill(‘‘) &lt;&lt; 12.1&lt;&lt; endl;//6) 非负数不显示正号，输出宽度为12字符，宽度不足则右边用填充字符填充cout &lt;&lt; “6) “ &lt;&lt; noshowpos &lt;&lt; setw(12) &lt;&lt; left &lt;&lt; 12.1 &lt;&lt; endl;//7) 输出宽度为12字符，宽度不足则左边用填充字符填充cout &lt;&lt; “7) “ &lt;&lt; setw(12) &lt;&lt; right &lt;&lt; 12.1 &lt;&lt; endl;//8) 宽度不足时，负号和数值分列左右，中间用填充字符填充cout &lt;&lt; “8) “ &lt;&lt; setw(12) &lt;&lt; internal &lt;&lt; -12.1 &lt;&lt; endl;cout &lt;&lt; “9) “ &lt;&lt; 12.1 &lt;&lt; endl;return 0;}","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/tags/Cplusplus/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"输入输出","slug":"输入输出","permalink":"http://yoursite.com/tags/输入输出/"}]},{"title":"【继承】","slug":"【继承】","date":"2019-08-15T02:39:31.000Z","updated":"2019-08-15T02:41:24.569Z","comments":true,"path":"2019/08/15/【继承】/","link":"","permalink":"http://yoursite.com/2019/08/15/【继承】/","excerpt":"","text":"写法class Man{public: virtual void eat(){ cout&lt;&lt;”base”&lt;&lt;endl; };};class Woman:public Man{public: void eat(){ cout&lt;&lt;”woman”&lt;&lt;endl; }};","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/tags/Cplusplus/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}]},{"title":"【Java】值和refrense","slug":"【Java】值和refrense","date":"2019-08-12T08:18:26.000Z","updated":"2019-08-12T08:19:49.739Z","comments":true,"path":"2019/08/12/【Java】值和refrense/","link":"","permalink":"http://yoursite.com/2019/08/12/【Java】值和refrense/","excerpt":"","text":"值和对象的指针","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/指针/"}]},{"title":"【Java】基础变量","slug":"【Java】基础变量","date":"2019-08-12T04:36:08.000Z","updated":"2019-08-12T08:17:42.150Z","comments":true,"path":"2019/08/12/【Java】基础变量/","link":"","permalink":"http://yoursite.com/2019/08/12/【Java】基础变量/","excerpt":"","text":"语言类型java是先通过javac编译成.class字节码文件，然后运行java读入.class，并在jvm去解释的执行.class文件；jvm 实现了跨平台https://blog.csdn.net/qzc70919700/article/details/72515022 jdkJDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。 JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。 JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。 ①SE(J2SE)，standard edition，标准版，是我们通常用的一个版本，从JDK 5.0开始，改名为Java SE。 ②EE(J2EE)，enterprise edition，企业版，使用这种JDK开发J2EE应用程序，从JDK 5.0开始，改名为Java EE。 ③ME(J2ME)，micro edition，主要用于移动设备、嵌入式设备上的java应用程序，从JDK 5.0开始，改名为Java ME。 Java Runtime Environment（JRE） 是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。 RE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。 与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。 JVM（java virtual machine） 就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。 也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。 JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。格式一个.java只能有一个public classpublic static void main(String[] args)基本类型 char与c++不同，java中char型是16位的； float 和doubledouble 8个字节，更精确float 4个字节，要加f","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"【static】","slug":"【static】","date":"2019-08-07T12:59:28.000Z","updated":"2019-08-21T12:34:53.320Z","comments":true,"path":"2019/08/07/【static】/","link":"","permalink":"http://yoursite.com/2019/08/07/【static】/","excerpt":"","text":"https://blog.csdn.net/shuilan0066/article/details/6924251/ 全局静态变量 全局变量是可以extern的，但是静态全局变量是不可以extern的，它的作用域就是本文件；在全局变量前加上关键字static，全局变量就定义成一个全局静态变量. 他在整个程序生命周期的地址静止不变静态存储区，在整个程序运行期间一直存在。 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）； 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾 一定不要在头文件中定义static变量，不然的话每个cpp都会自己做一份备份。局部静态变量在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。 内存中的位置：静态存储区初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）； 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变； 关于声明和定义https://www.cnblogs.com/HDK2016/p/10236702.html 声明意味着告诉编译器关于变量名称、变量类型、变量大小、函数名称、结构名称、大小等等信息，并且在声明阶段不会给变量分配任何的内存。extern 声明，放.h文件中，什么都不加就是定义了，static也是，直接定义和声明是在一起的了。函数声明； 定义定义= 声明+内存分配函数定义； 静态成员及静态函数cnblogs.com/codingmengmeng/p/5906282.html","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"static","slug":"static","permalink":"http://yoursite.com/tags/static/"}]},{"title":"【Leetcode】145. 二叉树的后序遍历","slug":"【Leetcode】145-二叉树的后序遍历","date":"2019-07-27T12:11:31.000Z","updated":"2019-07-27T13:03:02.796Z","comments":true,"path":"2019/07/27/【Leetcode】145-二叉树的后序遍历/","link":"","permalink":"http://yoursite.com/2019/07/27/【Leetcode】145-二叉树的后序遍历/","excerpt":"","text":"题目 二叉树的中序遍历给定一个二叉树，返回它的 后序 遍历。 案例12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 递归思路中序遍历：左右中；首先递归左子树，然后递归右子树，最后将根节点压入栈； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; dfs(root, res); return res; &#125; void dfs(TreeNode* root, vector&lt;int&gt; &amp;res)&#123; if(!root) return; dfs(root-&gt;left, res); dfs(root-&gt;right, res); res.push_back(root-&gt;val); &#125;&#125;; 非递归思路1 参考前序遍历的方法，我们用中左右的方式去遍历，然后不断的加在前面； 在第二次遍历到的时候pop出去；代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(!root) return vector&lt;int&gt;&#123;&#125;; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; TreeNode* T = root; while(T || !s.empty())&#123; while(T)&#123; res.insert(res.begin(),T-&gt;val); s.push(T);//push的要对 T = T-&gt;right; &#125; if(!s.empty())&#123; TreeNode* t = s.top(); T = t-&gt;left; s.pop(); &#125; &#125; return res; &#125;&#125;; 非递归思路2 无论是前序还是中序还是后序；走的路径都是一样的，每个点都会被遍历三遍； 所以用一个pre指针和一个cur指针； 如果pre-&gt;left == cur 或者pre-&gt;right == cur，那么说明cur是第一次被遍历到； 如果cur-&gt;left == pre ，说明是第二次被遍历到； 如果cur-&gt;right == pre,说明是第三次遍历； 我们在第三次遍历到的时候再pop出去； 对于叶节点来讲，也会被遍历三次，但是实际上三次都是自己，所以当pre == cur的时候（也可能是右子树没有的节点），就是叶节点直接pop的时候； 注意一点就是第二次的情况，如果有左子树那么是cur-&gt;left == pre,如果没有左子树，那么就是第一次遍历的； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(!root) return vector&lt;int&gt;&#123;&#125;; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; s.push(root); TreeNode* pre = NULL,*cur = NULL; while(!s.empty())&#123; cur = s.top(); if(pre == NULL || pre-&gt;left == cur || pre-&gt;right == cur)&#123; if(cur-&gt;left)&#123; s.push(cur-&gt;left); &#125; else if(cur-&gt;right)&#123; s.push(cur-&gt;right); &#125; &#125; else if(cur-&gt;left == pre)&#123; if(cur-&gt;right) s.push(cur-&gt;right); &#125; else&#123; s.pop(); res.push_back(cur-&gt;val); &#125; pre = cur; &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"},{"name":"hard","slug":"hard","permalink":"http://yoursite.com/tags/hard/"}]},{"title":"【Leetcode】144. 二叉树的前序遍历","slug":"【Leetcode】144-二叉树的前序遍历","date":"2019-07-27T02:17:49.000Z","updated":"2019-07-27T08:55:33.132Z","comments":true,"path":"2019/07/27/【Leetcode】144-二叉树的前序遍历/","link":"","permalink":"http://yoursite.com/2019/07/27/【Leetcode】144-二叉树的前序遍历/","excerpt":"","text":"题目 判断是否是对称二叉树给定一个二叉树，返回它的 前序 遍历。 案例12345678 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 递归思路前序遍历：中左右；首先将根结点压入结果，然后不断的递归左子树和右子树； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; dfs(root, res); return res; &#125; void dfs(TreeNode* root, vector&lt;int&gt; &amp;res)&#123; if(!root) return; res.push_back(root-&gt;val); dfs(root-&gt;left, res); dfs(root-&gt;right, res); &#125;&#125;; 非递归思路1 在第一次访问的时候，压入结果并且弹出； 第二次既该节点作为子树的根结点的时候； 首先左子树然后然转向右子树，利用栈进行存储；代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; TreeNode* T = root; while(T || !s.empty())&#123; while(T)&#123;//找到最底层的左子树 res.push_back(T-&gt;val); s.push(T); T = T-&gt;left; &#125; if(!s.empty())&#123;//处理节点并且 T = s.top(); T = T-&gt;right; s.pop(); &#125; &#125; return res; &#125;&#125;; 非递归思路2 无论是前序还是中序还是后序；走的路径都是一样的，每个点都会被遍历三遍； 所以用一个pre指针和一个cur指针； 如果pre-&gt;left == cur 或者pre-&gt;right == cur，那么说明cur是第一次被遍历到； 如果cur-&gt;left == pre ，说明是第二次被遍历到； 如果cur-&gt;right == pre,说明是第三次遍历； 我们在第三次遍历到的时候再pop出去； 对于叶节点来讲，也会被遍历三次，但是实际上三次都是自己，所以当pre == cur的时候（也可能是右子树没有的节点），就是叶节点直接pop的时候； 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; s.push(root); TreeNode* pre = NULL, *cur = NULL; while(!s.empty())&#123; cur = s.top(); if(pre == NULL || pre-&gt;left == cur || pre-&gt;right == cur)&#123; res.push_back(cur-&gt;val); if(cur-&gt;left) s.push(cur-&gt;left); else if(cur-&gt;right) s.push(cur-&gt;right); &#125; else if(cur-&gt;left == pre)&#123; if(cur-&gt;right) s.push(cur-&gt;right); &#125; else&#123; s.pop(); &#125; pre = cur; &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"}]},{"title":"【Leetcode】94. 二叉树的中序遍历","slug":"【Leetcode】94-二叉树的中序遍历","date":"2019-07-25T05:41:28.000Z","updated":"2019-07-27T09:08:19.397Z","comments":true,"path":"2019/07/25/【Leetcode】94-二叉树的中序遍历/","link":"","permalink":"http://yoursite.com/2019/07/25/【Leetcode】94-二叉树的中序遍历/","excerpt":"","text":"题目 二叉树的中序遍历给定一个二叉树，返回它的 中序 遍历。 案例12345678输入: [1,null,2,3] 1 \\ 2 / 3输出: [1,3,2] 递归思路中序遍历：左中右；首先递归左子树，然后将根节点压入栈，然后递归右子树； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; dfs(root, res); return res; &#125; void dfs(TreeNode* root, vector&lt;int&gt; &amp;res)&#123; if(!root) return; dfs(root-&gt;left, res); res.push_back(root-&gt;val); dfs(root-&gt;right, res); &#125;&#125;; 非递归思路1 在第二次访问的时候，压入结果并且弹出； 第二次既该节点作为子树的根结点的时候； 首先左子树然后然转向右子树，利用栈进行存储；代码12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; TreeNode* T = root; while(T || !s.empty())&#123; while(T)&#123; s.push(T); T = T-&gt;left; &#125; if(!s.empty())&#123; T = s.top(); res.push_back(T-&gt;val); T = T-&gt;right; s.pop(); &#125; &#125; return res; &#125;&#125;; 非递归思路2 无论是前序还是中序还是后序；走的路径都是一样的，每个点都会被遍历三遍； 所以用一个pre指针和一个cur指针； 如果pre-&gt;left == cur 或者pre-&gt;right == cur，那么说明cur是第一次被遍历到； 如果cur-&gt;left == pre ，说明是第二次被遍历到； 如果cur-&gt;right == pre,说明是第三次遍历； 我们在第三次遍历到的时候再pop出去； 对于叶节点来讲，也会被遍历三次，但是实际上三次都是自己，所以当pre == cur的时候（也可能是右子树没有的节点），就是叶节点直接pop的时候； 注意一点就是第二次的情况，如果有左子树那么是cur-&gt;left == pre,如果没有左子树，那么就是第一次遍历的； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; s.push(root); TreeNode* pre = NULL, *cur = NULL; while(!s.empty())&#123; //cout&lt;&lt;\"in\"&lt;&lt;endl; cur = s.top(); //if(cur) cout&lt;&lt;cur-&gt;val&lt;&lt;endl; //if(pre) cout&lt;&lt;pre-&gt;val&lt;&lt;endl; if(pre == NULL || pre-&gt;left == cur || pre-&gt;right == cur)&#123; if(!cur-&gt;left) res.push_back(cur-&gt;val); if(cur-&gt;left) s.push(cur-&gt;left); else if(cur-&gt;right) s.push(cur-&gt;right); &#125; else if(cur-&gt;left == pre)&#123; res.push_back(cur-&gt;val); if(cur-&gt;right) s.push(cur-&gt;right); &#125; else &#123; s.pop(); &#125; pre = cur; &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"}]},{"title":"【面试】面向对象的理解","slug":"【面试】面向对象的理解","date":"2019-07-22T14:53:09.000Z","updated":"2019-07-22T15:00:45.582Z","comments":true,"path":"2019/07/22/【面试】面向对象的理解/","link":"","permalink":"http://yoursite.com/2019/07/22/【面试】面向对象的理解/","excerpt":"","text":"怎么理解面向对象对面向对象的理解 在我理解,面向对象是向现实世界模型的自然延伸，这是一种“万物皆对象”的编程思想。在现实生活中的任何物体都可以归为一类事物，而每一个个体都是一类事物的实例。面向对象的编程是以对象为中心，以消息为驱动，所以程序=对象+消息。 面向对象有三大特性，封装、继承和多态。 封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化。这样做使得代码的复用性更高。 继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类–有父类的行为和属性，也有自己特有的行为和属性。这样做扩展了已存在的代码块，进一步提高了代码的复用性。 如果说封装和继承是为了使代码重用，那么多态则是为了实现接口重用。多态的一大作用就是为了解耦–为了解除父子类继承的耦合度。如果说继承中父子类的关系式IS-A的关系，那么接口和实现类之之间的关系式HAS-A。简单来说，多态就是允许父类引用(或接口)指向子类(或实现类)对象。很多的设计模式都是基于面向对象的多态性设计的。 总结一下，如果说封装和继承是面向对象的基础，那么多态则是面向对象最精髓的理论。掌握多态必先了解接口，只有充分理解接口才能更好的应用多态。 作者：samhan0616来源：CSDN原文：https://blog.csdn.net/weixin_40066829/article/details/78111476版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/tags/Cplusplus/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}]},{"title":"【Leetcode】85. 最大矩形","slug":"【Leetcode】85-最大矩形","date":"2019-07-16T03:36:22.000Z","updated":"2019-07-16T08:10:18.148Z","comments":true,"path":"2019/07/16/【Leetcode】85-最大矩形/","link":"","permalink":"http://yoursite.com/2019/07/16/【Leetcode】85-最大矩形/","excerpt":"","text":"题目 最大矩形给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 案例示例 1:12345678输入:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出: 6 思路 把每一层分别当成底部，算能形成的矩形的面试，就是84题一样的 [84、柱状图中最大的矩形]（https://ynggdttt.github.io/2019/07/16/【Leetcode】84-柱状图中最大的矩形/） 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; tem; int res = 0; for(int i = 0; i &lt; matrix.size(); i++)&#123; tem.resize(matrix[i].size()); for(int j = 0; j &lt; tem.size(); j++)&#123; if(matrix[i][j] == '0') tem[j] = 0; else tem[j]++; &#125; int re = helper(tem); res = max(res,re); &#125; return res; &#125; int helper(vector&lt;int&gt; &amp;tem)&#123; int n = tem.size(); int res = 0; for(int i = 0; i &lt; n; i++)&#123; if(i + 1 &lt; n &amp;&amp; tem[i] &lt; tem[i+1]) continue; int mi = tem[i]; for(int j = i; j &gt;= 0; j--)&#123; mi = min(mi, tem[j]); res = max(mi*(i - j + 1),res); &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"hard","slug":"hard","permalink":"http://yoursite.com/tags/hard/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"【Leetcode】84. 柱状图中最大的矩形","slug":"【Leetcode】84-柱状图中最大的矩形","date":"2019-07-16T03:05:14.000Z","updated":"2019-07-16T03:37:10.818Z","comments":true,"path":"2019/07/16/【Leetcode】84-柱状图中最大的矩形/","link":"","permalink":"http://yoursite.com/2019/07/16/【Leetcode】84-柱状图中最大的矩形/","excerpt":"","text":"题目 柱状图中最大的矩形给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 案例示例 1:12输入: [2,1,5,6,2,3]输出: 10 思路 找到局部最大，然后判断从头到这个地方的最大的矩形面积； 具体是找到到当前的最小值，然后乘以宽； 两种做法，一种是直接遍历，找到比后一个小的，另一种是用栈； 代码1234567891011121314151617class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; for(int i = 0; i &lt; heights.size(); i++)&#123; if(i + 1 &lt; heights.size() &amp;&amp; heights[i] &lt;= heights[i+1]) continue; int maxH = heights[i], minH = heights[i]; for(int j = i - 1; j &gt;= 0; j--)&#123; minH = min(minH, heights[j]); maxH = max(maxH, minH * (i - j + 1)); &#125; res = max(res, maxH); &#125; return res; &#125;&#125;; class Solution { public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int res = 0; stack&lt;int&gt; s; heights.push_back(0); for(int i = 0; i &lt; heights.size() - 1; i++){ //if(heights[i] &lt;= heights[i+1]) s.push(i); if(heights[i] &gt; heights[i+1]){ int mi = heights[i]; //res = max(heights[i],res); //int re = heights[i]; while(!s.empty()){ int t = s.top(); s.pop(); mi = min(mi,heights[t]); res = max(res, mi * (i - t + 1)); } for(int j = 0; j &lt;= i; j++) s.push(j); } } return res; } };","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"hard","slug":"hard","permalink":"http://yoursite.com/tags/hard/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"【Leetcode】149. 直线上最多的点数","slug":"【Leetcode】149-直线上最多的点数","date":"2019-07-16T02:42:42.000Z","updated":"2019-07-16T02:51:16.776Z","comments":true,"path":"2019/07/16/【Leetcode】149-直线上最多的点数/","link":"","permalink":"http://yoursite.com/2019/07/16/【Leetcode】149-直线上最多的点数/","excerpt":"","text":"题目 加一给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。 案例示例 1:12345678910输入: [[1,1],[2,2],[3,3]]输出: 3解释:^|| o| o| o +-------------&gt;0 1 2 3 4 1234567891011输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]输出: 4解释:^|| o| o o| o| o o+-------------------&gt;0 1 2 3 4 5 6 思路 考虑利用斜率解决问题，但是因为斜率可能有小数，更像是一个方向向量，所以推荐用除以最大公约数来做； 考虑可能求出来的公约数是0，那么这种情况实际是发生了重合的点，那么我们要对重合的点做一个特别的累积； 利用map来存储，存储每个方向向量上包含的点有多少，需要对每个点都做一遍这个操作； 时间复杂度是O（N^2）,空间复杂度是O（N）； 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int res = 0; int n = points.size(); map&lt;vector&lt;int&gt;,int&gt; m; for(int i = 0; i &lt; n; i++)&#123; int equal = 1; int x = points[i][0], y = points[i][1]; m.clear();//每次要清除 for(int j = i + 1; j &lt; n; j++)&#123; if(i == j) continue; int xt = points[j][0], yt = points[j][1]; if(xt == x &amp;&amp; yt == y) &#123;equal++; continue;&#125;;//判断是否是重合点 int dx = x - xt, dy = y - yt; int d = gcd(dx, dy); m[&#123;dx/d, dy/d&#125;]++; &#125; if(m.empty()) res = max(res, equal); else&#123; for(auto a : m)&#123; res = max(res, a.second + equal); &#125; &#125; &#125; return res; &#125; int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"http://yoursite.com/tags/哈希/"},{"name":"hard","slug":"hard","permalink":"http://yoursite.com/tags/hard/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"【golang】","slug":"【golang】","date":"2019-07-13T15:18:21.000Z","updated":"2019-07-13T15:42:41.267Z","comments":true,"path":"2019/07/13/【golang】/","link":"","permalink":"http://yoursite.com/2019/07/13/【golang】/","excerpt":"","text":"golang go的调度goroutine 协程（GPM模型）就随机选择另外一个P，从其可执行的G队列中偷取一半（work-stealing调度算法）https://cloud.tencent.com/developer/article/1399244https://www.cnblogs.com/wdliu/p/9272220.html channel 是符合类型利用channel 来同步可以用select在协程中进行选择；如何关闭https://blog.csdn.net/qq_33296108/article/details/82731686 channel 缓冲ch := make(chan int, n) slice相当于动态数据，维护struct；https://www.jianshu.com/p/19a38629b3d9copy 函数的话，就是覆盖前多少个； map key-value 判断key是否存在； 必须初始化； 是引用类型； 遍历是无序的； map顺序输出，把key存在数组里，然后再去输出； 和c++的区别（红黑树和hashtable） map是非并发安全的； go的new和make区别https://www.jianshu.com/p/c173dab0e71cnew和make都在堆上分配内存，但是它们的行为不同，适用于不同的类型。new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T{}。make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：slice、map 和 channel。换言之，new 函数分配内存，make 函数初始化； defer在return之后执行的；后进先出；https://studygolang.com/articles/10167 reflecthttps://www.cnblogs.com/cxiaojia/p/6193606.html我用在数据库迁移，因为有很多的表，每次要从表中取出，然后再Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:(value, type) reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型 reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值 也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种 为什么要序列化成json","categories":[{"name":"语言","slug":"语言","permalink":"http://yoursite.com/categories/语言/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"【内存泄漏】","slug":"【内存泄漏】","date":"2019-07-13T11:15:39.000Z","updated":"2019-07-13T15:16:46.132Z","comments":true,"path":"2019/07/13/【内存泄漏】/","link":"","permalink":"http://yoursite.com/2019/07/13/【内存泄漏】/","excerpt":"","text":"https://www.cnblogs.com/liushui-sky/p/7727865.html 在类的构造函数和析构函数中没有匹配的调用new和delete函数两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存 在释放对象数组时在delete中没有使用方括号方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。 释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。 对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了 缺少拷贝构造函数浅拷贝两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。 按值传递会调用（拷贝）构造函数，引用传递不会调用。 在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。 所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符 C++中构造函数，拷贝构造函数和赋值函数的区别和实现参见：http://www.cnblogs.com/liushui-sky/p/7728902.html 缺少重载赋值运算符 这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露 关于nonmodifying运算符重载的常见迷思 a. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针 b. 返回内部静态对象的引用。 c. 返回一个泄露内存的动态分配的对象。导致内存泄露，并且无法回收 解决这一类问题的办法是重载运算符函数的返回值不是类型的引用，二应该是类型的返回值，即不是 int&amp;而是int 没有将基类的析构函数定义为虚函数当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露 造成野指针的原因：指针变量没有被初始化（如果值不定，可以初始化为NULL）指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/tags/Cplusplus/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://yoursite.com/tags/内存泄漏/"}]},{"title":"【数据库引擎】","slug":"【数据库引擎】","date":"2019-07-13T06:37:58.000Z","updated":"2019-07-13T07:41:52.593Z","comments":true,"path":"2019/07/13/【数据库引擎】/","link":"","permalink":"http://yoursite.com/2019/07/13/【数据库引擎】/","excerpt":"","text":"来源 什么是引擎数据库引擎是用于存储、处理和保护数据的核心服务。MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。 如何存储数据 如何为存储的数据建立索引 如何更新、查询数据 等技术的实现方法。 Mysql数据库的引擎InnoDBInnoDB是一个健壮的*事务型 存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。使用场合 更新密集的表。 InnoDB存储引擎特别适合处理多重并发的更新请求。 事务。 InnoDB存储引擎是支持事务的标准MySQL存储引擎。 自动灾难恢复。 与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。 外键约束。 MySQL支持外键的存储引擎只有InnoDB。 支持自动增加列AUTO_INCREMENT属性。 从5.7开始innodb存储引擎成为默认的存储引擎。一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。 MyISAM MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器。 每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：tb_demo.frm，存储表定义。tb_demo.MYD，存储数据。tb_demo.MYI，存储索引。 MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。 使用场合 选择密集型的表。 MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。 插入密集型的表。 MyISAM的并发插入特性允许同时选择和插入数据。 由此看来，MyISAM存储引擎很适合管理服务器日志数据。 MRG_MYISAM MRG_MyISAM存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同； 对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间段相关；例如，可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。 MEMORY 使用MySQL Memory存储引擎的出发点是速度，为得到最快的响应时间，采用的逻辑存储介质是系统内存。 缺点 虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。 它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。 使用场合 目标数据较小，而且被非常频繁地访问。 在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。 如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。 存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。 Memory同时支持散列索引和B树索引。 CSV CSV 存储引擎是基于 CSV 格式文件存储数据。 CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。 CSV 引擎也不支持索引，不支持分区。 CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为CSM，用来保存表的状态及表中保存的数据量。 每个数据行占用一个文本行。 因为 csv 文件本身就可以被Office等软件直接编辑，保不齐就有不按规则出牌的情况，如果出现csv 文件中的内容损坏了的情况，也可以使用 CHECK TABLE 或者 REPAIR TABLE 命令检查和修复。 ARCHIVEArchive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。 在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。 Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。 BLACKHOLE MySQL在5.x系列提供了Blackhole引擎–“黑洞”，其作用正如其名字一样：任何写入到此引擎的数据均会被丢弃掉， 不做实际存储；Select语句的内容永远是空。 Blackhole虽然不存储数据，但是MySQL还是会正常的记录下Binlog，而且这些Binlog还会被正常的同步到Slave上，可以在Slave上对数据进行后续的处理。关于binglog 使用场合 验证语法 验证dump file语法的正确性 检测负载 以使用blackhole引擎来检测binlog功能所需要的额外负载 检测性能 由于blackhole性能损耗极小，可以用来检测除了存储引擎这个功能点之外的其他MySQL功能点的性能。 PERFORMANCE_SCHEMA主要用于收集数据库服务器性能参数。 MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。 FEDERATED主要用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取；在MariaDB上的实现是FederatedX。 #存储引擎相关操作命令 存储引擎相关操作命令 SHOW ENGINES； 在创建表的时候，对表设置存储引擎 CREATE TABLE user ( id int(100) unsigned NOT NULL AUTO_INCREMENT, name varchar(32) NOT NULL DEFAULT ‘’ COMMENT ‘姓名’, mobile varchar(20) NOT NULL DEFAULT ‘’ COMMENT ‘手机’, PRIMARY KEY (id))ENGINE=InnoDB; 选择数据库引擎的时候要注意 是否需要支持事务； 是否需要使用热备； 崩溃恢复，能否接受崩溃； 是否需要外键支持； 存储的限制； 对索引和缓存的支持。 各个引擎对比","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"引擎","slug":"引擎","permalink":"http://yoursite.com/tags/引擎/"}]},{"title":"Leetcode】66. 加一","slug":"【Leetcode】66-加一","date":"2019-07-11T06:41:23.000Z","updated":"2019-07-11T06:46:38.831Z","comments":true,"path":"2019/07/11/【Leetcode】66-加一/","link":"","permalink":"http://yoursite.com/2019/07/11/【Leetcode】66-加一/","excerpt":"","text":"题目 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 案例示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 思路 考虑只有9+1才会进位； 先从后往前，如果是是连续的9，就设置为0，直至不是9； 然后把退出的那位+1； 如果全是9，就在0的位置插入1； 代码1234567891011121314class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int i = digits.size() - 1; while(i &gt;= 0 &amp;&amp; digits[i] == 9)&#123; digits[i--] = 0; &#125; if(i &lt; 0) digits.insert(digits.begin(),1); else digits[i]++; return digits; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"【Leetcode】64. 最小路径和","slug":"【Leetcode】64-最小路径和","date":"2019-07-11T06:32:25.000Z","updated":"2019-07-11T06:36:25.807Z","comments":true,"path":"2019/07/11/【Leetcode】64-最小路径和/","link":"","permalink":"http://yoursite.com/2019/07/11/【Leetcode】64-最小路径和/","excerpt":"","text":"题目 最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 案例示例 1:12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 思路 利用dp,递归数组为dp[i][j] = min(dp[i][j + 1],dp[i+1][j]) + grid[i][j]; 首先初始化dp数组的右边和下边； 代码1234567891011121314151617181920class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.empty()) return 0; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,grid[m-1][n-1])); for(int i = m - 2; i &gt;= 0; i--)&#123; dp[i][n-1] = dp[i+1][n-1] + grid[i][n-1]; &#125; for(int i = n - 2; i &gt;= 0; i--)&#123; dp[m-1][i] = dp[m-1][i+1] + grid[m-1][i]; &#125; for(int i = m - 2; i &gt;= 0; i--)&#123; for(int j = n - 2; j &gt;= 0; j--)&#123; dp[i][j] = min(dp[i][j + 1],dp[i+1][j]) + grid[i][j]; &#125; &#125; return dp[0][0]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"【Leetcode】63. 不同路径 II","slug":"【Leetcode】63-不同路径-II","date":"2019-07-11T06:26:19.000Z","updated":"2019-07-11T06:40:04.486Z","comments":true,"path":"2019/07/11/【Leetcode】63-不同路径-II/","link":"","permalink":"http://yoursite.com/2019/07/11/【Leetcode】63-不同路径-II/","excerpt":"","text":"题目 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。 案例示例 1:123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 思路 利用dp,递归数组为dp[i][j] = dp[i-1][j] + dp[i][j - 1]; 对于障碍物的情况，首先确定右边界和下边界，如果是已经有障碍物了，那么左边或者上边都是0； 遍历的时候考虑，是不是有障碍物，有的话，就设置为0； 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.empty()) return 0; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;long int&gt; &gt;dp(m, vector&lt;long int&gt;(n,1)); if(obstacleGrid[m - 1][n - 1] == 1) return 0; //确定初始的值 for(int i = 1; i &lt; m; i++)&#123; if(obstacleGrid[m - 1 - i][n - 1] == 1)&#123; for(int j = i; j &lt; m; j++) dp[j][0] = 0; break; &#125; &#125; for(int i = 1; i &lt; n; i++)&#123; if(obstacleGrid[m - 1][n - 1 - i] == 1)&#123; for(int j = i; j &lt; n; j++) dp[0][j] = 0; break; &#125; &#125; //遍历 for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; if(obstacleGrid[m - 1 - i][n - 1 - j] == 1) dp[i][j] = 0; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"【Leetcode】62. 不同路径","slug":"【Leetcode】62-不同路径","date":"2019-07-11T03:38:34.000Z","updated":"2019-07-11T06:22:41.710Z","comments":true,"path":"2019/07/11/【Leetcode】62-不同路径/","link":"","permalink":"http://yoursite.com/2019/07/11/【Leetcode】62-不同路径/","excerpt":"","text":"题目 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 案例示例 1:1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2:12输入: m = 7, n = 3输出: 28 思路 利用dp,递归数组为dp[i][j] = dp[i-1][j] + dp[i][j - 1]; 边界右和下均为1； 这里设置的是反着的，注意一下哈，也可以正着； 也可以空间复杂度没那么高，只有n也可以；代码123456789101112class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n,1)); for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j - 1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;int&gt; dp(n,1); for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; dp[j] = dp[j] + dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"【指针和引用】","slug":"【指针和引用】","date":"2019-07-09T13:57:44.000Z","updated":"2019-07-09T15:12:42.496Z","comments":true,"path":"2019/07/09/【指针和引用】/","link":"","permalink":"http://yoursite.com/2019/07/09/【指针和引用】/","excerpt":"","text":"指针和引用的区别1.指针有自己的一块空间，而引用只是一个别名； 2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小； 3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用； 4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象； 5.可以有const指针，但是没有const引用； 解释引用可以指向常量，也可以指向变量。例如int &amp;a=b，使引用a指向变量b。而为了让引用指向常量，必须使用常量引用，如const int &amp;a=1; 它代表的是引用a指向一个const int型，这个int型的值不能被改变，而不是引用a的指向不能被改变，因为引用的指向本来就是不可变的，无需加const声明。即指针存在常量指针int const p和指针常量int const p，而引用只存在常量引用int const &amp;a，不存在引用常量int&amp; const a。 6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变； 7.指针可以有多级指针（**p），而引用至于一级； 8.指针和引用使用++运算符的意义不一样； 9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/指针/"},{"name":"引用","slug":"引用","permalink":"http://yoursite.com/tags/引用/"}]},{"title":"【缓存】","slug":"【缓存】","date":"2019-07-08T01:39:50.000Z","updated":"2019-07-08T01:51:55.862Z","comments":true,"path":"2019/07/08/【缓存】/","link":"","permalink":"http://yoursite.com/2019/07/08/【缓存】/","excerpt":"","text":"缓存缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，https://blog.csdn.net/weixin_43538815/article/details/84559933","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"}]},{"title":"【Leetcode】42. 接雨水","slug":"【Leetcode】42-接雨水","date":"2019-07-06T07:44:59.000Z","updated":"2019-07-06T08:37:04.560Z","comments":true,"path":"2019/07/06/【Leetcode】42-接雨水/","link":"","permalink":"http://yoursite.com/2019/07/06/【Leetcode】42-接雨水/","excerpt":"","text":"题目 组合总和 II给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 案例示例 1:12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 思路 首先找到最大的那个，然后分成左右两边； 对左边的，从左向右遍历；如果比当前的值大，就替换，否则相减，就是当前的能盛水的； 对右边的，从右向左遍历；如果比当前的值大，就替换，否则相减，就是当前的能盛水的； 代码12345678910111213141516171819202122232425262728class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n &lt;= 2) return 0; //找最大值 int maxt = height[0], index = 0; for(int i = 1; i &lt; n; i++)&#123; if(height[i] &gt; maxt)&#123; maxt = height[i]; index = i; &#125; &#125; //找左侧的 int maxl = height[0], res = 0; for(int i = 1; i &lt; index; i++)&#123; if(height[i] &gt; maxl) maxl = height[i]; else res += maxl - height[i]; &#125; //找右侧的 int maxr = height[n - 1]; for(int i = n -1; i &gt; index; i--)&#123; if(height[i] &gt; maxr) maxr = height[i]; else res += maxr - height[i]; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"困难","slug":"困难","permalink":"http://yoursite.com/tags/困难/"},{"name":"递减序列","slug":"递减序列","permalink":"http://yoursite.com/tags/递减序列/"},{"name":"递增序列","slug":"递增序列","permalink":"http://yoursite.com/tags/递增序列/"}]},{"title":"【Leetcode】41. 缺失的第一个正数","slug":"【Leetcode】41-缺失的第一个正数","date":"2019-07-06T07:15:12.000Z","updated":"2019-07-06T07:27:23.376Z","comments":true,"path":"2019/07/06/【Leetcode】41-缺失的第一个正数/","link":"","permalink":"http://yoursite.com/2019/07/06/【Leetcode】41-缺失的第一个正数/","excerpt":"","text":"题目 组合总和 II给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 案例示例 1: 输入:12输入: [1,2,0]输出: 3 案例2:12输入: [3,4,-1,1]输出: 2 案例3:12输入: [7,8,9,11,12]输出: 1 思路因为题目中要求是时间复杂度不超过O（n）,空间复杂度要为常数空间，总体的思路就是把所有的位置放回原位，然后从前向后遍历； 具体的实现就是，当这个数是1-n之间的，且这个数组本应该对应的那个位置上没有正确的数，就把两个交换，直至该位置上的数不满足条件位置； 特别注意的是，要把这个位置上的都处理好再进行下一个位置的； 代码1234567891011121314151617class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i = 0; i &lt; n; i++)&#123; while(i &lt; n &amp;&amp; nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i])&#123; swap(nums[i], nums[nums[i] - 1]); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(nums[i] != i + 1)&#123; return i + 1; &#125; &#125; return n + 1; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"困难","slug":"困难","permalink":"http://yoursite.com/tags/困难/"},{"name":"变换下标","slug":"变换下标","permalink":"http://yoursite.com/tags/变换下标/"}]},{"title":"【英文】","slug":"【英文】","date":"2019-07-06T03:01:05.000Z","updated":"2019-07-06T03:12:02.927Z","comments":true,"path":"2019/07/06/【英文】/","link":"","permalink":"http://yoursite.com/2019/07/06/【英文】/","excerpt":"","text":"算法 回溯算法：Backtracking Algorithm； 时间复杂度：Time Complexity； 空间复杂度：space complexity;","categories":[{"name":"专业术语","slug":"专业术语","permalink":"http://yoursite.com/categories/专业术语/"}],"tags":[{"name":"英文表达","slug":"英文表达","permalink":"http://yoursite.com/tags/英文表达/"}]},{"title":"【Leetcode】40. 组合总和 II","slug":"【Leetcode】40-组合总和-II","date":"2019-07-06T02:51:37.000Z","updated":"2019-07-06T03:58:44.886Z","comments":true,"path":"2019/07/06/【Leetcode】40-组合总和-II/","link":"","permalink":"http://yoursite.com/2019/07/06/【Leetcode】40-组合总和-II/","excerpt":"","text":"题目 组合总和 II给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 案例示例 1: 输入:12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 案例2:123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 思路 很典型的dfs思想，回溯算法 三步，定义一个存储的中间变量，最终结果，起始位置； 递归兜底条件是target == 0,或者target &lt; 0; 回溯的过程记得pop出来，恢复上一个状态； 关键的点在不可以重复； 如果和前面的重复，要去重； 所以要排序，才好去重； 类似题目39,组合总和 代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(target == 0) return res; vector&lt;int&gt; cur; sort(candidates.begin(),candidates.end()); helper(candidates, target, 0, res, cur); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates, int target, int pos, vector&lt;vector&lt;int&gt; &gt;&amp;res, vector&lt;int&gt; cur)&#123; if(target == 0)&#123; res.push_back(cur); return; &#125; if(target &lt; 0) return; for(int i = pos; i &lt; candidates.size(); i++)&#123; if(i &gt; pos &amp;&amp; candidates[i] == candidates[i - 1]) continue; cur.push_back(candidates[i]); helper(candidates,target - candidates[i], i + 1, res, cur); cur.pop_back(); &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/回溯/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"}]},{"title":"【Leetcode】39. 组合总和","slug":"【Leetcode】39-组合总和","date":"2019-07-06T02:51:14.000Z","updated":"2019-07-06T03:56:55.873Z","comments":true,"path":"2019/07/06/【Leetcode】39-组合总和/","link":"","permalink":"http://yoursite.com/2019/07/06/【Leetcode】39-组合总和/","excerpt":"","text":"题目 组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 案例示例 1: 输入:123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2:1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 思路 很典型的dfs思想，回溯算法 三步，定义一个存储的中间变量，最终结果，起始位置； 递归兜底条件是target == 0,或者target &lt; 0; 回溯的过程记得pop出来，恢复上一个状态； 关键的点在可以重复，所以递归的时候就是要从i开始； 代码12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(target == 0) return res; vector&lt;int&gt;cur; helper(candidates,target,0,res, cur); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates,int target,int start, vector&lt;vector&lt;int&gt; &gt;&amp;res,vector&lt;int&gt;cur)&#123; if(target == 0)&#123; res.push_back(cur); return; &#125; if(target &lt; 0) return; for(int i = start; i &lt; candidates.size(); i++)&#123; cur.push_back(candidates[i]); helper(candidates, target - candidates[i], i, res, cur); cur.pop_back(); &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/回溯/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"}]},{"title":"【测试】","slug":"【测试】","date":"2019-06-29T12:07:57.000Z","updated":"2019-08-21T13:44:30.482Z","comments":true,"path":"2019/06/29/【测试】/","link":"","permalink":"http://yoursite.com/2019/06/29/【测试】/","excerpt":"","text":"测试方法 单元测试完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。 集成测试应当避免一次性的集成（除非软件规模很小），而采用增量集成。自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。 自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。 系统测试是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。 回归测试回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。 验收测试Alpha测试：是由用户在开发者的场所来进行的，在一个受控的环境中进行。aBeta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。 灰度测试就是在小范围内看一下效果； bug的评测优先级和严重程度 自动化测试自动化测试的意义在于1、可以对程序的新版本自动执行回归测试 2、可以执行手工测试困难或者不可能实现的测试，如压力测试，并发测试， 3、能够更好的利用资源，节省时间和人力 执行自动化测试之前首先判断这个项目是不是和推广自动化测试，然后对项目做需求分析，指定测试计划，搭建自动化测试框架，设计测试用例，执行测试，评估4、测试的复用性；5、测试具有一致性和可重复性。由于测试是自动执行的，每次测试的结果和执行的内容的一致性是可以得到保障的，从而达到测试的可重复的效果。6、增加软件信任度。由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量。一旦软件通过了强有力的自动测试后，软件的信任度自然会增加。 自动化测试替代手工测试1、不能取代手工测试 2、手工测试比自动测试发现的缺陷更多 3、对测试质量的依赖性极大 4、测试自动化不能提高有效性 5、测试自动化可能会制约软件开发。由于自动测试比手动测试更脆弱，所以维护会受到限制，从而制约软件的开发。 6、工具本身并无想像力7、审美以及合理性 请问你怎么看待测试，知道哪些测试的类型，有用过哪些测试方法？测试是软件开发中不可或缺的一环，测试通过经济，高效的方法，捕捉软件中的错误，从而达到保重软件内在质量的目的。测试分为功能测试和非功能测试，非功能测试又可以分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。 测试方法用过等价划分法、边值分析法、错误推测法、因果图法。 app和web测试web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容 app测试则要看分辨率，屏幕尺寸，还要看设备系统。 web测试是基于浏览器的所以不必考虑安装卸载。 而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件 。 此外APP还有一些专项测试：如网络、适配性。 性能方面: web页面主要会关注响应时间 而app则还需要关心流量、电量、CPU、GPU、Memory这些。 测试工具 uiautomator weditor selenium pict https://jingyan.baidu.com/article/2fb0ba4049ac5400f2ec5fb1.html jmeter 性能测试https://blog.csdn.net/u012111923/article/details/80705141 monkey安卓手机端 树莓派 弱网","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"}]},{"title":"【数据库sql】","slug":"【数据库sql】","date":"2019-06-29T11:36:06.000Z","updated":"2019-08-17T11:37:10.094Z","comments":true,"path":"2019/06/29/【数据库sql】/","link":"","permalink":"http://yoursite.com/2019/06/29/【数据库sql】/","excerpt":"","text":"创建数据库CREATE SCHEMA T; 删除数据库DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;//级联和限制级联就是直接都删除限制是只有表都删除了，才能删除 定义表CREATE TABLE &lt;表名&gt; / 基本表的名称 /(&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] /组成该表的列/[,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ]…[,&lt;表级完整性约束条件&gt; ] ); Create table Student(Sno CHAR(9) primary key,Sname CHAR(20) UNIQUE, / Sname取唯一值/Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20));CREATE TABLE Course(Cno CHAR(4) PRIMARY KEY,Cname CHAR(40),Cpno CHAR(4),Ccredit int(8),FOREIGN KEY (Cpno) REFERENCES Course(Cno)//定义外键);CREATE TABLE SC(Sno CHAR(9),Cno CHAR(4),Grade int(8),PRIMARY KEY (Sno,Cno),/ 主码由两个属性构成，必须作为表级完整性进行定义/ FOREIGN KEY (Sno) REFERENCES Student(Sno),/ 表级完整性约束条件，Sno是外码，被参照表是Student /FOREIGN KEY (Cno)REFERENCES Course(Cno)/ 表级完整性约束条件， Cno是外码，被参照表是Course/); 修改表ALTER TABLE &lt;表名&gt;[ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ][ADD &lt;表级完整性约束&gt;][DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ]//删除列名[DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ][modify COLUMN &lt;列名&gt;&lt;数据类型&gt; ] ;//修改列的类型ALTER TABLE 表名 CHANGE 列名 新列名 列类型。//修改列名 Alter table student add S_entrance DATE;//增加ALTER TABLE Student modify COLUMN Sage INT;//改变类型ALTER TABLE Course ADD UNIQUE(Cname); //增加约束 索引 建立索引CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);&lt;表名&gt;：要建索引的基本表的名字 索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔 &lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC UNIQUE：此索引的每一个索引值只对应唯一的数据记录 CLUSTER：表示要建立的索引是聚簇索引CREATE UNIQUE INDEX Stusno ON Student(Sno);CREATE UNIQUE INDEX Coucno ON Course(Cno);CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC); 修改索引ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt; 删除索引DROP INDEX &lt;索引名&gt;; 查询语句SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;] …FROM &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]…|(SELECT 语句)[AS]&lt;别名&gt;[ WHERE &lt;条件表达式&gt; ][ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ][ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]; 用小写字母输出 lower例子：查询全体学生的姓名、出生年份和所在的院系，要求用小写字母表示系名。Year of Birth: ‘就是个常量 SELECT Sname,’Year of Birth: ‘,2014-Sage,LOWER(Sdept)FROM Student;输出结果：Sname ‘Year of Birth:’ 2014-Sage LOWER(Sdept)李勇 Year of Birth: 1994 cs刘晨 Year of Birth: 1995 cs王敏 Year of Birth: 1996 ma张立 Year of Birth: 1995 is 重新命名各个列 别名SELECT Sname NAME,’Year of Birth:’ BIRTH,2014-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENTFROM Student;输出结果：NAME BIRTH BIRTHDAY DEPARTMENT李勇 Year of Birth: 1994 cs刘晨 Year of Birth: 1995 cs王敏 Year of Birth: 1996 ma张立 Year of Birth: 1995 is 消除重复的distinct 常用查询条件 IN &lt;值表&gt;, NOT IN &lt;值表&gt;[例3.28]查询既不是计算机科学系、数学系，也不是信息系的学生的姓名和性别。SELECT Sname, SsexFROM StudentWHERE Sdept NOT IN (‘IS’,’MA’,’CS’ ); [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’]&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和 _ % （百分号） 代表任意长度（长度可以为0）的字符串例如a%b表示以a开头，以b结尾的任意长度的字符串 _ （下横线） 代表任意单个字符。例如a_b表示以a开头，以b结尾的长度为3的任意字符串 使用换码字符将通配符转义为普通字符ESCAPE[例3.34] 查询DB_Design课程的课程号和学分。SELECT Cno，CcreditFROM CourseWHERE Cname LIKE ‘DB_Design’ ESCAPE ‘\\ ‘ ; 确定范围谓词: BETWEEN … AND …NOT BETWEEN … AND … 涉及空值的查询不能用=： IS NULL 或 IS NOT NULL“IS” 不能用 “=” 代替SELECT Sno，CnoFROM SCWHERE Grade IS NUL 多重条件查询 AND OR逻辑运算符：AND和 OR来连接多个查询条件 AND的优先级高于OR 可以用括号改变优先级 排序order by desc 和 asc 可以查询两个查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。SELECT *FROM StudentORDER BY Sdept, Sage DESC; 聚集函数count, sum ,avg, max, min 查询学生总人数SELECT COUNT(*)FROM Student; 查询选修了课程的学生人数。SELECT COUNT(DISTINCT Sno)FROM SC; 计算1号课程的学生平均成绩SELECT AVG(Grade)FROM SCWHERE Cno=’1’ 查询选修1号课程的学生最高分数。SELECT MAX(Grade)FROM SCWHERE Cno=’1’;GROUP BY子句 查询选修了3门以上课程的学生学号。SELECT SnoFROM SCGROUP BY SnoHaving Count(*) &gt; 3 查询平均成绩大于等于90分的学生学号和平均成绩SELECT Sno, AVG(Grade)FROM SCWHERE AVG(Grade)&gt;=90GROUP BY Sno;//错误 SELECT Sno, AVG(Grade)FROM SCGROUP BY SnoHAVING AVG(Grade) &gt; 90;HAVING短语与WHERE子句的区别： 作用对象不同 WHERE子句作用于基表或视图，从中选择满足条件的元组 HAVING短语作用于组，从中选择满足条件的组。列出计算机系姓刘的同学的信息，按照学号大小排序SELECT *FROM STUDENTWHERE Sdept=‘CS’ AND NAME LIKE ‘刘%’ORDER BY Sno 按系并区分男女统计各系学生的人数、并按照人数降序排序SELECT Ssex, Sdep, Count(Sno)GROUP BY Ssex, Sdep,Order By Count(Sno) Desc https://www.cnblogs.com/diffrent/p/8854995.html 用一条SQL 语句 查询出每门课都大于80 分的学生姓名 name kecheng fenshu张三 语文 81张三 数学 75李四 语文 76李四 数学 90王五 语文 81王五 数学 100王五 英语 901select name from table group by name having min(fenshu)&gt;80 学生表 如下:自动编号 学号 姓名 课程编号 课程名称 分数1 2005001 张三 0001 数学 692 2005002 李四 0001 数学 893 2005001 张三 0001 数学 69删除除了自动编号不同, 其他都相同的学生冗余信息 A: delete tablename where 自动编号 not in(select min( 自动编号) from tablename group by学号, 姓名, 课程编号, 课程名称, 分数) limit offset 查找入职员工时间排名倒数第三的员工所有信息1select * from employees order by hire_date desc limit 1 offset 2; join查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_noCREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 123select salaries.emp_no,salaries.salary,salaries.from_date,salaries.to_date,dept_manager.dept_nofrom salaries join dept_manager on dept_manager.emp_no = salaries.emp_nowhere salaries.to_date = '9999-01-01' and dept_manager.to_date = '9999-01-01';","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"常考语句","slug":"常考语句","permalink":"http://yoursite.com/tags/常考语句/"}]},{"title":"【c#】","slug":"【c-】","date":"2019-06-29T11:19:09.000Z","updated":"2019-06-29T11:36:23.596Z","comments":true,"path":"2019/06/29/【c-】/","link":"","permalink":"http://yoursite.com/2019/06/29/【c-】/","excerpt":"","text":"lambda简化了匿名委托的使用；lambda运算符：所有的lambda表达式都是用新的lambda运算符 “ =&gt; “,可以叫他，“转到”或者 “成为”。运算符将表达式分为两部分，左边指定输入参数，右边是lambda的主体。 lambda表达式：1.一个参数：param=&gt;expr2.多个参数：（param-list）=&gt;expr","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"lambd","slug":"lambd","permalink":"http://yoursite.com/tags/lambd/"}]},{"title":"【红黑树】","slug":"【红黑树】","date":"2019-06-29T08:20:39.000Z","updated":"2019-06-29T11:17:24.473Z","comments":true,"path":"2019/06/29/【红黑树】/","link":"","permalink":"http://yoursite.com/2019/06/29/【红黑树】/","excerpt":"","text":"二叉树链接特点由二叉树定义以及图示分析得出二叉树有以下特点：1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。2）左子树和右子树是有顺序的，次序不能任意颠倒。3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 性质1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;(2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；(3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。满二叉树满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。满二叉树的特点有：1）叶子只能出现在最下一层。出现在其它层就不可能达成平衡。2）非叶子结点的度一定是2。3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。完全二叉树1）叶子结点只能出现在最下层和次下层。2）最下层的叶子结点集中在树的左部。3）倒数第二层若存在叶子结点，一定在右部连续位置。4）如果结点度为1，则该结点只有左孩子，即没有右子树。5）同样结点数目的二叉树，完全二叉树深度最小。注：满二叉树一定是完全二叉树，但反过来不一定成立。 遍历见链接 知乎链接 BST二叉搜索树AVL平衡二叉搜索树特点（1）非叶子节点最多拥有两个子节点； （2）非叶子节值大于左边子节点、小于右边子节点； （3）树的左右两边的层级数相差不会大于1; （4）没有值相等重复的节点; B树(B-tree) B树特点 B树性质 B树结构 B树查找 B树插入、删除分裂和借兄弟合并 B+ 树 B+树的特点 B+树的结构 B+树的查找一直查到叶节点； B+树的特点 B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快； B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定; B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。 B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。 红黑树用途1）广泛应用在 C++ 的 STL 中，如 map 和 set 都是用红黑树实现的。2）linux 进程调度，用红黑树管理进程控制块3）epoll 在内核中的实现，用红黑树管理事件块4）nginx 中，用红黑树管理 timer 等特征阶特征(1) 红黑树是满二叉树 空叶结点也看作结点(2) 阶为 k 的红黑树路径长度 最短是 k，最长是 2k(2)’ 阶为 k 的红黑树树高最小是 k+1，最高是 2k+1(3) 阶为k的红黑树的内部结点最少是一棵完全满二叉树，内部结点数最少是 2k-1(4) n 个内部结点的红黑树树高最大是 2 log2(n+1)+插入、删除解决冲突，重构或者换色","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"各种树","slug":"各种树","permalink":"http://yoursite.com/tags/各种树/"}]},{"title":"【数据库】","slug":"【数据库】","date":"2019-06-26T13:52:30.000Z","updated":"2019-07-13T15:41:36.909Z","comments":true,"path":"2019/06/26/【数据库】/","link":"","permalink":"http://yoursite.com/2019/06/26/【数据库】/","excerpt":"","text":"索引数据库索引 https://www.cnblogs.com/s-b-b/p/8334593.html 联合索引联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。最左前缀匹配 对于一个联合索引，如果有一个SQL查询语句需要执行，则只有从索引最左边的第一个字段开始到SQL语句查询条件中不包含的字段（不含）或范围条件字段（含）为止的部分才会使用索引进行加速。 范围查询条件 聚集索引数据会根据索引中的顺序进行排列和组织的，这样的索引就被称为聚集索引，而非聚集索引就是其他的一般索引。因为数据只能按照一种规则排序，所以一张表至多有一个聚集索引，但可以有多个非聚集索引。B+ 树。在B+树中，每一个节点里都有N个按顺序排列的值，且每个值的中间和节点的头尾都有指向下一级节点的指针。在查找过程中，按顺序从头到尾遍历一个节点中的值，当发现要找的目标值恰好在一个指针的前一个值之前、后一个值之后时，就通过这个指针进入下一级节点。当最后到达叶子节点，也就是最下层的节点时，就能够找到自己希望查找的数据记录了。 非聚集索引而从非聚集索引的叶子节点链接到聚集索引的叶子节点查询实际数据的过程就叫做——回表。 全覆盖索引不需要回表；全覆盖索引可以节约回表的开销这一点在一些回表开销很大的情况下就非常重要了 为什么用B+ 树 不用二叉树 二分法，查找效率高 所以对于数据库索引来说，因为数据量很大，所以基本都是保存在外存中的，这样的话数据库读取一个索引节点的成本就非常大了。在数据量一样大的情况下，我们可以知道，B+树的单个节点中包含的值个数越多那么树中需要的节点总数就会越少，这样查询一次数据需要访问的节点数就更少了。 在现代的操作系统中，把数据从外存读到内存所使用的单位一般被称为“页”，每次读取数据都需要读入整数个的“页”，而不能读入半页或者0.8页。一页的大小由操作系统决定，常见的页大小一般为4KB=4096字节。所以不管我们是要读取1字节还是2KB，最后都是需要读入一个完整的4KB大小的页的，那么一个节点的读取成本就取决于需要读入的页数。 索引分类 唯一索引唯一索引：表中的任意两行的索引值都不相等 主键索引 主键索引和唯一索引的区别： 主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键； 主键不允许为空值，唯一索引列允许空值； 一个表只能有一个主键，但是可以有多个唯一索引； 主键可以被其他表引用为外键，唯一索引列不可以； 主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的差别 复合索引复合索引，可以是唯一索引 比较详细 sql语句创建索引12CREATE INDEX index_nameON table_name (column_name) 创建唯一索引12CREATE UNIQUE INDEX index_nameON table_name (column_name) 创建复合索引12CREATE INDEX PersonIndexON Person (LastName, FirstName) 删除索引1DROP INDEX index_name ON table_name 隔离级别[参考链接]https://www.cnblogs.com/myseries/p/10748912.html 读未提交 脏读 读提交 update 不可重复读 不可重复读 insert 幻读 序列化事务的四大特性事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。acid原子性、一致性、隔离性、持久性 三大范式https://www.cnblogs.com/1906859953Lucas/p/8299959.html 第一范式*（确保每列保持原子性） 第二范式（确保表中的每列都和主键相关） 第三范式（确保每列都和主键列直接相关，而不是间接相关） varchar 和char的区别 char类型的长度是固定的，varchar的长度是可变的。 这就表示，存储字符串’abc’，使用char(10)，表示存储的字符将占10个字节（包括7个空字符） 使用varchar2(10),，则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储。 ER图ER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。 死锁https://www.jianshu.com/p/26881a1b9e30概念：多个并发进程因争夺系统资源而产生相互等待的现象。1、互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。 2、占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。3、不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。4、循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。解决办法：1、死锁预防 —– 确保系统永远不会进入死锁状态a、破坏“占有且等待”条件b、破坏“不可抢占”条件c、破坏“循环等待”条件2、避免死锁 —– 在使用前进行判断，只允许不会产生死锁的进程申请资源两种避免办法： 1、如果一个进程的请求会导致死锁，则不启动该进程 2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。3、死锁检测与解除 —– 在检测到运行系统进入死锁，进行恢复。1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。 a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。 b、逐个终止进程，直至死锁状态解除 饥饿锁用远得不到资源活锁两人争夺资源都进，都让https://blog.csdn.net/u013766342/article/details/80929719 常用语句 https://www.cnblogs.com/ieayoio/p/5293124.html删除列名alter table 表名 drop column 列名;添加列alter table tableName add columnName varchar(30)增insert into 表名 （col1，col2….coln）values(value1,value2…..valuen)；删delete from 表名 where改update 数据表 set 字段1=‘值1’,字段2=‘值2’,字段3=‘值3’ where id=你要修改的数据ID","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"},{"name":"隔离级别","slug":"隔离级别","permalink":"http://yoursite.com/tags/隔离级别/"},{"name":"常用语句","slug":"常用语句","permalink":"http://yoursite.com/tags/常用语句/"}]},{"title":"【网络】","slug":"【网络】","date":"2019-06-25T02:28:14.415Z","updated":"2019-06-26T13:51:42.975Z","comments":true,"path":"2019/06/25/【网络】/","link":"","permalink":"http://yoursite.com/2019/06/25/【网络】/","excerpt":"","text":"tcp三次握手，四次挥手的具体三次握手、四次挥手 tcp、udp区别1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 5、TCP提供面向字节流的传输，它能将信息分割成组，并在接收端将其充足，UDP提供面向数据报的传输，没有分组开销 6、TCP提供拥塞控制，流量控制机制，UDP没有 滑动窗口滑动窗口协议的实现：GBN(go back to N)GBN 累计计数收到乱序的直接丢了 分组头部包含序列号 窗口如下，大小为N，最多允许N个分组未确认 ACK(n),则表示确认从开始到n（包含n）的序列号全部正确接收 会空中在传的分组设置一个Timer计时器，处理超时，如果收到了timeout(n)事件，那么会重传的是n以及n以后的所有分组（尽管后面的可能已经收到了，这就是回退，回退到n开始传，GBN） 接收方会有一个期望序列号，如果收到的不是期望的分组，直接丢弃 SR(select repeat)多了一个接收方的窗口发送方窗口和接收窗口不同步的 GBN缺陷，累积确认机制导致回退到N，重复传了很多。解决这个。 1.对每个分组分别确认，不再只接收期望的，接到不期望的，就先缓存（设置缓存机制），接到期望的才交付上层 2.发送方只需要重传那些没收到ACK的分组了 3.产生了接收方窗口（GBN只有发送方窗口），用来缓存，现在有两窗口了 4.序列号的位数是K的话，那么得满足 接收方窗口大小N+发送方N&lt;= 2的k次方，防止因为接收方ACK丢失导致发送重发k号分组，而此时接收方滑到了新窗口，新窗口有新的k号分组（不是原来的，共用序号产生的），导致出错 tcp可靠数据传输的原理端到端，用确认重传等保证TCP协议采用累积确认机制、通常在接收端提供缓存、单一重传计时器重传具有最小序列号的那一个，并且重启计时器 快重传定时器超时之前，收到三个重复的ack，就重传 流量控制速度匹配 拥塞控制整个网络的负载带来的问题：拥塞端到端的拥塞控制加性增、乘性减、慢启动 TCP为什么可靠知乎链接 TCP超时重传，确认和重传机制 流量控制 TCP窗口会指明双方能够发送接收的最大数据量 TCP流量控制主要是针对接收端的处理速度不如发送端发送速度快的问题，消除发送方使接收方缓存溢出的可能性。 TCP流量控制主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。 拥塞控制TCP发送方可能因为IP网络的拥塞而被遏制，TCP拥塞控制就是为了解决这个问题（注意和TCP流量控制的区别）。 TCP拥塞控制的几种方法：慢启动，拥塞避免，快重传和快恢复。 慢启动 拥塞避免 加性增 快重传 快恢复 乘性减 https 的实现传纸条讲解https小灰讲解https 牛客上的https答案HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。HTTPS和HTTP的区别主要如下： 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 http\\tcpip\\socket指路链接吧了socket，tcp，http三者之间的区别和原理 网络协议 待看https://blog.csdn.net/stringNewName/article/details/72717213 session 和 cookie讲解 差异①存在的位置： cookie 存在于客户端，临时文件夹中 session：存在于服务器的内存中，一个session域对象为一个用户浏览器服务 ②安全性 cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放 session存放于服务器的内存中，所以安全性好 ③网络传输量 cookie会传递消息给服务器 session本身存放于服务器，不会有传送流量 ④生命周期(以20分钟为例) (1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束， (2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁 但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期 (3)关机会造成session生命周期的结束，但是对cookie没有影响⑤访问范围 session为一个用户浏览器独享 cookie为多个用户浏览器共享 域名解析 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。 但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。 如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址 此时LDNS再发送请求给上一步返回的gTLD 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器 Name Server根据映射关系表找到目标ip，返回给LDNS LDNS缓存这个域名和对应的ip LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束 请你说一下HTTP的报文段是什么样的？开始背 状态码状态码，100~199表示请求已收到继续处理，200~299表示成功，300~399表示资源重定向，400~499表示客户端请求出错，500~599表示服务器端出错 200：响应成功 302：跳转，重定向 400：客户端有语法错误 403：服务器拒绝提供服务 404：请求资源不存在 500：服务器内部错误","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[]},{"title":"【操作系统】进程线程","slug":"【操作系统】进程线程","date":"2019-06-23T12:54:23.000Z","updated":"2019-06-30T12:22:38.937Z","comments":true,"path":"2019/06/23/【操作系统】进程线程/","link":"","permalink":"http://yoursite.com/2019/06/23/【操作系统】进程线程/","excerpt":"","text":"指路链接吧，讲的太好了分享链接 进程线程 进程：程序的一次执行 线程：CPU的基本调度单位 自己的感悟：线程是我们自己设计的，一个程序中可以开启多个线程去干活，这样快很多，但是必要的时候为了保证线程安全，就得加锁；进程，通常是操作系统调度的； 进程是并行，线程并发 进程之间通信参考链接，链接进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 线程和进程的堆栈线程有栈，进程有堆 静态存储区、堆区和栈区可编程内存在基本上分为这样的几大部分：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。 栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，否则，我们认为发生了内存泄漏现象。 线程、协程、进程机器人解释coroutine可以认为是单线程多任务的工作方式(当然，进程中实现coroutine也是可以的)，因为它在单个线程中的多个任务之间直接跳转，而多线程是通过上下文切换来实现多任务的。换句话说，coroutine提供了并发却不并行的功能。通过coroutine，还能实现更为”实时”的上下文任务，因为coroutine之间的跳转切换不需要任何系统调用和可能的阻塞调用，不需要像多线程一样为了线程之间的资源同步而使用额外的互斥锁、信号量等。协程线程区别而协程与线程主要的区别有两个，最大的就是调度方式，线程是操作系统调度，协程是应用系统自己调度。 另外一个区别，协程的栈空间是可以动态调整的，这样空间利用率就可以更高，一个任务需要2K空间就分配2K内存，一个任务需要20M空间就分配20M，而不用担心栈空间不够或者空间浪费。 由于上面的两个原因，协程的优势也就凸显出来。 协程可以更好的利用CPU，不用把CPU浪费在线程调度和上下文切换上。 协程可以更好的利用内存，不用全都分配一个偏大的空间，只需要分配需要的对应空间即可。 多线程单线程 多线程的产生并不是因为发明了多核CPU甚至现在有多个CPU+多核的硬件，也不是因为多线程CPU运行效率比单线程高。单从CPU的运行效率上考虑，单任务进程及单线程效率是最高的，因为CPU没有任何进程及线程的切换开销， 实际上，多线程的出现主要为了解决IO设备的读写速度往往比CPU的处理速度慢造成的单线程程序运行阻塞问题，一个极端的例子就是如果你需要用户在键盘上输入一个数据，当用户没有输入前，单线程程序就阻塞了，多线程程序就可以放个音乐或继续干一些程序中除了键盘输入外的工作，因此，多线程能提高因程序由于等待某个资源阻塞时其他资源的利用率（是利用率不是效率）。 因此多线程与单线程的最大区别，多线程程序能在等待某个IO操作时，继续完成非这个IO的其他工作，有利于提高完成整个任务的效果和速度。此外，多线程程序与单线程程序对程序设计也有不同的流程和结构，多线程需要考虑对静态变量等资源的操作互锁及程序执行的同步问题。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"},{"name":"进程","slug":"进程","permalink":"http://yoursite.com/tags/进程/"}]},{"title":"【Linux】","slug":"【Linux】","date":"2019-06-23T05:41:47.000Z","updated":"2019-08-21T06:48:16.789Z","comments":true,"path":"2019/06/23/【Linux】/","link":"","permalink":"http://yoursite.com/2019/06/23/【Linux】/","excerpt":"","text":"常用语法 查看进程ps -ef//-e显示系统内的所有进程信息。-f使用完整的（full）格式显示进程信息。ps -ef -a的详细说明https://www.cnblogs.com/ericli-ericli/p/8144934.html 杀死进程kill -15 //正常退出kill -9 //强制退出 怎么批量杀死进程，ps aux|grep python|grep -v grep|cut -c 9-15|xargs kill -15 看进程号ps -a | grep “cmdname” 批量替换指定文件夹中所有文件的指定内容命令：sed -i “s/查找字段/替换字段/g” grep 查找字段 -rl 路径 文件名功能：用来替换当前目录VEROMODA文件夹及子文件夹中所有文件中的https为http. 说明： -i 表示inplace edit，就地修改文件 -r 表示搜索子目录 -l 表示输出匹配的文件名 linux 下查找一个目录下带指定字符的文件grep -r “test” /data/reports Linux查看磁盘空间大小命令df -hl 查看硬盘的分区：fdisk -l 修改文件的权限最高位7是设置文件所有者访问权限，第二位是设置群组访问权限，最低位是设置其他人访问权限。 其中每一位的权限用数字来表示。具体有这些权限：r(Read，读取，权限值为4)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目 录的权限。w(Write,写入，权限值为2)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。x(eXecute，执行，权限值为1)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。 ifconfig 显示或设置网络设备。 grep 搜索https://www.cnblogs.com/zhangyuhang3/p/6873900.html find Linux命令https://www.cnblogs.com/yuanfei1110111/p/10135765.html格式：find path option filepath：查找的目录路径option：按什么进行查找file： 查找的文件特征 查看文件内容cat wc命令用于计算字数 linux基础数据库基础https://blog.csdn.net/qq_38358499/article/details/83242140","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"【Leetcode】918. 环形子数组的最大和","slug":"【Leetcode】918-环形子数组的最大和","date":"2019-06-22T07:09:20.000Z","updated":"2019-06-22T07:29:01.555Z","comments":true,"path":"2019/06/22/【Leetcode】918-环形子数组的最大和/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】918-环形子数组的最大和/","excerpt":"","text":"题目 环形子数组的最大和给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。 在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，而当 i &gt;= 0 时 C[i+A.length] = C[i]） 此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length） 案例示例 1:123输入：[1,-2,3,-2]输出：3解释：从子数组 [3] 得到最大和 3 示例2：123输入：[5,-3,5]输出：10解释：从子数组 [5,5] 得到最大和 5 + 5 = 10 示例3：123输入：[3,-1,2,-1]输出：4解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4 -30000 &lt;= A[i] &lt;= 300001 &lt;= A.length &lt;= 30000 思路 首先处理没有延长的情况，就正常寻找最大的值； 对于有延长的情况，只要用求和的减去连续数组的最小值即可； 但是要考虑是不是全是负数，因为全是负数的话，考虑延长的结果就是0了；代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int maxSubarraySumCircular(vector&lt;int&gt;&amp; A) &#123; bool flag = false; int sum = 0, amax = A[0]; //考虑是不是负数，并且找到最大值 for(auto a : A)&#123; if(a &gt; 0) flag = true; sum += a; amax = max(a,amax); &#125; if(!flag)&#123; return amax; &#125; int res = INT_MIN; int res_max = INT_MIN; int res_min = INT_MAX; int n = A.size(); int tem_max = A[0], tem_min = A[0]; //分别找到最大值和最小值 for(int i = 1;i &lt; n; i++)&#123; if(tem_max + A[i] &gt; A[i])&#123; tem_max = tem_max + A[i]; &#125;else&#123; tem_max = A[i]; &#125; res_max = max(res_max,tem_max); if(tem_min + A[i] &lt; A[i])&#123; tem_min = tem_min + A[i]; &#125;else&#123; tem_min = A[i]; &#125; res_min = min(res_min,tem_min); &#125; //求和减去最小值 int res2 = sum - res_min; res = max(res2,res_max); return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组 - 中等 - 双指针","slug":"数组-中等-双指针","permalink":"http://yoursite.com/tags/数组-中等-双指针/"}]},{"title":"【Leetcode】31. 下一个排列","slug":"【Leetcode】31-下一个排列","date":"2019-06-22T06:13:28.000Z","updated":"2019-06-22T06:27:02.685Z","comments":true,"path":"2019/06/22/【Leetcode】31-下一个排列/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】31-下一个排列/","excerpt":"","text":"题目 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 案例示例 1:1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路 从后往前找，首先找到第一个逆序的位置 如果不存在逆序的位置，就直接把顺序改变，得到最小的； 再从后往前遍历，找到第一个比当前的大的，然后交换后，再排序；代码 12345678910111213141516171819class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; //找第一个不顺序的数 int i = nums.size() - 1; for(i; i &gt; 0; i--)&#123; if(nums[i] &gt; nums[i - 1]) break; &#125; if(i == 0) return sort(nums.begin(),nums.end()); int j = nums.size() - 1; for(j; j &gt;= i; j--)&#123; if(nums[j] &gt; nums[i - 1]) break; &#125; swap(nums[j],nums[i - 1]); sort(nums.begin()+i, nums.end()); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】27. 移除元素","slug":"【Leetcode】27-移除元素","date":"2019-06-22T06:04:30.000Z","updated":"2019-06-22T06:05:56.386Z","comments":true,"path":"2019/06/22/【Leetcode】27-移除元素/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】27-移除元素/","excerpt":"","text":"题目 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 案例示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 思路 从前向后遍历，利用两个指针，一个指针遍历，一个指针用来存储当前的有效的位置； 代码123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int i = 0; for(int j = 0; j &lt; nums.size(); j++)&#123; if(nums[j] != val)&#123; nums[i++] = nums[j]; &#125; &#125; return i; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组 - 中等 - 双指针","slug":"数组-中等-双指针","permalink":"http://yoursite.com/tags/数组-中等-双指针/"}]},{"title":"【Leetcode】26. 删除排序数组中的重复项","slug":"【Leetcode】26-删除排序数组中的重复项","date":"2019-06-22T05:59:57.000Z","updated":"2019-06-22T06:03:29.869Z","comments":true,"path":"2019/06/22/【Leetcode】26-删除排序数组中的重复项/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】26-删除排序数组中的重复项/","excerpt":"","text":"题目 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 案例示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 思路 从前向后遍历，利用两个指针，一个指针遍历，一个指针用来存储当前的有效的位置； 代码12345678910111213class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; int i = 1, t = nums[0]; for(int j = 1; j &lt; nums.size();j++)&#123; if(nums[j] != nums[j - 1])&#123; nums[i++] = nums[j]; &#125; &#125; return i; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】18. 四数之和","slug":"【Leetcode】18-四数之和","date":"2019-06-21T10:10:35.000Z","updated":"2019-06-21T10:15:16.625Z","comments":true,"path":"2019/06/21/【Leetcode】18-四数之和/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】18-四数之和/","excerpt":"","text":"题目 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意 答案中不可以包含重复的四元组。 案例示例 1:12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路和题目【Leetcode】15-3Sum比较相近； 将数组排序； 降为三维； 不同的是不用去做判断break,因为有负数； 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt;res; sort(nums.begin(),nums.end()); for(int i = 0; i &lt; nums.size(); i++)&#123; //if(nums[i] &gt; target) break;//没有的 if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; for(int j = i + 1; j &lt; nums.size(); j++)&#123; //if(nums[j] &gt; target) break;//没有的 if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int t = target - nums[i] - nums[j]; int left = j + 1,right = nums.size() - 1; while(left &lt; right)&#123; int sum = nums[left] + nums[right]; if(sum == t)&#123; res.push_back(&#123;nums[i],nums[j],nums[left],nums[right]&#125;); while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++,right--; &#125;else if(sum &lt; t) left++; else right--; &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】16. 最接近的三数之和","slug":"【Leetcode】16-最接近的三数之和","date":"2019-06-21T10:04:31.000Z","updated":"2019-06-21T10:09:09.797Z","comments":true,"path":"2019/06/21/【Leetcode】16-最接近的三数之和/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】16-最接近的三数之和/","excerpt":"","text":"题目 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 案例示例 1:123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 思路和题目【Leetcode】15-3Sum比较相近； 将数组排序； 不段的比较，找到最小的 注意，仍然用双指针方法，这样不会丢解，因为是在不短的像target靠近；代码 12345678910111213141516171819202122class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int dif = INT_MAX,res = 0; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++)&#123; int left = i + 1, right = nums.size() - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[left] + nums[right]; int diff = abs(sum - target); if(diff &lt; dif)&#123; dif = diff; res = sum; &#125; // res = min(res,diff); if (sum &lt; target) left++; else right--; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】11.盛最多水的容器","slug":"【Leetcode】11-盛最多水的容器","date":"2019-06-21T09:41:51.000Z","updated":"2019-06-21T09:58:58.725Z","comments":true,"path":"2019/06/21/【Leetcode】11-盛最多水的容器/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】11-盛最多水的容器/","excerpt":"","text":"题目 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 案例12![示例](【Leetcode】11-盛最多水的容器/figure.jpg)图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 思路利用双指针，移动的是盛水少的指针，最后跳出循环，得到最终结果； 代码1234567891011121314class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int left = 0, right = height.size() - 1; int res = 0; while(left &lt; right)&#123; int l = height[left], r = height[right]; res = max(min(l,r)*(right - left),res); if(l &lt; r) left++; else right--; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"mk的一些常见的语法“ ","slug":"mk的一些常见的语法“","date":"2019-05-30T14:11:56.000Z","updated":"2019-05-30T14:17:20.392Z","comments":true,"path":"2019/05/30/mk的一些常见的语法“/","link":"","permalink":"http://yoursite.com/2019/05/30/mk的一些常见的语法“/","excerpt":"","text":"插入图片! + [[内容]] + ( ) 字体加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 超链接语法： [超链接名]+(超链接地址 +”超链接title”)title可加可不加 列表 无序列表语法：无序列表用 - + * 任何一种都可以 有序列表语法：数字加点","categories":[{"name":"MK","slug":"MK","permalink":"http://yoursite.com/categories/MK/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"【Leetcode】12. 整数转罗马数字","slug":"【Leetcode】12-整数转罗马数字","date":"2019-05-30T13:01:23.000Z","updated":"2019-05-30T13:05:17.631Z","comments":true,"path":"2019/05/30/【Leetcode】12-整数转罗马数字/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】12-整数转罗马数字/","excerpt":"","text":"题目 整数转罗马数字罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 案例示例 1:12输入: 3输出: &quot;III&quot; 示例 2:12输入: 4输出: &quot;IV&quot; 思路先将所有的对应表列好，每次通过查表找出当前最大的数，减去再继续查表 代码123456789101112131415class Solution &#123;public: string intToRoman(int num) &#123; string res = \"\"; vector&lt;int&gt; val = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; vector&lt;string&gt; s = &#123;\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"&#125;; for(int i = 0; i &lt; val.size(); i++)&#123;//这个for和while很巧妙 while(num &gt;= val[i])&#123; num -= val[i]; res += s[i]; &#125; &#125; return res; &#125;&#125;; 需要记住的点 这个for和while用的很巧妙；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"【Leetcode】8. 字符串转换整数 (atoi)” ","slug":"【Leetcode】8-字符串转换整数-atoi-”","date":"2019-05-30T12:10:52.538Z","updated":"2019-05-30T13:01:33.553Z","comments":true,"path":"2019/05/30/【Leetcode】8-字符串转换整数-atoi-”/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】8-字符串转换整数-atoi-”/","excerpt":"","text":"题目 Z 字形变换请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 案例示例 1:12输入: &quot;42&quot;输出: 42 示例 2:1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 思路首先排除空字符，然后看符号，然后看数字，注意，判断数字要考虑可能越界问题，采用INT_MACX/10，作为判断是不是会越界；具体看代码；这道题主要学习代码简洁性，以及判断越界的方法； 代码1234567891011121314151617181920cclass Solution &#123;public: int myAtoi(string str) &#123; int flag = 1, res = 0,n = str.length(),i = 0; while(i &lt; n &amp;&amp; str[i] == ' ')&#123; i++; &#125; if(str[i] == '+' || str[i] == '-')&#123; flag = str[i++] == '+' ? 1 : -1; &#125; while(i &lt; n &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')&#123; int tem = str[i++] - '0'; if(res &gt; INT_MAX/10 || (res == INT_MAX/10 &amp;&amp; tem &gt;= 8))&#123; return flag == 1 ? INT_MAX : INT_MIN; &#125; res = res * 10 + tem; &#125; return flag * res; &#125;&#125;; 需要记住的点 INT_MAX/10，并要判断等于的情况，等于的情况要分为大不大于8；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】6. Z 字形变换","slug":"【Leetcode】6-Z-字形变换","date":"2019-05-30T07:52:03.146Z","updated":"2019-05-30T08:01:57.308Z","comments":true,"path":"2019/05/30/【Leetcode】6-Z-字形变换/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】6-Z-字形变换/","excerpt":"","text":"题目 Z 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 案例示例 1:12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2:12345678输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L D RE O E I IE C I H NT S G 思路可以看出是有规律可循的，我们发现，周期为2nRows - 2, 根据这个特点，我们可以按顺序找到所有的黑色元素在元字符串的位置，将他们按顺序加到新字符串里面。对于红色元素出现的位置也是有规律的，每个红色元素的位置为 j + 2nRows-2 - 2i, 其中，j为前一个黑色元素的列数，i为当前行数。 比如当n = 4中的那个红色5，它的位置为 1 + 24-2 - 2*1 = 5，为原字符串的正确位置。因为相当于加了一个周期再折回来，当我们知道所有黑色元素和红色元素位置的正确算法，我们就可以一次性的把它们按顺序都加到新的字符串里面 代码12345678910111213141516class Solution &#123;public: string convert(string s, int nRows) &#123; if (nRows &lt;= 1) return s; string res = \"\"; int size = 2 * nRows - 2; for (int i = 0; i &lt; nRows; ++i) &#123; for (int j = i; j &lt; s.size(); j += size) &#123; res += s[j]; int tmp = j + size - 2 * i; if (i != 0 &amp;&amp; i != nRows - 1 &amp;&amp; tmp &lt; s.size()) res += s[tmp];//关键的地方 &#125; &#125; return res; &#125;&#125;; 需要记住的点 规律很好，时间复杂度就是变成n；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】5. 最长回文子串","slug":"【Leetcode】5-最长回文子串","date":"2019-05-27T14:35:14.716Z","updated":"2019-05-27T14:48:49.869Z","comments":true,"path":"2019/05/27/【Leetcode】5-最长回文子串/","link":"","permalink":"http://yoursite.com/2019/05/27/【Leetcode】5-最长回文子串/","excerpt":"","text":"题目 无重复字符的最长子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 案例示例 1:123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2:12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 思路遍历每个字符，然后获取这个字符作为中间的最长的回文串；再去更新结果；分为两种情况，回文串为奇数和偶数两种情况；具体代码如下； 代码123456789101112131415161718192021class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; int n = s.size(), maxLen = 0, start = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; searchPalindrome(s, i, i, start, maxLen); searchPalindrome(s, i, i + 1, start, maxLen); &#125; return s.substr(start, maxLen); &#125; void searchPalindrome(string s, int left, int right, int&amp; start, int&amp; maxLen) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; if (maxLen &lt; right - left - 1) &#123; start = left + 1; maxLen = right - left - 1; &#125; &#125;&#125;; 需要记住的点 很巧妙的用了引用；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】3. 无重复字符的最长子串","slug":"【Leetcode】3-无重复字符的最长子串","date":"2019-05-27T13:59:22.000Z","updated":"2019-05-27T14:09:33.416Z","comments":true,"path":"2019/05/27/【Leetcode】3-无重复字符的最长子串/","link":"","permalink":"http://yoursite.com/2019/05/27/【Leetcode】3-无重复字符的最长子串/","excerpt":"","text":"题目 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。 案例示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路建立一个HashMap，建立每个字符和其最后出现位置之间的映射，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置的前一个，由于是前一个，所以初始化就是-1，然后我们遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在HashMap中存在了，并且如果其映射值大于left的话，那么更新left为当前映射值。然后映射值更新为当前坐标i，这样保证了left始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用i-left即可，用来更新结果res。几个比较关键的点： left初始值设为1，因为我们定义left是当前窗口的前一个值；代码 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0, left = -1, n = s.size(); unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; n; ++i) &#123; if (m.count(s[i]) &amp;&amp; m[s[i]] &gt; left) &#123;//比较精华的一句话 left = m[s[i]]; &#125; m[s[i]] = i; res = max(res, i - left); &#125; return res; &#125;&#125;; 需要记住的点 unordered_map查找，用m.count(val); 包含再头文件unordered_map中；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/滑动窗口/"}]},{"title":"排序算法","slug":"排序算法“","date":"2019-05-04T12:30:21.000Z","updated":"2019-07-24T02:07:00.022Z","comments":true,"path":"2019/05/04/排序算法“/","link":"","permalink":"http://yoursite.com/2019/05/04/排序算法“/","excerpt":"","text":"每一种排序算法都有必须存在的理由； 选择排序 时间复杂度：n^2，最好的最坏的情况都是； 不需要额外的空间； 不稳定；代码：123456789101112void helper(vector&lt;int&gt; &amp;b)&#123; int n = b.size(); for(int i = 0; i &lt; n; i++)&#123; int index = i; for(int j = i + 1; j &lt; n; j++)&#123; if(b[j] &lt; b[index])&#123; index = j; &#125; &#125; swap(b[i],b[index]); &#125;&#125; 冒泡排序冒泡排序的思想是，从第0个元素到第n-1个元素遍历，若前面一个元素大于后面一个元素，则交换两个元素，这样可将整个序列中最大的元素冒泡到最后，然后再从第0个到第n-2遍历，如此往复，直到只剩一个元素。 时间复杂度：n^2，最好的最坏的情况都是； 不需要额外的空间； 不稳定 好在可以在内层循环中设置一个flag,如果在当前的循环中从来没有进行过交换，那么说明内部已经是完全有序的了，那么这种情况，最好的情况是时间复杂度为n;代码：123456789101112131415void helper(vector&lt;int&gt; &amp;b)&#123; int n = b.size(); for(int i = n - 1; i &gt; 0; i--)&#123; bool flag = false; for(int j = 0; j &lt; i; j++)&#123; if(b[j] &gt; b[j + 1])&#123; flag = true; swap(b[j], b[j+1]); &#125; &#125; if(!flag)&#123; break; &#125; &#125;&#125; 123456789101112void Bubble_Sort( ElementType A[], int N )&#123; for ( P=N-1; P&gt;=0; P-- )&#123; flag = 0; for( i=0; i&lt;P; i++ ) &#123; /* 一趟冒泡 */ if ( A[i] &gt; A[i+1] ) &#123; Swap(A[i], A[i+1]); flag = 1; /* 标识发生了交换 */ &#125; &#125; if ( flag==0 ) break; /* 全程无交换 */ &#125;&#125; 插入排序插入排序的思想是，像抓扑克牌一样，不断的将一张牌插入到已经排序好的数组中；从有序的最后比较； 时间复杂度：最坏n^2，最好n,取决于逆序对的数量； 不需要额外的空间； 现在一次只能消除一个逆序对，想法就是一次多消除几个逆序对；代码：123456789void Insertion_Sort( ElementType A[], int N ) &#123; for(int P = 1; P &lt; N; P++)&#123; int tem = A[P];//抓牌 for(int i = P; i &gt; 0 &amp;&amp; tem &lt; A[i - 1]; i--)&#123; A[i] = A[i - 1];//找位置 &#125; A[i] = tem; &#125;&#125; 当我们每次需要多消除几个逆序对的想法出现的时候，就变成了希尔排序； 希尔排序希尔排序的思想是，保证K个间隔是有序的 定义增量序列DM &gt;DM-1 &gt;…&gt;D1 =1 对每个 Dk 进行“Dk-间隔”排序( k = M, M-1, … 1 ) 注意:“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk- 间隔”有序的 几种增量序列 原始增量序列DM =N/2, Dk =Dk+1/2代码：1234567891011void Shell_sort( ElementType A[], int N )&#123; for(int D = N/2; D &gt; 0; D /= 2 )&#123; for(int P = D; P &lt; N; P ++)&#123; int tem = A[P]; for(int i = P; i &gt;0 &amp;&amp; tem &lt; A[i - D]; i -= D)&#123; A[i] = A[i - D]; &#125; A[i] = tem; &#125; &#125;&#125; 可能会导致很大的问题，比如下面的情况相当于白跑很多趟，只有最后一趟有用，坏的是O(N^2) Hibbard 增量序列Dk =2k –1 —相邻元素互质 最坏情况:T=O(N3/2 ) 猜想:Tavg =O(N5/4 ) Sedgewick增量序列 {1, 5, 19, 41, 109, … }—9+4^i–9+2^i +1或4^i–3*2^i+1 猜想:Tavg =O(N7/6 )，Tworst =O(N4/3 ) 堆排序思想就是，在选择排序的基础上，把每次找最小元的事情交给堆；但是因为选择排序的，每次是N的复杂度去找最小元； 首先建立最大堆； 每次交换根节点和头节点； 向下过滤，调整成最大堆； 不断的交换； 最小堆 建立最小堆； 每次从头部弹出一个； 然后重开一个数组；T(N)=O(N logN)1234567void Heap_Sort ( ElementType A[], int N )&#123; BuildHeap(A); /* O(N) */&#125;for ( i=0; i&lt;N; i++ ) TmpA[i] = DeleteMin(A); /* O(logN) */for ( i=0; i&lt;N; i++ ) /* O(N) */ A[i] = TmpA[i]; 归并排序排两个有序子列T ( N ) = O( N ) 快速排序分而治之，选主元，大于主元，小于主元，底层是N是1的时候直接就返回了；快在每次主元一次性的换到了正确的位置；问题 选主元； 怎么分最好情况每次正好中分 T(N) = O(NlogN） 不好的情况 本来就是有顺序的，然后选了主元为第一个，结果是N^2； 是递归的，不断的进栈，大规模的时候可以，小规模的时候就没必要了； 步骤 选三个的中位数； 换到right-1; 子集划分 选定主元后； 两个指针i,j，如果i小于主元，那么直接走，直到i大于位置；然后开始j–,直到j小于主元为止，最后的限制条件是i&lt;j; 最终i的位置就是主元的位置； 极端情况如果是全相等的序列的话，如果停下来交换，最终主元是会被放在中间位置；O(NlogN）但是如果是继续向前，最终主元就是倒数第一个位置，导致N^2;程序123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void quicksort(vector&lt;int&gt; &amp;arr, int l, int r);int main()&#123; vector&lt;int&gt; arr&#123;2,1,4,3&#125;; quicksort(arr,0,3); for(int i = 0; i &lt; 4; i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;endl; &#125;&#125;void quicksort(vector&lt;int&gt; &amp;arr, int l, int r)&#123; if(l &gt; r) return; int t = arr[l], index = l,end = r; l = l + 1; while(l &lt;= r)&#123; while(l &lt;= r &amp;&amp; arr[l] &lt; t) l++; while(l &lt;= r &amp;&amp; arr[r] &gt; t) r--; if(l &lt; r) swap(arr[l],arr[r]); &#125; swap(arr[r],arr[index]); quicksort(arr, index, r -1); quicksort(arr, r+1, end);&#125; 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void helper(vector&lt;int&gt;&amp;arr,int l,int r);int main()&#123; vector&lt;int&gt; arr&#123;2,1,4,3&#125;; int l = 0, r = arr.size()-1; helper(arr,l,r); for(int a:arr)&#123; cout&lt;&lt;a&lt;&lt;endl; &#125;&#125;void helper(vector&lt;int&gt;&amp;arr,int l,int r)&#123; //选主元 if(l == r || l &gt; r) return; int mid = l + (r - l)/2; if(arr[l] &gt; arr[mid]) swap(arr[l],arr[mid]); if(arr[mid] &gt; arr[r]) swap(arr[mid],arr[r]); if(arr[l] &gt; arr[mid]) swap(arr[mid],arr[l]); swap(arr[r - 1],arr[mid]); //找主元 int i = l + 1, j = r - 2; while(i &lt; j)&#123; while(i &lt; j &amp;&amp; arr[i] &lt; arr[r-1]) i++; while(i &lt; j &amp;&amp; arr[j] &gt; arr[r-1]) j--; if(i &lt; j) swap(arr[i], arr[j]); &#125; if(r-1 &gt; i) swap(arr[r - 1],arr[i]);//一定要判断 helper(arr,l,i - 1); helper(arr,i + 1,r);&#125; 非递归排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;stack&gt;#include&lt;vector&gt;using namespace std;int helper(vector&lt;int&gt;&amp;arr,int l,int r);int main()&#123; vector&lt;int&gt; arr&#123;2,1,4,3&#125;; int l = 0, r = arr.size()-1; stack&lt;int&gt; s; s.push(l); s.push(r); while(!s.empty())&#123; int right = s.top(); s.pop(); int left = s.top(); s.pop(); if(left &lt; right)&#123; int p = helper(arr,left, right); s.push(left); s.push(p - 1); s.push(p+1); s.push(right); &#125; &#125; for(auto a : arr)&#123; cout&lt;&lt;a&lt;&lt;endl; &#125;&#125;int helper(vector&lt;int&gt;&amp;arr,int l,int r)&#123; int mid = l + (r - l)/2; if(arr[l] &gt; arr[mid]) swap(arr[l],arr[mid]); if(arr[mid] &gt; arr[r]) swap(arr[mid],arr[r]); if(arr[l] &gt; arr[mid]) swap(arr[mid],arr[l]); swap(arr[r - 1],arr[mid]); //找主元 int i = l + 1, j = r - 2; while(i &lt; j)&#123; while(i &lt; j &amp;&amp; arr[i] &lt; arr[r-1]) i++; while(i &lt; j &amp;&amp; arr[j] &gt; arr[r-1]) j--; if(i &lt; j) swap(arr[i], arr[j]); &#125; if(r-1 &gt; i) swap(arr[r - 1],arr[i]); return i;&#125; 表排序待排的是一个结构体，因为要频繁的移动，移动指针；定义一个指针数组；插入排序； 基数排序 桶排序 基数排序“次位优先”先排个位数 基数排序–多关键字 各种比较","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"【Leetcode】15. 3Sum","slug":"【Leetcode】15-3Sum","date":"2019-05-03T10:27:07.000Z","updated":"2019-06-21T07:24:30.128Z","comments":true,"path":"2019/05/03/【Leetcode】15-3Sum/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】15-3Sum/","excerpt":"","text":"题目 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。案例示例 1:1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路 将数组排序； 遍历数组，利用双指针的方法去找两个数的和相加是当前数的相反数的情况，见题目（）； 几点注意，因为题目中要求不能有重复的结果，重复的结果可能出现在两个地方，首先是，遍历的时候已经找到过的组合，还有就是对当前遍历到的数字，可能存在两种相同的组合；对两种情况进行排除即可。代码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; int n = nums.size(); if(n &lt;= 2) return result; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int t = nums[i]; if(i &gt; 0 &amp;&amp; t == nums[i - 1]) continue; if(t &gt; 0) break; else&#123; int tem = -t; int l = i + 1, r = n - 1; while(l &lt; r)&#123; if(nums[l] + nums[r] == tem) &#123; result.push_back(&#123;t,nums[l],nums[r]&#125;); while(l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++;//记住是为什么，是为了排除重复，而且有条件限制，所以不会在l+1处出问题 while(l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; &#125; else if(nums[l] + nums[r] &gt; tem) r--; else if(nums[l] + nums[r] &lt; tem) l++; &#125; &#125; &#125; return result; &#125; &#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】4. Median of Two Sorted Arrays","slug":"【Leetcode】4-Median-of-Two-Sorted-Arrays“","date":"2019-05-03T09:32:55.000Z","updated":"2019-05-03T09:38:19.984Z","comments":true,"path":"2019/05/03/【Leetcode】4-Median-of-Two-Sorted-Arrays“/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】4-Median-of-Two-Sorted-Arrays“/","excerpt":"","text":"题目 寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 案例示例 1:123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 思路 首先题目要求时间复杂度为O(log(m + n))，那么需要用二分法，但是两个数组怎么用二分法呢； 第二点，中位数要怎么找呢，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小 trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。 需要定义一个函数来在两个有序数组中找到第K个元素； 首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组 nums1 和 nums2 的起始位置。 然后来处理一些 corner cases，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果 K=1 的话，那么我们只要比较 nums1 和 nums2 的起始位置i和j上的数字就可以了。难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，那么对谁二分呢，数组么？其实要对K二分，意思是我们需要分别在 nums1 和 nums2 中查找第 K/2 个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第 K/2 个数字，所以我们需要先 check 一下，数组中到底存不存在第 K/2 个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第 K/2 个数字，那么我们就淘汰另一个数组的前 K/2 个数字即可。举个例子来说吧，比如 nums1 = {3}，nums2 = {2, 4, 5, 6, 7}，K=4，我们要找两个数组混合中第4个数字，那么我们分别在 nums1 和 nums2 中找第2个数字，我们发现 nums1 中只有一个数字，不存在第二个数字，那么 nums2 中的前2个数字可以直接跳过，为啥呢，因为我们要求整个混合数组的第4个数字，不管 nums1 中的那个数字是大是小，第4个数字绝不会出现在 nums2 的前两个数字中，所以可以直接跳过。 最后就是二分法的核心啦，比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，如果第一个数组的第 K/2 个数字小的话，那么说明我们要找的数字肯定不在 nums1 中的前 K/2 个数字，所以我们可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2，调用递归。反之，我们淘汰 nums2 中的前 K/2 个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2代码 12345678910111213141516171819class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(), left = (m + n + 1) / 2, right = (m + n + 2) / 2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; &#125; int findKth(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt;&amp; nums2, int j, int k) &#123; if (i &gt;= nums1.size()) return nums2[j + k - 1]; if (j &gt;= nums2.size()) return nums1[i + k - 1]; if (k == 1) return min(nums1[i], nums2[j]); int midVal1 = (i + k / 2 - 1 &lt; nums1.size()) ? nums1[i + k / 2 - 1] : INT_MAX; int midVal2 = (j + k / 2 - 1 &lt; nums2.size()) ? nums2[j + k / 2 - 1] : INT_MAX; if (midVal1 &lt; midVal2) &#123; return findKth(nums1, i + k / 2, nums2, j, k - k / 2); &#125; else &#123; return findKth(nums1, i, nums2, j + k / 2, k - k / 2); &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"困难","slug":"困难","permalink":"http://yoursite.com/tags/困难/"}]},{"title":"【Leetcode】1. Two Sum","slug":"【Leetcode】1-Two-Sum","date":"2019-05-03T07:46:05.000Z","updated":"2019-06-21T09:42:18.396Z","comments":true,"path":"2019/05/03/【Leetcode】1-Two-Sum/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】1-Two-Sum/","excerpt":"","text":"题目 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 案例示例 1:123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路最开始的想法应该都是用两重循环去遍历，这样会超时；可以用空间换时间，利用哈希表map进行存储;从前向后遍历，这样可以排除自己加自己的情况； 代码12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0; i &lt; nums.size(); i++)&#123; int t = target - nums[i]; if(m.count(t))&#123; return &#123;i,m[t]&#125;; &#125; else&#123; m[nums[i]] = i; &#125; &#125; return &#123;&#125;; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"类成员可访问的情况","slug":"类成员可访问的情况","date":"2019-04-27T02:30:49.000Z","updated":"2019-04-30T01:56:33.459Z","comments":true,"path":"2019/04/27/类成员可访问的情况/","link":"","permalink":"http://yoursite.com/2019/04/27/类成员可访问的情况/","excerpt":"","text":"Private基类的Private成员可以被以下两种访问： 基类的成员函数 基类的友员函数 Protected基类的Protected成员可以被以下访问： 基类的成员函数 基类的友员函数 派生类的成员函数可以访问当前对象的基类的保护成员 Pulbic基类的Pulbic成员可以被以下访问： 基类的成员函数 基类的友员函数 派生类的成员函数 派生类的友员函数 其他函数","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"}]},{"title":"多态，虚函数，抽象类","slug":"多态，虚函数，抽象类","date":"2019-04-24T14:20:01.000Z","updated":"2019-08-15T07:43:38.432Z","comments":true,"path":"2019/04/24/多态，虚函数，抽象类/","link":"","permalink":"http://yoursite.com/2019/04/24/多态，虚函数，抽象类/","excerpt":"","text":"多态什么是多态？不同类的对同一函数的响应不同，不同类的对象的一个函数，多种实现； 目的：提供程序的可扩充性，有些语言有继承的概念但是没有多态的概念，只能称为基于对象的语言，不能称为面向对象的语言； 多态的表现形式： 派生类的指针可以赋值给基类指针；（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数;（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。举例： 12345678910111213class CBase &#123; public: virtual void SomeVirtualFunction() &#123; &#125;&#125;;class CDerived:public CBase &#123;public : virtual void SomeVirtualFunction() &#123; &#125;&#125;;int main() &#123;CDerived ODerived;CBase * p = &amp; ODerived;p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象 return 0;&#125; 派生类的对象可以赋值给基类引用；（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数;（2）若该引用引用的是派生类的对象，那么被调用的是派生类的虚函数。 虚函数在类外实现时不需要加virtual 12345678910111213class CBase &#123; public: virtual void SomeVirtualFunction() &#123; &#125;&#125;;class CDerived:public CBase &#123;public : virtual void SomeVirtualFunction() &#123; &#125;&#125;;int main() &#123; CDerived ODerived; CBase &amp; r = ODerived; r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象 return 0;&#125; 虚函数在声明成员函数的时候，加上virtual关键字，该关键字只用在类定义函数的声明中，写函数体的时候不需要；注意 构造函数和静态成员函数不能是虚函数； 虚函数和普通函数的差别在于，虚函数可以参与多态，而普通函数不能 函数重写等于覆盖，重写的函数在基类中必须是虚函数； 派生类中和基类的虚函数同名同参数的函数，不叫virtual也会自动定义为虚函数； 为什么构造函数不能是虚函数https://blog.csdn.net/jiadebin890724/article/details/7951520 构造函数和析构函数函数调用虚函数，不是多态；https://blog.csdn.net/sinat_21107433/article/details/81836602比如构造函数是多态或者调用多态，那么基类构造函数被调用时，派生类的很多东西还没初始化好，就去调用就会出问题；析构函数中也一样,先析构派生类，如果在基类中调用的是多态的话，此时派生类已经不存在了，就会出现问题； 虚函数的访问权限问题12345678910class Base &#123;private:virtual void fun2() &#123; cout &lt;&lt; \"Base::fun2()\" &lt;&lt; endl; &#125; &#125;;class Derived:public Base &#123; public:virtual void fun2() &#123; cout &lt;&lt; \"Derived:fun2()\" &lt;&lt; endl; &#125; &#125;;Derived d;Base * pBase = &amp; d;pBase -&gt; fun2(); // 编译出错 编译出错是因为fun2()是Base的私有成员。即使运行到此时实际上调用的应该是 Derived的公有成员 fun2()也不行，因为语法检查是不考虑运行结果的。如果将Base中的private换成public,即使Derived中的fun2()是private的，编译依然能通 过，也能正确调用Derived::fun2()。 一般基类的虚构函数都会写成是虚析构函数，因为要不然基类指针只会析构掉基类的，不会析构掉派生类new出来的东西；先执行派生类的析构函数，再执行基类的析构函数； 纯虚函数的实现 定义为0，但是可以在类外进行实现； 1234567891011121314151617181920class Man&#123;public: virtual void eat() = 0;&#125;;void Man::eat()&#123; cout&lt;&lt;\"base\"&lt;&lt;endl;&#125;class Woman:public Man&#123;private: void eat()&#123; cout&lt;&lt;\"woman\"&lt;&lt;endl; &#125;&#125;;int main()&#123; //Man a;//错误 //Man *a = new Man();//错误 Man *a = new Woman(); a-&gt;eat(); return 0;&#125; 纯虚函数可以定义指针和引用； 纯虚函数不可以定义对象； 包含纯虚函数的类叫抽象类； 抽象类可以调用纯虚函数，但在构造函数或者析构函数内部不可以调用纯虚函数； 如果一个类从抽象类派生而来，那么近当实现了所有的纯虚函数才是一个非抽象类；","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"多态","slug":"多态","permalink":"http://yoursite.com/tags/多态/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/虚函数/"},{"name":"抽象类","slug":"抽象类","permalink":"http://yoursite.com/tags/抽象类/"}]},{"title":"【Leetcode】106. Construct Binary Tree from Inorder and Postorder Traversal","slug":"【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal","date":"2019-04-22T14:12:25.000Z","updated":"2019-04-22T14:15:53.168Z","comments":true,"path":"2019/04/22/【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的中序遍历与后序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 123453 / \\9 20 / \\ 15 7 思路这道题是105基本相同，只不过，根节点在后续遍历数组的尾部，剩余都相同。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int il = 0, ir = inorder.size() - 1; int pl = 0, pr = postorder.size() - 1; return dfs(inorder, il, ir, postorder, pl, pr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; inorder, int il, int ir, vector&lt;int&gt;&amp; postorder, int pl, int pr)&#123; if(il &gt; ir || pl &gt; pr)&#123; return NULL; &#125; TreeNode* root = new TreeNode(postorder[pr]); int pos = 0; for(; pos &lt; ir; pos++)&#123; if(inorder[pos] == postorder[pr]) break; &#125; int len = pos - il; root-&gt;left = dfs(inorder, il, pos - 1, postorder, pl, pl + len - 1); root-&gt;right = dfs(inorder, pos + 1, ir, postorder, pl + len, pr - 1); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】105. Construct Binary Tree from Preorder and Inorder Traversal","slug":"【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","date":"2019-04-22T13:57:04.000Z","updated":"2019-04-22T14:10:51.617Z","comments":true,"path":"2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的前序遍历与中序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 123453 / \\9 20 / \\ 15 7 思路这道题实际上就是前序遍历的是，中左右，中序遍历的顺序是左中右，那么前序遍历的第一个点就是根节点，我们在中序遍历的数组中找到根节点的位置，左边就是左子树，右边就是右子树，不断的递归；这个题之前做的时候，是每次都构造新的vector,但是这样就会爆栈溢出，实际上每次传递引用即可。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int pl = 0, pr = preorder.size() - 1; int vl = 0, vr = inorder.size() - 1; return dfs(preorder, pl, pr, inorder, vl, vr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; preorder, int pl, int pr, vector&lt;int&gt;&amp; inorder, int vl, int vr)&#123; if(pl &gt; pr || vl &gt; vr)&#123; return NULL; &#125; int pos = 0; for(; pos &lt; vr; pos++)&#123; if(preorder[pl] == inorder[pos]) break; &#125; int len = pos - vl; TreeNode* root = new TreeNode(preorder[pl]); root-&gt;left = dfs(preorder, pl + 1, pl + len, inorder, vl, pos - 1); root-&gt;right = dfs(preorder, pl + len + 1, pr, inorder, pos + 1, vr); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】101.Symmetric Tree","slug":"【Leetcode】101-Symmetric-Tree","date":"2019-04-08T13:50:58.000Z","updated":"2019-04-08T14:05:13.777Z","comments":true,"path":"2019/04/08/【Leetcode】101-Symmetric-Tree/","link":"","permalink":"http://yoursite.com/2019/04/08/【Leetcode】101-Symmetric-Tree/","excerpt":"","text":"题目 判断是否是对称二叉树给定一个二叉树，检查它是否是镜像对称的。 案例二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \\2 2 \\ \\ 3 3 思路这道题反反复复几次总容易想错，实际上要看这个二叉树的左右子树是不是对称二叉树，实际上是看左右节点的子树是不是对称二叉树，也就是左节点的左子树和右节点的右子树是不是对称的，左节点的右子树和右节点的左子树的不是对称的。具体代码如下； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return issym(root-&gt;left, root-&gt;right); &#125; bool issym(TreeNode* left,TreeNode* right)&#123; if(!left &amp;&amp; !right) return true; if((!left &amp;&amp; right) || (left &amp;&amp; !right)) return false; if(left-&gt;val != right-&gt;val) return false; return issym(left-&gt;left, right-&gt;right) &amp;&amp; issym(left-&gt;right, right-&gt;left); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】81. Search in Rotated Sorted Array II","slug":"【Leetcode】81-Search-in-Rotated-Sorted-Array-II","date":"2019-03-06T14:53:38.000Z","updated":"2019-03-06T14:59:14.664Z","comments":true,"path":"2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 案例示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 思路这道题是33题的延伸，重复带来的问题就是，增加了判断哪边是有序的困难，比如[3 1 1] 和 [1 1 3 1]，对于这两种情况中间值等于最右值时，目标值3既可以在左边又可以在右边，那么其实，只要right和mid相等的话，我们直接将rihgt不断的减小就可以了。容易忘记等号！！！！ 代码123456789101112131415161718192021class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return true; if(nums[mid] &gt; nums[right])&#123; if(nums[mid] &gt; target &amp;&amp; target &gt;= nums[left]) right = mid - 1; else left = mid + 1; &#125;else if(nums[mid] &lt; nums[right])&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) left = mid + 1; else right = mid - 1; &#125;else right--; &#125; return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】33. Search in Rotated Sorted Array","slug":"【Leetcode】33-Search-in-Rotated-Sorted-Array","date":"2019-03-06T14:26:00.000Z","updated":"2019-03-06T14:37:20.833Z","comments":true,"path":"2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路如果是没旋转的，直接用二分法就可以了，但是旋转后的问题就在于不知道应该去左边和右边哪边找，实际上，如果mid大于right的值的话，那么就知道mid是旋转过来的，也就是左边是有序的，那我们先判断target是不是在左边，如果不是那么就是在右边；反之，如果mid小于right,说明mid是没有被旋转，右边是有序的，那么就先判断是不是属于右边，如果不是的话就属于左边；容易忘记等号！！！！ 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0; int right = n-1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; if(nums[mid] &gt; nums[right])//左边有序 &#123; if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])//容易忘记等号 &#123; right = mid -1; &#125; else left = mid + 1; &#125; else//右边有序 &#123; if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid+1; &#125; else right = mid -1; &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】67.Add Binary","slug":"【Leetcode】67-Add-Binary","date":"2019-03-03T05:15:05.000Z","updated":"2019-03-09T02:28:02.801Z","comments":true,"path":"2019/03/03/【Leetcode】67-Add-Binary/","link":"","permalink":"http://yoursite.com/2019/03/03/【Leetcode】67-Add-Binary/","excerpt":"","text":"题目 合并区间给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2:12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 思路从后向前看，如果当前的的位不存在，那么直接赋值为0，否则的话，赋值为当前的字符值，并于carry相加，这样不断的循环，直到两个字符串都遍历结束；具体看代码：需要注意的是，每次取的时候要转化成int; 代码123456789101112131415class Solution &#123;public: string addBinary(string a, string b) &#123; string res = \"\"; int m = a.length() - 1, n = b.length() - 1, carry = 0; while(m &gt;= 0 || n &gt;= 0)&#123; int i = m &gt;= 0 ? a[m--] - '0' : 0; int j = n &gt;= 0 ? b[n--] - '0' : 0; int tem = i + j + carry; res = to_string(tem % 2) + res; carry = tem / 2; &#125; return carry == 1 ? \"1\" + res : res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"}]},{"title":"【Leetcode】57.Insert Interval","slug":"【Leetcode】57-Insert-Interval","date":"2019-02-25T07:45:10.000Z","updated":"2019-02-25T08:15:23.310Z","comments":true,"path":"2019/02/25/【Leetcode】57-Insert-Interval/","link":"","permalink":"http://yoursite.com/2019/02/25/【Leetcode】57-Insert-Interval/","excerpt":"","text":"题目 合并区间给出一个无重叠的 ，按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 案例示例 1:12输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2:123输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 思路这个题和56题很像，唯一不同的就是是需要插入一个区间；思考这样的一个问题，这个区间应该插在哪里，实际上应该插在，该区间的start比原区间数组中的某一个元素的start刚好大于或者等于的情况；找到这个位置之后，就要考虑当前的插入区间是不是能直接插入还是需要和上一个区间合并，如果该区间的start比上一个区间的end要大的话，那么可以直接插入，或者还有一种特殊情况就是res中还没有区间，那么这两种情况都直接插入，否则的话就需要进行一次合并，合并的原则和56题一样，就是将当前res尾部的区间的end修改成插入区间的end和res尾部的end中的较大的值；然后再对剩余的区间依次做合并操作，最终得到结果； 代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); if(n == 0) &#123; res.push_back(newInterval); return res; &#125; int i = 0; for( ; i &lt; n; i++)&#123; if(newInterval.start &lt;= intervals[i].start) break; res.push_back(intervals[i]); &#125; if(i == 0 || newInterval.start &gt; intervals[i - 1].end) res.push_back(newInterval); else&#123; res.back().end = max(newInterval.end, res.back().end); &#125; for(; i &lt; n; i++)&#123; if(res.back().end &lt; intervals[i].start) res.push_back(intervals[i]); else res.back().end = max(res.back().end, intervals[i].end); &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"难","slug":"难","permalink":"http://yoursite.com/tags/难/"}]},{"title":"【Leetcode】56. Merge Intervals","slug":"【Leetcode】56-Merge-Intervals","date":"2019-02-24T15:07:06.000Z","updated":"2019-02-25T08:20:23.493Z","comments":true,"path":"2019/02/24/【Leetcode】56-Merge-Intervals/","link":"","permalink":"http://yoursite.com/2019/02/24/【Leetcode】56-Merge-Intervals/","excerpt":"","text":"题目 合并区间给出一个区间的集合，请合并所有重叠的区间。 案例示例 1:123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路首先将当前的区间按照start从低到高排序，如果后面一个区间的start比前一个的end要大，那么两者是没有重复的，直接将第二个放到当前的结果中；否则就是存在重复的区间，那就将当前res中最后一个区间的end，换成当前的end和原本的end的最大值；这个题目类似的题目是56题 代码123456789101112131415161718192021222324252627282930/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; if(n == 0) return res; sort(intervals.begin(), intervals.end(), cmp); res.push_back(intervals[0]); for(int i = 1; i &lt; n; i++)&#123; if(intervals[i].start &gt; res.back().end) res.push_back(intervals[i]); else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125; static bool cmp(Interval a, Interval b)&#123; return a.start &lt; b.start; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]},{"title":"关于c++ push ,pop小命令的笔记小抄","slug":"关于c-push-pop小命令的笔记小抄","date":"2019-02-23T03:04:33.000Z","updated":"2019-04-30T01:57:47.571Z","comments":true,"path":"2019/02/23/关于c-push-pop小命令的笔记小抄/","link":"","permalink":"http://yoursite.com/2019/02/23/关于c-push-pop小命令的笔记小抄/","excerpt":"","text":"set 插入：insert; vector 插入：push_back; 删除：pop_back; queuemap 访问map的key 和 value 的时候，是m.second 或者 m.first","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"c++习惯总结","slug":"c-习惯总结","permalink":"http://yoursite.com/tags/c-习惯总结/"}]},{"title":"leetcode之间的关系捋一捋","slug":"leetcode之间的关系捋一捋","date":"2019-02-23T02:21:44.000Z","updated":"2019-07-16T03:01:46.637Z","comments":true,"path":"2019/02/23/leetcode之间的关系捋一捋/","link":"","permalink":"http://yoursite.com/2019/02/23/leetcode之间的关系捋一捋/","excerpt":"","text":"组合类型 Permutations47. 39.40。 数组双指针【Leetcode】11.盛最多水的容器 求和问题双指针最后返回的是和值有关【Leetcode】15-3Sum【Leetcode】16-最接近的三数之和【Leetcode】16-最接近的三数之和map解决，返回的是下标Leetcode】1-Two-Sum 两个指针，一个指针用来锁定位置，一个用来遍历【Leetcode】26-删除排序数组中的重复项【Leetcode】27-移除元素 dfs、回溯【Leetcode】39-组合总和【Leetcode】40-组合总和-II 递归 类别1,二维dp数组可以只刷一次的是63【Leetcode】62. 不同路径【Leetcode】63. 不同路径 II【Leetcode】64. 最小路径和 哈希map【Leetcode】149. 直线上最多的点数（有三点注意） 技巧变小数为除以最大公约数，这样是比较保险的【Leetcode】149. 直线上最多的点数","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"知识点梳理","slug":"知识点梳理","permalink":"http://yoursite.com/tags/知识点梳理/"}]},{"title":"【leetcode】36. Valid Sudoku","slug":"【leetcode】36-Valid-Sudoku","date":"2019-02-21T14:09:21.000Z","updated":"2019-04-30T01:43:21.464Z","comments":true,"path":"2019/02/21/【leetcode】36-Valid-Sudoku/","link":"","permalink":"http://yoursite.com/2019/02/21/【leetcode】36-Valid-Sudoku/","excerpt":"","text":"题目 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 案例示例 1: 输入:12345678910111213[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:123456789101112输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] 输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 思路设置三个标志矩阵，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下，如下代码； 代码12345678910111213141516171819202122232425class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int n = board.size(); vector&lt;vector&lt;bool&gt;&gt; iscol(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; isrow(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; ismini(n,vector&lt;bool&gt;(n,false)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9') &#123; int t = board[i][j] - '1'; if(iscol[t][j] || isrow[i][t] || ismini[3 * (i / 3) + j / 3][t]) return false; iscol[t][j] = true; isrow[i][t] = true; ismini[3 * (i / 3) + j / 3][t] = true; &#125; &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]}]}
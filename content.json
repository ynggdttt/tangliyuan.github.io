{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"油腻高贵的唐怂怂","date":"2019-02-15T10:45:41.000Z","updated":"2019-02-16T13:24:04.094Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me12345&lt;profile&gt; &lt;name&gt; ynggdttt &lt;/name&gt; &lt;email&gt; tangliyuan@sjtu.edu.cn &lt;/email&gt; &lt;location&gt; Shanghai, China &lt;/location&gt;&lt;/profile&gt; Tags Related: Coding, IT, Capturing, Reading, Books, Movies, fans of Maobuyi, Traveling, Music…… FAQ: 为什么叫 ynggdttt ？简单的不能再简单的翻译–油腻高贵的糖糖糖，2018年5月份粉上了毛不易先生，仔细想想能拿到 一句话描述自己：一个对曾以为自己很特别，现在逐渐接受也甘于平凡的人。 If you want to know more, contact me via my private WeChat account: zanglingyangshashou or email."}],"posts":[{"title":"【网络】","slug":"【网络】","date":"2019-06-25T02:28:14.415Z","updated":"2019-06-25T13:17:04.568Z","comments":true,"path":"2019/06/25/【网络】/","link":"","permalink":"http://yoursite.com/2019/06/25/【网络】/","excerpt":"","text":"tcp三次握手，四次挥手的具体三次握手、四次挥手 tcp、udp区别1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 5、TCP提供面向字节流的传输，它能将信息分割成组，并在接收端将其充足，UDP提供面向数据报的传输，没有分组开销 6、TCP提供拥塞控制，流量控制机制，UDP没有 滑动窗口滑动窗口协议的实现：GBN(go back to N)GBN 累计计数收到乱序的直接丢了 分组头部包含序列号 窗口如下，大小为N，最多允许N个分组未确认 ACK(n),则表示确认从开始到n（包含n）的序列号全部正确接收 会空中在传的分组设置一个Timer计时器，处理超时，如果收到了timeout(n)事件，那么会重传的是n以及n以后的所有分组（尽管后面的可能已经收到了，这就是回退，回退到n开始传，GBN） 接收方会有一个期望序列号，如果收到的不是期望的分组，直接丢弃 SR(select repeat)多了一个接收方的窗口发送方窗口和接收窗口不同步的 GBN缺陷，累积确认机制导致回退到N，重复传了很多。解决这个。 1.对每个分组分别确认，不再只接收期望的，接到不期望的，就先缓存（设置缓存机制），接到期望的才交付上层 2.发送方只需要重传那些没收到ACK的分组了 3.产生了接收方窗口（GBN只有发送方窗口），用来缓存，现在有两窗口了 4.序列号的位数是K的话，那么得满足 接收方窗口大小N+发送方N&lt;= 2的k次方，防止因为接收方ACK丢失导致发送重发k号分组，而此时接收方滑到了新窗口，新窗口有新的k号分组（不是原来的，共用序号产生的），导致出错 tcp可靠数据传输的原理端到端，用确认重传等保证TCP协议采用累积确认机制、通常在接收端提供缓存、单一重传计时器重传具有最小序列号的那一个，并且重启计时器 快重传定时器超时之前，收到三个重复的ack，就重传 流量控制速度匹配 拥塞控制整个网络的负载带来的问题：拥塞端到端的拥塞控制加性增、乘性减、慢启动 TCP为什么可靠知乎链接 TCP超时重传，确认和重传机制 流量控制 TCP窗口会指明双方能够发送接收的最大数据量 TCP流量控制主要是针对接收端的处理速度不如发送端发送速度快的问题，消除发送方使接收方缓存溢出的可能性。 TCP流量控制主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。 拥塞控制TCP发送方可能因为IP网络的拥塞而被遏制，TCP拥塞控制就是为了解决这个问题（注意和TCP流量控制的区别）。 TCP拥塞控制的几种方法：慢启动，拥塞避免，快重传和快恢复。 慢启动 拥塞避免 加性增 快重传 快恢复 乘性减 https 的实现传纸条讲解https小灰讲解https 牛客上的https答案HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。HTTPS和HTTP的区别主要如下： 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 http\\tcpip\\socket指路链接吧了socket，tcp，http三者之间的区别和原理 网络协议 待看https://blog.csdn.net/stringNewName/article/details/72717213","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[]},{"title":"【操作系统】进程线程","slug":"【操作系统】进程线程","date":"2019-06-23T12:54:23.000Z","updated":"2019-06-23T15:13:38.454Z","comments":true,"path":"2019/06/23/【操作系统】进程线程/","link":"","permalink":"http://yoursite.com/2019/06/23/【操作系统】进程线程/","excerpt":"","text":"指路链接吧，讲的太好了分享链接 进程线程 进程：程序的一次执行 线程：CPU的基本调度单位 自己的感悟：线程是我们自己设计的，一个程序中可以开启多个线程去干活，这样快很多，但是必要的时候为了保证线程安全，就得加锁；进程，通常是操作系统调度的； 进程是并行，线程并发 进程之间通信参考链接，链接进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 线程和进程的堆栈线程有栈，进程有堆 静态存储区、堆区和栈区可编程内存在基本上分为这样的几大部分：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。 栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，否则，我们认为发生了内存泄漏现象。 线程、协程、进程机器人解释coroutine可以认为是单线程多任务的工作方式(当然，进程中实现coroutine也是可以的)，因为它在单个线程中的多个任务之间直接跳转，而多线程是通过上下文切换来实现多任务的。换句话说，coroutine提供了并发却不并行的功能。通过coroutine，还能实现更为”实时”的上下文任务，因为coroutine之间的跳转切换不需要任何系统调用和可能的阻塞调用，不需要像多线程一样为了线程之间的资源同步而使用额外的互斥锁、信号量等。协程线程区别而协程与线程主要的区别有两个，最大的就是调度方式，线程是操作系统调度，协程是应用系统自己调度。 另外一个区别，协程的栈空间是可以动态调整的，这样空间利用率就可以更高，一个任务需要2K空间就分配2K内存，一个任务需要20M空间就分配20M，而不用担心栈空间不够或者空间浪费。 由于上面的两个原因，协程的优势也就凸显出来。 协程可以更好的利用CPU，不用把CPU浪费在线程调度和上下文切换上。 协程可以更好的利用内存，不用全都分配一个偏大的空间，只需要分配需要的对应空间即可。 多线程单线程 多线程的产生并不是因为发明了多核CPU甚至现在有多个CPU+多核的硬件，也不是因为多线程CPU运行效率比单线程高。单从CPU的运行效率上考虑，单任务进程及单线程效率是最高的，因为CPU没有任何进程及线程的切换开销， 实际上，多线程的出现主要为了解决IO设备的读写速度往往比CPU的处理速度慢造成的单线程程序运行阻塞问题，一个极端的例子就是如果你需要用户在键盘上输入一个数据，当用户没有输入前，单线程程序就阻塞了，多线程程序就可以放个音乐或继续干一些程序中除了键盘输入外的工作，因此，多线程能提高因程序由于等待某个资源阻塞时其他资源的利用率（是利用率不是效率）。 因此多线程与单线程的最大区别，多线程程序能在等待某个IO操作时，继续完成非这个IO的其他工作，有利于提高完成整个任务的效果和速度。此外，多线程程序与单线程程序对程序设计也有不同的流程和结构，多线程需要考虑对静态变量等资源的操作互锁及程序执行的同步问题。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"},{"name":"进程","slug":"进程","permalink":"http://yoursite.com/tags/进程/"}]},{"title":"【Linux】","slug":"【Linux】","date":"2019-06-23T05:41:47.000Z","updated":"2019-06-23T05:41:47.336Z","comments":true,"path":"2019/06/23/【Linux】/","link":"","permalink":"http://yoursite.com/2019/06/23/【Linux】/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【Leetcode】918. 环形子数组的最大和","slug":"【Leetcode】918-环形子数组的最大和","date":"2019-06-22T07:09:20.000Z","updated":"2019-06-22T07:29:01.555Z","comments":true,"path":"2019/06/22/【Leetcode】918-环形子数组的最大和/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】918-环形子数组的最大和/","excerpt":"","text":"题目 环形子数组的最大和给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。 在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，而当 i &gt;= 0 时 C[i+A.length] = C[i]） 此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length） 案例示例 1:123输入：[1,-2,3,-2]输出：3解释：从子数组 [3] 得到最大和 3 示例2：123输入：[5,-3,5]输出：10解释：从子数组 [5,5] 得到最大和 5 + 5 = 10 示例3：123输入：[3,-1,2,-1]输出：4解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4 -30000 &lt;= A[i] &lt;= 300001 &lt;= A.length &lt;= 30000 思路 首先处理没有延长的情况，就正常寻找最大的值； 对于有延长的情况，只要用求和的减去连续数组的最小值即可； 但是要考虑是不是全是负数，因为全是负数的话，考虑延长的结果就是0了；代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int maxSubarraySumCircular(vector&lt;int&gt;&amp; A) &#123; bool flag = false; int sum = 0, amax = A[0]; //考虑是不是负数，并且找到最大值 for(auto a : A)&#123; if(a &gt; 0) flag = true; sum += a; amax = max(a,amax); &#125; if(!flag)&#123; return amax; &#125; int res = INT_MIN; int res_max = INT_MIN; int res_min = INT_MAX; int n = A.size(); int tem_max = A[0], tem_min = A[0]; //分别找到最大值和最小值 for(int i = 1;i &lt; n; i++)&#123; if(tem_max + A[i] &gt; A[i])&#123; tem_max = tem_max + A[i]; &#125;else&#123; tem_max = A[i]; &#125; res_max = max(res_max,tem_max); if(tem_min + A[i] &lt; A[i])&#123; tem_min = tem_min + A[i]; &#125;else&#123; tem_min = A[i]; &#125; res_min = min(res_min,tem_min); &#125; //求和减去最小值 int res2 = sum - res_min; res = max(res2,res_max); return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组 - 中等 - 双指针","slug":"数组-中等-双指针","permalink":"http://yoursite.com/tags/数组-中等-双指针/"}]},{"title":"【Leetcode】31. 下一个排列","slug":"【Leetcode】31-下一个排列","date":"2019-06-22T06:13:28.000Z","updated":"2019-06-22T06:27:02.685Z","comments":true,"path":"2019/06/22/【Leetcode】31-下一个排列/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】31-下一个排列/","excerpt":"","text":"题目 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 案例示例 1:1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路 从后往前找，首先找到第一个逆序的位置 如果不存在逆序的位置，就直接把顺序改变，得到最小的； 再从后往前遍历，找到第一个比当前的大的，然后交换后，再排序；代码 12345678910111213141516171819class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; //找第一个不顺序的数 int i = nums.size() - 1; for(i; i &gt; 0; i--)&#123; if(nums[i] &gt; nums[i - 1]) break; &#125; if(i == 0) return sort(nums.begin(),nums.end()); int j = nums.size() - 1; for(j; j &gt;= i; j--)&#123; if(nums[j] &gt; nums[i - 1]) break; &#125; swap(nums[j],nums[i - 1]); sort(nums.begin()+i, nums.end()); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】27. 移除元素","slug":"【Leetcode】27-移除元素","date":"2019-06-22T06:04:30.000Z","updated":"2019-06-22T06:05:56.386Z","comments":true,"path":"2019/06/22/【Leetcode】27-移除元素/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】27-移除元素/","excerpt":"","text":"题目 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 案例示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 思路 从前向后遍历，利用两个指针，一个指针遍历，一个指针用来存储当前的有效的位置； 代码123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int i = 0; for(int j = 0; j &lt; nums.size(); j++)&#123; if(nums[j] != val)&#123; nums[i++] = nums[j]; &#125; &#125; return i; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组 - 中等 - 双指针","slug":"数组-中等-双指针","permalink":"http://yoursite.com/tags/数组-中等-双指针/"}]},{"title":"【Leetcode】26. 删除排序数组中的重复项","slug":"【Leetcode】26-删除排序数组中的重复项","date":"2019-06-22T05:59:57.000Z","updated":"2019-06-22T06:03:29.869Z","comments":true,"path":"2019/06/22/【Leetcode】26-删除排序数组中的重复项/","link":"","permalink":"http://yoursite.com/2019/06/22/【Leetcode】26-删除排序数组中的重复项/","excerpt":"","text":"题目 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 案例示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 思路 从前向后遍历，利用两个指针，一个指针遍历，一个指针用来存储当前的有效的位置； 代码12345678910111213class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; int i = 1, t = nums[0]; for(int j = 1; j &lt; nums.size();j++)&#123; if(nums[j] != nums[j - 1])&#123; nums[i++] = nums[j]; &#125; &#125; return i; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】18. 四数之和","slug":"【Leetcode】18-四数之和","date":"2019-06-21T10:10:35.000Z","updated":"2019-06-21T10:15:16.625Z","comments":true,"path":"2019/06/21/【Leetcode】18-四数之和/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】18-四数之和/","excerpt":"","text":"题目 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意 答案中不可以包含重复的四元组。 案例示例 1:12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路和题目【Leetcode】15-3Sum比较相近； 将数组排序； 降为三维； 不同的是不用去做判断break,因为有负数； 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt;res; sort(nums.begin(),nums.end()); for(int i = 0; i &lt; nums.size(); i++)&#123; //if(nums[i] &gt; target) break;//没有的 if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; for(int j = i + 1; j &lt; nums.size(); j++)&#123; //if(nums[j] &gt; target) break;//没有的 if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int t = target - nums[i] - nums[j]; int left = j + 1,right = nums.size() - 1; while(left &lt; right)&#123; int sum = nums[left] + nums[right]; if(sum == t)&#123; res.push_back(&#123;nums[i],nums[j],nums[left],nums[right]&#125;); while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++,right--; &#125;else if(sum &lt; t) left++; else right--; &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】16. 最接近的三数之和","slug":"【Leetcode】16-最接近的三数之和","date":"2019-06-21T10:04:31.000Z","updated":"2019-06-21T10:09:09.797Z","comments":true,"path":"2019/06/21/【Leetcode】16-最接近的三数之和/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】16-最接近的三数之和/","excerpt":"","text":"题目 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 案例示例 1:123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 思路和题目【Leetcode】15-3Sum比较相近； 将数组排序； 不段的比较，找到最小的 注意，仍然用双指针方法，这样不会丢解，因为是在不短的像target靠近；代码 12345678910111213141516171819202122class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int dif = INT_MAX,res = 0; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++)&#123; int left = i + 1, right = nums.size() - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[left] + nums[right]; int diff = abs(sum - target); if(diff &lt; dif)&#123; dif = diff; res = sum; &#125; // res = min(res,diff); if (sum &lt; target) left++; else right--; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】11.盛最多水的容器","slug":"【Leetcode】11-盛最多水的容器","date":"2019-06-21T09:41:51.000Z","updated":"2019-06-21T09:58:58.725Z","comments":true,"path":"2019/06/21/【Leetcode】11-盛最多水的容器/","link":"","permalink":"http://yoursite.com/2019/06/21/【Leetcode】11-盛最多水的容器/","excerpt":"","text":"题目 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 案例12![示例](【Leetcode】11-盛最多水的容器/figure.jpg)图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 思路利用双指针，移动的是盛水少的指针，最后跳出循环，得到最终结果； 代码1234567891011121314class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int left = 0, right = height.size() - 1; int res = 0; while(left &lt; right)&#123; int l = height[left], r = height[right]; res = max(min(l,r)*(right - left),res); if(l &lt; r) left++; else right--; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"mk的一些常见的语法“ ","slug":"mk的一些常见的语法“","date":"2019-05-30T14:11:56.000Z","updated":"2019-05-30T14:17:20.392Z","comments":true,"path":"2019/05/30/mk的一些常见的语法“/","link":"","permalink":"http://yoursite.com/2019/05/30/mk的一些常见的语法“/","excerpt":"","text":"插入图片! + [[内容]] + ( ) 字体加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 超链接语法： [超链接名]+(超链接地址 +”超链接title”)title可加可不加 列表 无序列表语法：无序列表用 - + * 任何一种都可以 有序列表语法：数字加点","categories":[{"name":"MK","slug":"MK","permalink":"http://yoursite.com/categories/MK/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"【Leetcode】12. 整数转罗马数字","slug":"【Leetcode】12-整数转罗马数字","date":"2019-05-30T13:01:23.000Z","updated":"2019-05-30T13:05:17.631Z","comments":true,"path":"2019/05/30/【Leetcode】12-整数转罗马数字/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】12-整数转罗马数字/","excerpt":"","text":"题目 整数转罗马数字罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 案例示例 1:12输入: 3输出: &quot;III&quot; 示例 2:12输入: 4输出: &quot;IV&quot; 思路先将所有的对应表列好，每次通过查表找出当前最大的数，减去再继续查表 代码123456789101112131415class Solution &#123;public: string intToRoman(int num) &#123; string res = \"\"; vector&lt;int&gt; val = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; vector&lt;string&gt; s = &#123;\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"&#125;; for(int i = 0; i &lt; val.size(); i++)&#123;//这个for和while很巧妙 while(num &gt;= val[i])&#123; num -= val[i]; res += s[i]; &#125; &#125; return res; &#125;&#125;; 需要记住的点 这个for和while用的很巧妙；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"【Leetcode】8. 字符串转换整数 (atoi)” ","slug":"【Leetcode】8-字符串转换整数-atoi-”","date":"2019-05-30T12:10:52.538Z","updated":"2019-05-30T13:01:33.553Z","comments":true,"path":"2019/05/30/【Leetcode】8-字符串转换整数-atoi-”/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】8-字符串转换整数-atoi-”/","excerpt":"","text":"题目 Z 字形变换请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 案例示例 1:12输入: &quot;42&quot;输出: 42 示例 2:1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 思路首先排除空字符，然后看符号，然后看数字，注意，判断数字要考虑可能越界问题，采用INT_MACX/10，作为判断是不是会越界；具体看代码；这道题主要学习代码简洁性，以及判断越界的方法； 代码1234567891011121314151617181920cclass Solution &#123;public: int myAtoi(string str) &#123; int flag = 1, res = 0,n = str.length(),i = 0; while(i &lt; n &amp;&amp; str[i] == ' ')&#123; i++; &#125; if(str[i] == '+' || str[i] == '-')&#123; flag = str[i++] == '+' ? 1 : -1; &#125; while(i &lt; n &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')&#123; int tem = str[i++] - '0'; if(res &gt; INT_MAX/10 || (res == INT_MAX/10 &amp;&amp; tem &gt;= 8))&#123; return flag == 1 ? INT_MAX : INT_MIN; &#125; res = res * 10 + tem; &#125; return flag * res; &#125;&#125;; 需要记住的点 INT_MAX/10，并要判断等于的情况，等于的情况要分为大不大于8；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】6. Z 字形变换","slug":"【Leetcode】6-Z-字形变换","date":"2019-05-30T07:52:03.146Z","updated":"2019-05-30T08:01:57.308Z","comments":true,"path":"2019/05/30/【Leetcode】6-Z-字形变换/","link":"","permalink":"http://yoursite.com/2019/05/30/【Leetcode】6-Z-字形变换/","excerpt":"","text":"题目 Z 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 案例示例 1:12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2:12345678输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L D RE O E I IE C I H NT S G 思路可以看出是有规律可循的，我们发现，周期为2nRows - 2, 根据这个特点，我们可以按顺序找到所有的黑色元素在元字符串的位置，将他们按顺序加到新字符串里面。对于红色元素出现的位置也是有规律的，每个红色元素的位置为 j + 2nRows-2 - 2i, 其中，j为前一个黑色元素的列数，i为当前行数。 比如当n = 4中的那个红色5，它的位置为 1 + 24-2 - 2*1 = 5，为原字符串的正确位置。因为相当于加了一个周期再折回来，当我们知道所有黑色元素和红色元素位置的正确算法，我们就可以一次性的把它们按顺序都加到新的字符串里面 代码12345678910111213141516class Solution &#123;public: string convert(string s, int nRows) &#123; if (nRows &lt;= 1) return s; string res = \"\"; int size = 2 * nRows - 2; for (int i = 0; i &lt; nRows; ++i) &#123; for (int j = i; j &lt; s.size(); j += size) &#123; res += s[j]; int tmp = j + size - 2 * i; if (i != 0 &amp;&amp; i != nRows - 1 &amp;&amp; tmp &lt; s.size()) res += s[tmp];//关键的地方 &#125; &#125; return res; &#125;&#125;; 需要记住的点 规律很好，时间复杂度就是变成n；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】5. 最长回文子串","slug":"【Leetcode】5-最长回文子串","date":"2019-05-27T14:35:14.716Z","updated":"2019-05-27T14:48:49.869Z","comments":true,"path":"2019/05/27/【Leetcode】5-最长回文子串/","link":"","permalink":"http://yoursite.com/2019/05/27/【Leetcode】5-最长回文子串/","excerpt":"","text":"题目 无重复字符的最长子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 案例示例 1:123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2:12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 思路遍历每个字符，然后获取这个字符作为中间的最长的回文串；再去更新结果；分为两种情况，回文串为奇数和偶数两种情况；具体代码如下； 代码123456789101112131415161718192021class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; int n = s.size(), maxLen = 0, start = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; searchPalindrome(s, i, i, start, maxLen); searchPalindrome(s, i, i + 1, start, maxLen); &#125; return s.substr(start, maxLen); &#125; void searchPalindrome(string s, int left, int right, int&amp; start, int&amp; maxLen) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; if (maxLen &lt; right - left - 1) &#123; start = left + 1; maxLen = right - left - 1; &#125; &#125;&#125;; 需要记住的点 很巧妙的用了引用；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】3. 无重复字符的最长子串","slug":"【Leetcode】3-无重复字符的最长子串","date":"2019-05-27T13:59:22.000Z","updated":"2019-05-27T14:09:33.416Z","comments":true,"path":"2019/05/27/【Leetcode】3-无重复字符的最长子串/","link":"","permalink":"http://yoursite.com/2019/05/27/【Leetcode】3-无重复字符的最长子串/","excerpt":"","text":"题目 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。 案例示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路建立一个HashMap，建立每个字符和其最后出现位置之间的映射，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置的前一个，由于是前一个，所以初始化就是-1，然后我们遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在HashMap中存在了，并且如果其映射值大于left的话，那么更新left为当前映射值。然后映射值更新为当前坐标i，这样保证了left始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用i-left即可，用来更新结果res。几个比较关键的点： left初始值设为1，因为我们定义left是当前窗口的前一个值；代码 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0, left = -1, n = s.size(); unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; n; ++i) &#123; if (m.count(s[i]) &amp;&amp; m[s[i]] &gt; left) &#123;//比较精华的一句话 left = m[s[i]]; &#125; m[s[i]] = i; res = max(res, i - left); &#125; return res; &#125;&#125;; 需要记住的点 unordered_map查找，用m.count(val); 包含再头文件unordered_map中；","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/滑动窗口/"}]},{"title":"排序算法","slug":"排序算法“","date":"2019-05-04T12:30:21.000Z","updated":"2019-05-30T14:57:56.487Z","comments":true,"path":"2019/05/04/排序算法“/","link":"","permalink":"http://yoursite.com/2019/05/04/排序算法“/","excerpt":"","text":"每一种排序算法都有必须存在的理由； 选择排序 时间复杂度：n^2，最好的最坏的情况都是； 不需要额外的空间； 不稳定；代码：123456789101112void helper(vector&lt;int&gt; &amp;b)&#123; int n = b.size(); for(int i = 0; i &lt; n; i++)&#123; int index = i; for(int j = i + 1; j &lt; n; j++)&#123; if(b[j] &lt; b[index])&#123; index = j; &#125; &#125; swap(b[i],b[index]); &#125;&#125; 冒泡排序冒泡排序的思想是，从第0个元素到第n-1个元素遍历，若前面一个元素大于后面一个元素，则交换两个元素，这样可将整个序列中最大的元素冒泡到最后，然后再从第0个到第n-2遍历，如此往复，直到只剩一个元素。 时间复杂度：n^2，最好的最坏的情况都是； 不需要额外的空间； 不稳定 好在可以在内层循环中设置一个flag,如果在当前的循环中从来没有进行过交换，那么说明内部已经是完全有序的了，那么这种情况，最好的情况是时间复杂度为n;代码：123456789101112131415void helper(vector&lt;int&gt; &amp;b)&#123; int n = b.size(); for(int i = n - 1; i &gt; 0; i--)&#123; bool flag = false; for(int j = 0; j &lt; i; j++)&#123; if(b[j] &gt; b[j + 1])&#123; flag = true; swap(b[j], b[j+1]); &#125; &#125; if(!flag)&#123; break; &#125; &#125;&#125; 123456789101112void Bubble_Sort( ElementType A[], int N )&#123; for ( P=N-1; P&gt;=0; P-- )&#123; flag = 0; for( i=0; i&lt;P; i++ ) &#123; /* 一趟冒泡 */ if ( A[i] &gt; A[i+1] ) &#123; Swap(A[i], A[i+1]); flag = 1; /* 标识发生了交换 */ &#125; &#125; if ( flag==0 ) break; /* 全程无交换 */ &#125;&#125; 插入排序插入排序的思想是，像抓扑克牌一样，不断的将一张牌插入到已经排序好的数组中；从有序的最后比较； 时间复杂度：最坏n^2，最好n,取决于逆序对的数量； 不需要额外的空间； 现在一次只能消除一个逆序对，想法就是一次多消除几个逆序对；代码：123456789void Insertion_Sort( ElementType A[], int N ) &#123; for(int P = 1; P &lt; N; P++)&#123; int tem = A[P];//抓牌 for(int i = P; i &gt; 0 &amp;&amp; tem &lt; A[i - 1]; i--)&#123; A[i] = A[i - 1];//找位置 &#125; A[i] = tem; &#125;&#125; 当我们每次需要多消除几个逆序对的想法出现的时候，就变成了希尔排序； 希尔排序希尔排序的思想是，保证K个间隔是有序的 定义增量序列DM &gt;DM-1 &gt;…&gt;D1 =1 对每个 Dk 进行“Dk-间隔”排序( k = M, M-1, … 1 ) 注意:“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk- 间隔”有序的 几种增量序列 原始增量序列DM =N/2, Dk =Dk+1/2代码：1234567891011void Shell_sort( ElementType A[], int N )&#123; for(int D = N/2; D &gt; 0; D /= 2 )&#123; for(int P = D; P &lt; N; P ++)&#123; int tem = A[P]; for(int i = P; i &gt;0 &amp;&amp; tem &lt; A[i - D]; i -= D)&#123; A[i] = A[i - D]; &#125; A[i] = tem; &#125; &#125;&#125; 可能会导致很大的问题，比如下面的情况相当于白跑很多趟，只有最后一趟有用，坏的是O(N^2) Hibbard 增量序列Dk =2k –1 —相邻元素互质 最坏情况:T=O(N3/2 ) 猜想:Tavg =O(N5/4 ) Sedgewick增量序列 {1, 5, 19, 41, 109, … }—9+4^i–9+2^i +1或4^i–3*2^i+1 猜想:Tavg =O(N7/6 )，Tworst =O(N4/3 )","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"【Leetcode】15. 3Sum","slug":"【Leetcode】15-3Sum","date":"2019-05-03T10:27:07.000Z","updated":"2019-06-21T07:24:30.128Z","comments":true,"path":"2019/05/03/【Leetcode】15-3Sum/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】15-3Sum/","excerpt":"","text":"题目 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。案例示例 1:1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路 将数组排序； 遍历数组，利用双指针的方法去找两个数的和相加是当前数的相反数的情况，见题目（）； 几点注意，因为题目中要求不能有重复的结果，重复的结果可能出现在两个地方，首先是，遍历的时候已经找到过的组合，还有就是对当前遍历到的数字，可能存在两种相同的组合；对两种情况进行排除即可。代码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; int n = nums.size(); if(n &lt;= 2) return result; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int t = nums[i]; if(i &gt; 0 &amp;&amp; t == nums[i - 1]) continue; if(t &gt; 0) break; else&#123; int tem = -t; int l = i + 1, r = n - 1; while(l &lt; r)&#123; if(nums[l] + nums[r] == tem) &#123; result.push_back(&#123;t,nums[l],nums[r]&#125;); while(l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++;//记住是为什么，是为了排除重复，而且有条件限制，所以不会在l+1处出问题 while(l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; &#125; else if(nums[l] + nums[r] &gt; tem) r--; else if(nums[l] + nums[r] &lt; tem) l++; &#125; &#125; &#125; return result; &#125; &#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"}]},{"title":"【Leetcode】4. Median of Two Sorted Arrays","slug":"【Leetcode】4-Median-of-Two-Sorted-Arrays“","date":"2019-05-03T09:32:55.000Z","updated":"2019-05-03T09:38:19.984Z","comments":true,"path":"2019/05/03/【Leetcode】4-Median-of-Two-Sorted-Arrays“/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】4-Median-of-Two-Sorted-Arrays“/","excerpt":"","text":"题目 寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 案例示例 1:123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 思路 首先题目要求时间复杂度为O(log(m + n))，那么需要用二分法，但是两个数组怎么用二分法呢； 第二点，中位数要怎么找呢，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小 trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。 需要定义一个函数来在两个有序数组中找到第K个元素； 首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组 nums1 和 nums2 的起始位置。 然后来处理一些 corner cases，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果 K=1 的话，那么我们只要比较 nums1 和 nums2 的起始位置i和j上的数字就可以了。难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，那么对谁二分呢，数组么？其实要对K二分，意思是我们需要分别在 nums1 和 nums2 中查找第 K/2 个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第 K/2 个数字，所以我们需要先 check 一下，数组中到底存不存在第 K/2 个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第 K/2 个数字，那么我们就淘汰另一个数组的前 K/2 个数字即可。举个例子来说吧，比如 nums1 = {3}，nums2 = {2, 4, 5, 6, 7}，K=4，我们要找两个数组混合中第4个数字，那么我们分别在 nums1 和 nums2 中找第2个数字，我们发现 nums1 中只有一个数字，不存在第二个数字，那么 nums2 中的前2个数字可以直接跳过，为啥呢，因为我们要求整个混合数组的第4个数字，不管 nums1 中的那个数字是大是小，第4个数字绝不会出现在 nums2 的前两个数字中，所以可以直接跳过。 最后就是二分法的核心啦，比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，如果第一个数组的第 K/2 个数字小的话，那么说明我们要找的数字肯定不在 nums1 中的前 K/2 个数字，所以我们可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2，调用递归。反之，我们淘汰 nums2 中的前 K/2 个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2代码 12345678910111213141516171819class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(), left = (m + n + 1) / 2, right = (m + n + 2) / 2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; &#125; int findKth(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt;&amp; nums2, int j, int k) &#123; if (i &gt;= nums1.size()) return nums2[j + k - 1]; if (j &gt;= nums2.size()) return nums1[i + k - 1]; if (k == 1) return min(nums1[i], nums2[j]); int midVal1 = (i + k / 2 - 1 &lt; nums1.size()) ? nums1[i + k / 2 - 1] : INT_MAX; int midVal2 = (j + k / 2 - 1 &lt; nums2.size()) ? nums2[j + k / 2 - 1] : INT_MAX; if (midVal1 &lt; midVal2) &#123; return findKth(nums1, i + k / 2, nums2, j, k - k / 2); &#125; else &#123; return findKth(nums1, i, nums2, j + k / 2, k - k / 2); &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"困难","slug":"困难","permalink":"http://yoursite.com/tags/困难/"}]},{"title":"【Leetcode】1. Two Sum","slug":"【Leetcode】1-Two-Sum","date":"2019-05-03T07:46:05.000Z","updated":"2019-06-21T09:42:18.396Z","comments":true,"path":"2019/05/03/【Leetcode】1-Two-Sum/","link":"","permalink":"http://yoursite.com/2019/05/03/【Leetcode】1-Two-Sum/","excerpt":"","text":"题目 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 案例示例 1:123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路最开始的想法应该都是用两重循环去遍历，这样会超时；可以用空间换时间，利用哈希表map进行存储;从前向后遍历，这样可以排除自己加自己的情况； 代码12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0; i &lt; nums.size(); i++)&#123; int t = target - nums[i]; if(m.count(t))&#123; return &#123;i,m[t]&#125;; &#125; else&#123; m[nums[i]] = i; &#125; &#125; return &#123;&#125;; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"类成员可访问的情况","slug":"类成员可访问的情况","date":"2019-04-27T02:30:49.000Z","updated":"2019-04-30T01:56:33.459Z","comments":true,"path":"2019/04/27/类成员可访问的情况/","link":"","permalink":"http://yoursite.com/2019/04/27/类成员可访问的情况/","excerpt":"","text":"Private基类的Private成员可以被以下两种访问： 基类的成员函数 基类的友员函数 Protected基类的Protected成员可以被以下访问： 基类的成员函数 基类的友员函数 派生类的成员函数可以访问当前对象的基类的保护成员 Pulbic基类的Pulbic成员可以被以下访问： 基类的成员函数 基类的友员函数 派生类的成员函数 派生类的友员函数 其他函数","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"}]},{"title":"多态，虚函数，抽象类","slug":"多态，虚函数，抽象类","date":"2019-04-24T14:20:01.000Z","updated":"2019-04-30T01:56:31.287Z","comments":true,"path":"2019/04/24/多态，虚函数，抽象类/","link":"","permalink":"http://yoursite.com/2019/04/24/多态，虚函数，抽象类/","excerpt":"","text":"多态 目的：提供程序的可扩充性，有些语言有继承的概念但是没有多态的概念，只能称为基于对象的语言，不能称为面向对象的语言； 多态的表现形式： 派生类的指针可以赋值给基类指针；（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数;（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。举例： 12345678910111213class CBase &#123; public: virtual void SomeVirtualFunction() &#123; &#125;&#125;;class CDerived:public CBase &#123;public : virtual void SomeVirtualFunction() &#123; &#125;&#125;;int main() &#123;CDerived ODerived;CBase * p = &amp; ODerived;p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象 return 0;&#125; 派生类的对象可以赋值给基类引用；（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数;（2）若该引用引用的是派生类的对象，那么被调用的是派生类的虚函数。 12345678910111213class CBase &#123; public: virtual void SomeVirtualFunction() &#123; &#125;&#125;;class CDerived:public CBase &#123;public : virtual void SomeVirtualFunction() &#123; &#125;&#125;;int main() &#123; CDerived ODerived; CBase &amp; r = ODerived; r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象 return 0;&#125; 多态的原理 – 动态连编 “多态”的关键在于通过基类指针或引用调用 一个虚函数时，编译时不确定到底调用的是基类还 是派生类的函数，运行时才确定 —- 这叫“动态联编”。 虚函数表1）每一个有虚函数的类(或有虚函数的类的派生类) 都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。如图：多态的函数调用语句被编译成一系列根据基类指针所指向的(或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令； 虚函数在声明成员函数的时候，加上virtual关键字，该关键字只用在类定义函数的声明中，写函数体的时候不需要；注意 构造函数和静态成员函数不能是虚函数； 虚函数和普通函数的差别在于，虚函数可以参与多态，而普通函数不能 函数重写等于覆盖，重写的函数在基类中必须是虚函数； 派生类中和基类的虚函数同名同参数的函数，不叫virtual也会自动定义为虚函数； 虚函数的访问权限问题12345678910class Base &#123;private:virtual void fun2() &#123; cout &lt;&lt; \"Base::fun2()\" &lt;&lt; endl; &#125; &#125;;class Derived:public Base &#123; public:virtual void fun2() &#123; cout &lt;&lt; \"Derived:fun2()\" &lt;&lt; endl; &#125; &#125;;Derived d;Base * pBase = &amp; d;pBase -&gt; fun2(); // 编译出错 编译出错是因为fun2()是Base的私有成员。即使运行到此时实际上调用的应该是 Derived的公有成员 fun2()也不行，因为语法检查是不考虑运行结果的。如果将Base中的private换成public,即使Derived中的fun2()是private的，编译依然能通 过，也能正确调用Derived::fun2()。 一般基类的虚构函数都会写成是虚析构函数，这样才能把构造的对象成彻底析构掉； 纯虚函数和抽象类 纯虚函数: 没有函数体的虚函数；virtual void Print( ) = 0 ; 包含纯虚函数的类叫抽象类； 抽象类只能作为基类来派生新类使用，不能创建抽象类的对象 抽象类的指针和引用可以指向由抽象类派生出来的类的对象 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函 数，它才能成为非抽象类； 补充没有多态机制的语言，叫基于对象的程序语言，有多态的才叫面向对象语言；","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"C++面试知识点总结","slug":"C-面试知识点总结","permalink":"http://yoursite.com/tags/C-面试知识点总结/"},{"name":"多态","slug":"多态","permalink":"http://yoursite.com/tags/多态/"},{"name":"虚函数","slug":"虚函数","permalink":"http://yoursite.com/tags/虚函数/"},{"name":"抽象类","slug":"抽象类","permalink":"http://yoursite.com/tags/抽象类/"}]},{"title":"【Leetcode】106. Construct Binary Tree from Inorder and Postorder Traversal","slug":"【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal","date":"2019-04-22T14:12:25.000Z","updated":"2019-04-22T14:15:53.168Z","comments":true,"path":"2019/04/22/【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的中序遍历与后序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 123453 / \\9 20 / \\ 15 7 思路这道题是105基本相同，只不过，根节点在后续遍历数组的尾部，剩余都相同。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int il = 0, ir = inorder.size() - 1; int pl = 0, pr = postorder.size() - 1; return dfs(inorder, il, ir, postorder, pl, pr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; inorder, int il, int ir, vector&lt;int&gt;&amp; postorder, int pl, int pr)&#123; if(il &gt; ir || pl &gt; pr)&#123; return NULL; &#125; TreeNode* root = new TreeNode(postorder[pr]); int pos = 0; for(; pos &lt; ir; pos++)&#123; if(inorder[pos] == postorder[pr]) break; &#125; int len = pos - il; root-&gt;left = dfs(inorder, il, pos - 1, postorder, pl, pl + len - 1); root-&gt;right = dfs(inorder, pos + 1, ir, postorder, pl + len, pr - 1); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[]},{"title":"【Leetcode】105. Construct Binary Tree from Preorder and Inorder Traversal","slug":"【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","date":"2019-04-22T13:57:04.000Z","updated":"2019-04-22T14:10:51.617Z","comments":true,"path":"2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","link":"","permalink":"http://yoursite.com/2019/04/22/【Leetcode】105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","excerpt":"","text":"题目 判断是否是对称二叉树根据一棵树的前序遍历与中序遍历构造二叉树。你可以假设树中没有重复的元素。返回如下的二叉树： 案例前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 123453 / \\9 20 / \\ 15 7 思路这道题实际上就是前序遍历的是，中左右，中序遍历的顺序是左中右，那么前序遍历的第一个点就是根节点，我们在中序遍历的数组中找到根节点的位置，左边就是左子树，右边就是右子树，不断的递归；这个题之前做的时候，是每次都构造新的vector,但是这样就会爆栈溢出，实际上每次传递引用即可。 代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int pl = 0, pr = preorder.size() - 1; int vl = 0, vr = inorder.size() - 1; return dfs(preorder, pl, pr, inorder, vl, vr); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; preorder, int pl, int pr, vector&lt;int&gt;&amp; inorder, int vl, int vr)&#123; if(pl &gt; pr || vl &gt; vr)&#123; return NULL; &#125; int pos = 0; for(; pos &lt; vr; pos++)&#123; if(preorder[pl] == inorder[pos]) break; &#125; int len = pos - vl; TreeNode* root = new TreeNode(preorder[pl]); root-&gt;left = dfs(preorder, pl + 1, pl + len, inorder, vl, pos - 1); root-&gt;right = dfs(preorder, pl + len + 1, pr, inorder, pos + 1, vr); return root; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】101.Symmetric Tree","slug":"【Leetcode】101-Symmetric-Tree","date":"2019-04-08T13:50:58.000Z","updated":"2019-04-08T14:05:13.777Z","comments":true,"path":"2019/04/08/【Leetcode】101-Symmetric-Tree/","link":"","permalink":"http://yoursite.com/2019/04/08/【Leetcode】101-Symmetric-Tree/","excerpt":"","text":"题目 判断是否是对称二叉树给定一个二叉树，检查它是否是镜像对称的。 案例二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \\2 2 \\ \\ 3 3 思路这道题反反复复几次总容易想错，实际上要看这个二叉树的左右子树是不是对称二叉树，实际上是看左右节点的子树是不是对称二叉树，也就是左节点的左子树和右节点的右子树是不是对称的，左节点的右子树和右节点的左子树的不是对称的。具体代码如下； 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return issym(root-&gt;left, root-&gt;right); &#125; bool issym(TreeNode* left,TreeNode* right)&#123; if(!left &amp;&amp; !right) return true; if((!left &amp;&amp; right) || (left &amp;&amp; !right)) return false; if(left-&gt;val != right-&gt;val) return false; return issym(left-&gt;left, right-&gt;right) &amp;&amp; issym(left-&gt;right, right-&gt;left); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】81. Search in Rotated Sorted Array II","slug":"【Leetcode】81-Search-in-Rotated-Sorted-Array-II","date":"2019-03-06T14:53:38.000Z","updated":"2019-03-06T14:59:14.664Z","comments":true,"path":"2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】81-Search-in-Rotated-Sorted-Array-II/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 案例示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 思路这道题是33题的延伸，重复带来的问题就是，增加了判断哪边是有序的困难，比如[3 1 1] 和 [1 1 3 1]，对于这两种情况中间值等于最右值时，目标值3既可以在左边又可以在右边，那么其实，只要right和mid相等的话，我们直接将rihgt不断的减小就可以了。容易忘记等号！！！！ 代码123456789101112131415161718192021class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return true; if(nums[mid] &gt; nums[right])&#123; if(nums[mid] &gt; target &amp;&amp; target &gt;= nums[left]) right = mid - 1; else left = mid + 1; &#125;else if(nums[mid] &lt; nums[right])&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) left = mid + 1; else right = mid - 1; &#125;else right--; &#125; return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】33. Search in Rotated Sorted Array","slug":"【Leetcode】33-Search-in-Rotated-Sorted-Array","date":"2019-03-06T14:26:00.000Z","updated":"2019-03-06T14:37:20.833Z","comments":true,"path":"2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","link":"","permalink":"http://yoursite.com/2019/03/06/【Leetcode】33-Search-in-Rotated-Sorted-Array/","excerpt":"","text":"题目 搜索旋转数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路如果是没旋转的，直接用二分法就可以了，但是旋转后的问题就在于不知道应该去左边和右边哪边找，实际上，如果mid大于right的值的话，那么就知道mid是旋转过来的，也就是左边是有序的，那我们先判断target是不是在左边，如果不是那么就是在右边；反之，如果mid小于right,说明mid是没有被旋转，右边是有序的，那么就先判断是不是属于右边，如果不是的话就属于左边；容易忘记等号！！！！ 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0; int right = n-1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; if(nums[mid] &gt; nums[right])//左边有序 &#123; if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])//容易忘记等号 &#123; right = mid -1; &#125; else left = mid + 1; &#125; else//右边有序 &#123; if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid+1; &#125; else right = mid -1; &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"medium","slug":"medium","permalink":"http://yoursite.com/tags/medium/"}]},{"title":"【Leetcode】67.Add Binary","slug":"【Leetcode】67-Add-Binary","date":"2019-03-03T05:15:05.000Z","updated":"2019-03-09T02:28:02.801Z","comments":true,"path":"2019/03/03/【Leetcode】67-Add-Binary/","link":"","permalink":"http://yoursite.com/2019/03/03/【Leetcode】67-Add-Binary/","excerpt":"","text":"题目 合并区间给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 案例示例 1:12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2:12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 思路从后向前看，如果当前的的位不存在，那么直接赋值为0，否则的话，赋值为当前的字符值，并于carry相加，这样不断的循环，直到两个字符串都遍历结束；具体看代码：需要注意的是，每次取的时候要转化成int; 代码123456789101112131415class Solution &#123;public: string addBinary(string a, string b) &#123; string res = \"\"; int m = a.length() - 1, n = b.length() - 1, carry = 0; while(m &gt;= 0 || n &gt;= 0)&#123; int i = m &gt;= 0 ? a[m--] - '0' : 0; int j = n &gt;= 0 ? b[n--] - '0' : 0; int tem = i + j + carry; res = to_string(tem % 2) + res; carry = tem / 2; &#125; return carry == 1 ? \"1\" + res : res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"easy","slug":"easy","permalink":"http://yoursite.com/tags/easy/"}]},{"title":"【Leetcode】57.Insert Interval","slug":"【Leetcode】57-Insert-Interval","date":"2019-02-25T07:45:10.000Z","updated":"2019-02-25T08:15:23.310Z","comments":true,"path":"2019/02/25/【Leetcode】57-Insert-Interval/","link":"","permalink":"http://yoursite.com/2019/02/25/【Leetcode】57-Insert-Interval/","excerpt":"","text":"题目 合并区间给出一个无重叠的 ，按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 案例示例 1:12输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2:123输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 思路这个题和56题很像，唯一不同的就是是需要插入一个区间；思考这样的一个问题，这个区间应该插在哪里，实际上应该插在，该区间的start比原区间数组中的某一个元素的start刚好大于或者等于的情况；找到这个位置之后，就要考虑当前的插入区间是不是能直接插入还是需要和上一个区间合并，如果该区间的start比上一个区间的end要大的话，那么可以直接插入，或者还有一种特殊情况就是res中还没有区间，那么这两种情况都直接插入，否则的话就需要进行一次合并，合并的原则和56题一样，就是将当前res尾部的区间的end修改成插入区间的end和res尾部的end中的较大的值；然后再对剩余的区间依次做合并操作，最终得到结果； 代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); if(n == 0) &#123; res.push_back(newInterval); return res; &#125; int i = 0; for( ; i &lt; n; i++)&#123; if(newInterval.start &lt;= intervals[i].start) break; res.push_back(intervals[i]); &#125; if(i == 0 || newInterval.start &gt; intervals[i - 1].end) res.push_back(newInterval); else&#123; res.back().end = max(newInterval.end, res.back().end); &#125; for(; i &lt; n; i++)&#123; if(res.back().end &lt; intervals[i].start) res.push_back(intervals[i]); else res.back().end = max(res.back().end, intervals[i].end); &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"难","slug":"难","permalink":"http://yoursite.com/tags/难/"}]},{"title":"【Leetcode】56. Merge Intervals","slug":"【Leetcode】56-Merge-Intervals","date":"2019-02-24T15:07:06.000Z","updated":"2019-02-25T08:20:23.493Z","comments":true,"path":"2019/02/24/【Leetcode】56-Merge-Intervals/","link":"","permalink":"http://yoursite.com/2019/02/24/【Leetcode】56-Merge-Intervals/","excerpt":"","text":"题目 合并区间给出一个区间的集合，请合并所有重叠的区间。 案例示例 1:123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路首先将当前的区间按照start从低到高排序，如果后面一个区间的start比前一个的end要大，那么两者是没有重复的，直接将第二个放到当前的结果中；否则就是存在重复的区间，那就将当前res中最后一个区间的end，换成当前的end和原本的end的最大值；这个题目类似的题目是56题 代码123456789101112131415161718192021222324252627282930/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; if(n == 0) return res; sort(intervals.begin(), intervals.end(), cmp); res.push_back(intervals[0]); for(int i = 1; i &lt; n; i++)&#123; if(intervals[i].start &gt; res.back().end) res.push_back(intervals[i]); else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125; static bool cmp(Interval a, Interval b)&#123; return a.start &lt; b.start; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]},{"title":"关于c++ push ,pop小命令的笔记小抄","slug":"关于c-push-pop小命令的笔记小抄","date":"2019-02-23T03:04:33.000Z","updated":"2019-04-30T01:57:47.571Z","comments":true,"path":"2019/02/23/关于c-push-pop小命令的笔记小抄/","link":"","permalink":"http://yoursite.com/2019/02/23/关于c-push-pop小命令的笔记小抄/","excerpt":"","text":"set 插入：insert; vector 插入：push_back; 删除：pop_back; queuemap 访问map的key 和 value 的时候，是m.second 或者 m.first","categories":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"http://yoursite.com/categories/Cplusplus/"}],"tags":[{"name":"c++习惯总结","slug":"c-习惯总结","permalink":"http://yoursite.com/tags/c-习惯总结/"}]},{"title":"leetcode之间的关系捋一捋","slug":"leetcode之间的关系捋一捋","date":"2019-02-23T02:21:44.000Z","updated":"2019-06-22T06:11:12.693Z","comments":true,"path":"2019/02/23/leetcode之间的关系捋一捋/","link":"","permalink":"http://yoursite.com/2019/02/23/leetcode之间的关系捋一捋/","excerpt":"","text":"组合类型 Permutations47. 39.40。 数组双指针【Leetcode】11.盛最多水的容器 求和问题双指针最后返回的是和值有关【Leetcode】15-3Sum【Leetcode】16-最接近的三数之和【Leetcode】16-最接近的三数之和map解决，返回的是下标Leetcode】1-Two-Sum 两个指针，一个指针用来锁定位置，一个用来遍历【Leetcode】26-删除排序数组中的重复项【Leetcode】27-移除元素","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"知识点梳理","slug":"知识点梳理","permalink":"http://yoursite.com/tags/知识点梳理/"}]},{"title":"【leetcode】36. Valid Sudoku","slug":"【leetcode】36-Valid-Sudoku","date":"2019-02-21T14:09:21.000Z","updated":"2019-04-30T01:43:21.464Z","comments":true,"path":"2019/02/21/【leetcode】36-Valid-Sudoku/","link":"","permalink":"http://yoursite.com/2019/02/21/【leetcode】36-Valid-Sudoku/","excerpt":"","text":"题目 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 案例示例 1: 输入:12345678910111213[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:123456789101112输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] 输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 思路设置三个标志矩阵，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下，如下代码； 代码12345678910111213141516171819202122232425class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int n = board.size(); vector&lt;vector&lt;bool&gt;&gt; iscol(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; isrow(n,vector&lt;bool&gt;(n,false)); vector&lt;vector&lt;bool&gt;&gt; ismini(n,vector&lt;bool&gt;(n,false)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9') &#123; int t = board[i][j] - '1'; if(iscol[t][j] || isrow[i][t] || ismini[3 * (i / 3) + j / 3][t]) return false; iscol[t][j] = true; isrow[i][t] = true; ismini[3 * (i / 3) + j / 3][t] = true; &#125; &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]}]}